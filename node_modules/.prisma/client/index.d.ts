
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model category
 * 
 */
export type category = $Result.DefaultSelection<Prisma.$categoryPayload>
/**
 * Model units
 * 
 */
export type units = $Result.DefaultSelection<Prisma.$unitsPayload>
/**
 * Model brands
 * 
 */
export type brands = $Result.DefaultSelection<Prisma.$brandsPayload>
/**
 * Model items
 * 
 */
export type items = $Result.DefaultSelection<Prisma.$itemsPayload>
/**
 * Model supplier
 * 
 */
export type supplier = $Result.DefaultSelection<Prisma.$supplierPayload>
/**
 * Model purchaseitems
 * 
 */
export type purchaseitems = $Result.DefaultSelection<Prisma.$purchaseitemsPayload>
/**
 * Model purchase
 * 
 */
export type purchase = $Result.DefaultSelection<Prisma.$purchasePayload>
/**
 * Model sales
 * 
 */
export type sales = $Result.DefaultSelection<Prisma.$salesPayload>
/**
 * Model customertype
 * 
 */
export type customertype = $Result.DefaultSelection<Prisma.$customertypePayload>
/**
 * Model customer
 * 
 */
export type customer = $Result.DefaultSelection<Prisma.$customerPayload>
/**
 * Model salescustomertracker
 * 
 */
export type salescustomertracker = $Result.DefaultSelection<Prisma.$salescustomertrackerPayload>
/**
 * Model customerpayment
 * 
 */
export type customerpayment = $Result.DefaultSelection<Prisma.$customerpaymentPayload>
/**
 * Model customerledger
 * 
 */
export type customerledger = $Result.DefaultSelection<Prisma.$customerledgerPayload>
/**
 * Model purchasesuppliertrack
 * 
 */
export type purchasesuppliertrack = $Result.DefaultSelection<Prisma.$purchasesuppliertrackPayload>
/**
 * Model transaction
 * 
 */
export type transaction = $Result.DefaultSelection<Prisma.$transactionPayload>
/**
 * Model supplierledger
 * 
 */
export type supplierledger = $Result.DefaultSelection<Prisma.$supplierledgerPayload>
/**
 * Model customerdetails
 * 
 */
export type customerdetails = $Result.DefaultSelection<Prisma.$customerdetailsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.categoryDelegate<ExtArgs>;

  /**
   * `prisma.units`: Exposes CRUD operations for the **units** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.units.findMany()
    * ```
    */
  get units(): Prisma.unitsDelegate<ExtArgs>;

  /**
   * `prisma.brands`: Exposes CRUD operations for the **brands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brands.findMany()
    * ```
    */
  get brands(): Prisma.brandsDelegate<ExtArgs>;

  /**
   * `prisma.items`: Exposes CRUD operations for the **items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.items.findMany()
    * ```
    */
  get items(): Prisma.itemsDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.supplierDelegate<ExtArgs>;

  /**
   * `prisma.purchaseitems`: Exposes CRUD operations for the **purchaseitems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchaseitems
    * const purchaseitems = await prisma.purchaseitems.findMany()
    * ```
    */
  get purchaseitems(): Prisma.purchaseitemsDelegate<ExtArgs>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.purchaseDelegate<ExtArgs>;

  /**
   * `prisma.sales`: Exposes CRUD operations for the **sales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sales.findMany()
    * ```
    */
  get sales(): Prisma.salesDelegate<ExtArgs>;

  /**
   * `prisma.customertype`: Exposes CRUD operations for the **customertype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customertypes
    * const customertypes = await prisma.customertype.findMany()
    * ```
    */
  get customertype(): Prisma.customertypeDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.customerDelegate<ExtArgs>;

  /**
   * `prisma.salescustomertracker`: Exposes CRUD operations for the **salescustomertracker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salescustomertrackers
    * const salescustomertrackers = await prisma.salescustomertracker.findMany()
    * ```
    */
  get salescustomertracker(): Prisma.salescustomertrackerDelegate<ExtArgs>;

  /**
   * `prisma.customerpayment`: Exposes CRUD operations for the **customerpayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customerpayments
    * const customerpayments = await prisma.customerpayment.findMany()
    * ```
    */
  get customerpayment(): Prisma.customerpaymentDelegate<ExtArgs>;

  /**
   * `prisma.customerledger`: Exposes CRUD operations for the **customerledger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customerledgers
    * const customerledgers = await prisma.customerledger.findMany()
    * ```
    */
  get customerledger(): Prisma.customerledgerDelegate<ExtArgs>;

  /**
   * `prisma.purchasesuppliertrack`: Exposes CRUD operations for the **purchasesuppliertrack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchasesuppliertracks
    * const purchasesuppliertracks = await prisma.purchasesuppliertrack.findMany()
    * ```
    */
  get purchasesuppliertrack(): Prisma.purchasesuppliertrackDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.transactionDelegate<ExtArgs>;

  /**
   * `prisma.supplierledger`: Exposes CRUD operations for the **supplierledger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Supplierledgers
    * const supplierledgers = await prisma.supplierledger.findMany()
    * ```
    */
  get supplierledger(): Prisma.supplierledgerDelegate<ExtArgs>;

  /**
   * `prisma.customerdetails`: Exposes CRUD operations for the **customerdetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customerdetails
    * const customerdetails = await prisma.customerdetails.findMany()
    * ```
    */
  get customerdetails(): Prisma.customerdetailsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.15.0
   * Query Engine version: 12e25d8d06f6ea5a0252864dd9a03b1bb51f3022
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    category: 'category',
    units: 'units',
    brands: 'brands',
    items: 'items',
    supplier: 'supplier',
    purchaseitems: 'purchaseitems',
    purchase: 'purchase',
    sales: 'sales',
    customertype: 'customertype',
    customer: 'customer',
    salescustomertracker: 'salescustomertracker',
    customerpayment: 'customerpayment',
    customerledger: 'customerledger',
    purchasesuppliertrack: 'purchasesuppliertrack',
    transaction: 'transaction',
    supplierledger: 'supplierledger',
    customerdetails: 'customerdetails'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'category' | 'units' | 'brands' | 'items' | 'supplier' | 'purchaseitems' | 'purchase' | 'sales' | 'customertype' | 'customer' | 'salescustomertracker' | 'customerpayment' | 'customerledger' | 'purchasesuppliertrack' | 'transaction' | 'supplierledger' | 'customerdetails'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      category: {
        payload: Prisma.$categoryPayload<ExtArgs>
        fields: Prisma.categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findFirst: {
            args: Prisma.categoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findMany: {
            args: Prisma.categoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          create: {
            args: Prisma.categoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          createMany: {
            args: Prisma.categoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.categoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          update: {
            args: Prisma.categoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          deleteMany: {
            args: Prisma.categoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.categoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.categoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.categoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      units: {
        payload: Prisma.$unitsPayload<ExtArgs>
        fields: Prisma.unitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.unitsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$unitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.unitsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$unitsPayload>
          }
          findFirst: {
            args: Prisma.unitsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$unitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.unitsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$unitsPayload>
          }
          findMany: {
            args: Prisma.unitsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$unitsPayload>[]
          }
          create: {
            args: Prisma.unitsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$unitsPayload>
          }
          createMany: {
            args: Prisma.unitsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.unitsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$unitsPayload>
          }
          update: {
            args: Prisma.unitsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$unitsPayload>
          }
          deleteMany: {
            args: Prisma.unitsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.unitsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.unitsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$unitsPayload>
          }
          aggregate: {
            args: Prisma.UnitsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUnits>
          }
          groupBy: {
            args: Prisma.unitsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UnitsGroupByOutputType>[]
          }
          count: {
            args: Prisma.unitsCountArgs<ExtArgs>,
            result: $Utils.Optional<UnitsCountAggregateOutputType> | number
          }
        }
      }
      brands: {
        payload: Prisma.$brandsPayload<ExtArgs>
        fields: Prisma.brandsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.brandsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.brandsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          findFirst: {
            args: Prisma.brandsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.brandsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          findMany: {
            args: Prisma.brandsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>[]
          }
          create: {
            args: Prisma.brandsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          createMany: {
            args: Prisma.brandsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.brandsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          update: {
            args: Prisma.brandsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          deleteMany: {
            args: Prisma.brandsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.brandsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.brandsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          aggregate: {
            args: Prisma.BrandsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBrands>
          }
          groupBy: {
            args: Prisma.brandsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BrandsGroupByOutputType>[]
          }
          count: {
            args: Prisma.brandsCountArgs<ExtArgs>,
            result: $Utils.Optional<BrandsCountAggregateOutputType> | number
          }
        }
      }
      items: {
        payload: Prisma.$itemsPayload<ExtArgs>
        fields: Prisma.itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          findFirst: {
            args: Prisma.itemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          findMany: {
            args: Prisma.itemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>[]
          }
          create: {
            args: Prisma.itemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          createMany: {
            args: Prisma.itemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.itemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          update: {
            args: Prisma.itemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          deleteMany: {
            args: Prisma.itemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.itemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.itemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          aggregate: {
            args: Prisma.ItemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItems>
          }
          groupBy: {
            args: Prisma.itemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.itemsCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemsCountAggregateOutputType> | number
          }
        }
      }
      supplier: {
        payload: Prisma.$supplierPayload<ExtArgs>
        fields: Prisma.supplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.supplierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.supplierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          findFirst: {
            args: Prisma.supplierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.supplierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          findMany: {
            args: Prisma.supplierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>[]
          }
          create: {
            args: Prisma.supplierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          createMany: {
            args: Prisma.supplierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.supplierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          update: {
            args: Prisma.supplierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          deleteMany: {
            args: Prisma.supplierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.supplierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.supplierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.supplierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.supplierCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      purchaseitems: {
        payload: Prisma.$purchaseitemsPayload<ExtArgs>
        fields: Prisma.purchaseitemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.purchaseitemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchaseitemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.purchaseitemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchaseitemsPayload>
          }
          findFirst: {
            args: Prisma.purchaseitemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchaseitemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.purchaseitemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchaseitemsPayload>
          }
          findMany: {
            args: Prisma.purchaseitemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchaseitemsPayload>[]
          }
          create: {
            args: Prisma.purchaseitemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchaseitemsPayload>
          }
          createMany: {
            args: Prisma.purchaseitemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.purchaseitemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchaseitemsPayload>
          }
          update: {
            args: Prisma.purchaseitemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchaseitemsPayload>
          }
          deleteMany: {
            args: Prisma.purchaseitemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.purchaseitemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.purchaseitemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchaseitemsPayload>
          }
          aggregate: {
            args: Prisma.PurchaseitemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePurchaseitems>
          }
          groupBy: {
            args: Prisma.purchaseitemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseitemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.purchaseitemsCountArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseitemsCountAggregateOutputType> | number
          }
        }
      }
      purchase: {
        payload: Prisma.$purchasePayload<ExtArgs>
        fields: Prisma.purchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.purchaseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.purchaseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>
          }
          findFirst: {
            args: Prisma.purchaseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.purchaseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>
          }
          findMany: {
            args: Prisma.purchaseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>[]
          }
          create: {
            args: Prisma.purchaseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>
          }
          createMany: {
            args: Prisma.purchaseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.purchaseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>
          }
          update: {
            args: Prisma.purchaseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>
          }
          deleteMany: {
            args: Prisma.purchaseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.purchaseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.purchaseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.purchaseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.purchaseCountArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      sales: {
        payload: Prisma.$salesPayload<ExtArgs>
        fields: Prisma.salesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.salesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.salesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salesPayload>
          }
          findFirst: {
            args: Prisma.salesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.salesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salesPayload>
          }
          findMany: {
            args: Prisma.salesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salesPayload>[]
          }
          create: {
            args: Prisma.salesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salesPayload>
          }
          createMany: {
            args: Prisma.salesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.salesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salesPayload>
          }
          update: {
            args: Prisma.salesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salesPayload>
          }
          deleteMany: {
            args: Prisma.salesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.salesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.salesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salesPayload>
          }
          aggregate: {
            args: Prisma.SalesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSales>
          }
          groupBy: {
            args: Prisma.salesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SalesGroupByOutputType>[]
          }
          count: {
            args: Prisma.salesCountArgs<ExtArgs>,
            result: $Utils.Optional<SalesCountAggregateOutputType> | number
          }
        }
      }
      customertype: {
        payload: Prisma.$customertypePayload<ExtArgs>
        fields: Prisma.customertypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customertypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customertypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customertypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customertypePayload>
          }
          findFirst: {
            args: Prisma.customertypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customertypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customertypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customertypePayload>
          }
          findMany: {
            args: Prisma.customertypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customertypePayload>[]
          }
          create: {
            args: Prisma.customertypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customertypePayload>
          }
          createMany: {
            args: Prisma.customertypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.customertypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customertypePayload>
          }
          update: {
            args: Prisma.customertypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customertypePayload>
          }
          deleteMany: {
            args: Prisma.customertypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.customertypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.customertypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customertypePayload>
          }
          aggregate: {
            args: Prisma.CustomertypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomertype>
          }
          groupBy: {
            args: Prisma.customertypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomertypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.customertypeCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomertypeCountAggregateOutputType> | number
          }
        }
      }
      customer: {
        payload: Prisma.$customerPayload<ExtArgs>
        fields: Prisma.customerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findFirst: {
            args: Prisma.customerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findMany: {
            args: Prisma.customerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          create: {
            args: Prisma.customerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          createMany: {
            args: Prisma.customerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.customerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          update: {
            args: Prisma.customerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          deleteMany: {
            args: Prisma.customerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.customerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.customerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.customerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      salescustomertracker: {
        payload: Prisma.$salescustomertrackerPayload<ExtArgs>
        fields: Prisma.salescustomertrackerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.salescustomertrackerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salescustomertrackerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.salescustomertrackerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salescustomertrackerPayload>
          }
          findFirst: {
            args: Prisma.salescustomertrackerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salescustomertrackerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.salescustomertrackerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salescustomertrackerPayload>
          }
          findMany: {
            args: Prisma.salescustomertrackerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salescustomertrackerPayload>[]
          }
          create: {
            args: Prisma.salescustomertrackerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salescustomertrackerPayload>
          }
          createMany: {
            args: Prisma.salescustomertrackerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.salescustomertrackerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salescustomertrackerPayload>
          }
          update: {
            args: Prisma.salescustomertrackerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salescustomertrackerPayload>
          }
          deleteMany: {
            args: Prisma.salescustomertrackerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.salescustomertrackerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.salescustomertrackerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$salescustomertrackerPayload>
          }
          aggregate: {
            args: Prisma.SalescustomertrackerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSalescustomertracker>
          }
          groupBy: {
            args: Prisma.salescustomertrackerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SalescustomertrackerGroupByOutputType>[]
          }
          count: {
            args: Prisma.salescustomertrackerCountArgs<ExtArgs>,
            result: $Utils.Optional<SalescustomertrackerCountAggregateOutputType> | number
          }
        }
      }
      customerpayment: {
        payload: Prisma.$customerpaymentPayload<ExtArgs>
        fields: Prisma.customerpaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerpaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerpaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerpaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerpaymentPayload>
          }
          findFirst: {
            args: Prisma.customerpaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerpaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerpaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerpaymentPayload>
          }
          findMany: {
            args: Prisma.customerpaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerpaymentPayload>[]
          }
          create: {
            args: Prisma.customerpaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerpaymentPayload>
          }
          createMany: {
            args: Prisma.customerpaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.customerpaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerpaymentPayload>
          }
          update: {
            args: Prisma.customerpaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerpaymentPayload>
          }
          deleteMany: {
            args: Prisma.customerpaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.customerpaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.customerpaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerpaymentPayload>
          }
          aggregate: {
            args: Prisma.CustomerpaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomerpayment>
          }
          groupBy: {
            args: Prisma.customerpaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomerpaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerpaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomerpaymentCountAggregateOutputType> | number
          }
        }
      }
      customerledger: {
        payload: Prisma.$customerledgerPayload<ExtArgs>
        fields: Prisma.customerledgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerledgerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerledgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerledgerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerledgerPayload>
          }
          findFirst: {
            args: Prisma.customerledgerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerledgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerledgerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerledgerPayload>
          }
          findMany: {
            args: Prisma.customerledgerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerledgerPayload>[]
          }
          create: {
            args: Prisma.customerledgerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerledgerPayload>
          }
          createMany: {
            args: Prisma.customerledgerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.customerledgerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerledgerPayload>
          }
          update: {
            args: Prisma.customerledgerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerledgerPayload>
          }
          deleteMany: {
            args: Prisma.customerledgerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.customerledgerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.customerledgerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerledgerPayload>
          }
          aggregate: {
            args: Prisma.CustomerledgerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomerledger>
          }
          groupBy: {
            args: Prisma.customerledgerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomerledgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerledgerCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomerledgerCountAggregateOutputType> | number
          }
        }
      }
      purchasesuppliertrack: {
        payload: Prisma.$purchasesuppliertrackPayload<ExtArgs>
        fields: Prisma.purchasesuppliertrackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.purchasesuppliertrackFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasesuppliertrackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.purchasesuppliertrackFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasesuppliertrackPayload>
          }
          findFirst: {
            args: Prisma.purchasesuppliertrackFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasesuppliertrackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.purchasesuppliertrackFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasesuppliertrackPayload>
          }
          findMany: {
            args: Prisma.purchasesuppliertrackFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasesuppliertrackPayload>[]
          }
          create: {
            args: Prisma.purchasesuppliertrackCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasesuppliertrackPayload>
          }
          createMany: {
            args: Prisma.purchasesuppliertrackCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.purchasesuppliertrackDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasesuppliertrackPayload>
          }
          update: {
            args: Prisma.purchasesuppliertrackUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasesuppliertrackPayload>
          }
          deleteMany: {
            args: Prisma.purchasesuppliertrackDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.purchasesuppliertrackUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.purchasesuppliertrackUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasesuppliertrackPayload>
          }
          aggregate: {
            args: Prisma.PurchasesuppliertrackAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePurchasesuppliertrack>
          }
          groupBy: {
            args: Prisma.purchasesuppliertrackGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PurchasesuppliertrackGroupByOutputType>[]
          }
          count: {
            args: Prisma.purchasesuppliertrackCountArgs<ExtArgs>,
            result: $Utils.Optional<PurchasesuppliertrackCountAggregateOutputType> | number
          }
        }
      }
      transaction: {
        payload: Prisma.$transactionPayload<ExtArgs>
        fields: Prisma.transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          findFirst: {
            args: Prisma.transactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          findMany: {
            args: Prisma.transactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          create: {
            args: Prisma.transactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          createMany: {
            args: Prisma.transactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.transactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          update: {
            args: Prisma.transactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          deleteMany: {
            args: Prisma.transactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.transactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.transactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.transactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionCountArgs<ExtArgs>,
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      supplierledger: {
        payload: Prisma.$supplierledgerPayload<ExtArgs>
        fields: Prisma.supplierledgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.supplierledgerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierledgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.supplierledgerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierledgerPayload>
          }
          findFirst: {
            args: Prisma.supplierledgerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierledgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.supplierledgerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierledgerPayload>
          }
          findMany: {
            args: Prisma.supplierledgerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierledgerPayload>[]
          }
          create: {
            args: Prisma.supplierledgerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierledgerPayload>
          }
          createMany: {
            args: Prisma.supplierledgerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.supplierledgerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierledgerPayload>
          }
          update: {
            args: Prisma.supplierledgerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierledgerPayload>
          }
          deleteMany: {
            args: Prisma.supplierledgerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.supplierledgerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.supplierledgerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierledgerPayload>
          }
          aggregate: {
            args: Prisma.SupplierledgerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplierledger>
          }
          groupBy: {
            args: Prisma.supplierledgerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplierledgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.supplierledgerCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplierledgerCountAggregateOutputType> | number
          }
        }
      }
      customerdetails: {
        payload: Prisma.$customerdetailsPayload<ExtArgs>
        fields: Prisma.customerdetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerdetailsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerdetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerdetailsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerdetailsPayload>
          }
          findFirst: {
            args: Prisma.customerdetailsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerdetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerdetailsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerdetailsPayload>
          }
          findMany: {
            args: Prisma.customerdetailsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerdetailsPayload>[]
          }
          create: {
            args: Prisma.customerdetailsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerdetailsPayload>
          }
          createMany: {
            args: Prisma.customerdetailsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.customerdetailsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerdetailsPayload>
          }
          update: {
            args: Prisma.customerdetailsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerdetailsPayload>
          }
          deleteMany: {
            args: Prisma.customerdetailsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.customerdetailsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.customerdetailsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerdetailsPayload>
          }
          aggregate: {
            args: Prisma.CustomerdetailsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomerdetails>
          }
          groupBy: {
            args: Prisma.customerdetailsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomerdetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerdetailsCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomerdetailsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    items: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CategoryCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
  }


  /**
   * Count Type UnitsCountOutputType
   */

  export type UnitsCountOutputType = {
    items: number
  }

  export type UnitsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | UnitsCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * UnitsCountOutputType without action
   */
  export type UnitsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitsCountOutputType
     */
    select?: UnitsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitsCountOutputType without action
   */
  export type UnitsCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
  }


  /**
   * Count Type BrandsCountOutputType
   */

  export type BrandsCountOutputType = {
    items: number
  }

  export type BrandsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | BrandsCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandsCountOutputType
     */
    select?: BrandsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
  }


  /**
   * Count Type ItemsCountOutputType
   */

  export type ItemsCountOutputType = {
    purchaseitems: number
    Purchase: number
    sales: number
  }

  export type ItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseitems?: boolean | ItemsCountOutputTypeCountPurchaseitemsArgs
    Purchase?: boolean | ItemsCountOutputTypeCountPurchaseArgs
    sales?: boolean | ItemsCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * ItemsCountOutputType without action
   */
  export type ItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsCountOutputType
     */
    select?: ItemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemsCountOutputType without action
   */
  export type ItemsCountOutputTypeCountPurchaseitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: purchaseitemsWhereInput
  }

  /**
   * ItemsCountOutputType without action
   */
  export type ItemsCountOutputTypeCountPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: purchaseWhereInput
  }

  /**
   * ItemsCountOutputType without action
   */
  export type ItemsCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: salesWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    purchaseitems: number
    Purchase: number
    purchasesuppliertrack: number
    transaction: number
    supplierledger: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseitems?: boolean | SupplierCountOutputTypeCountPurchaseitemsArgs
    Purchase?: boolean | SupplierCountOutputTypeCountPurchaseArgs
    purchasesuppliertrack?: boolean | SupplierCountOutputTypeCountPurchasesuppliertrackArgs
    transaction?: boolean | SupplierCountOutputTypeCountTransactionArgs
    supplierledger?: boolean | SupplierCountOutputTypeCountSupplierledgerArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: purchaseitemsWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: purchaseWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchasesuppliertrackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: purchasesuppliertrackWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountSupplierledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: supplierledgerWhereInput
  }


  /**
   * Count Type CustomertypeCountOutputType
   */

  export type CustomertypeCountOutputType = {
    customer: number
    customerpayment: number
  }

  export type CustomertypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomertypeCountOutputTypeCountCustomerArgs
    customerpayment?: boolean | CustomertypeCountOutputTypeCountCustomerpaymentArgs
  }

  // Custom InputTypes
  /**
   * CustomertypeCountOutputType without action
   */
  export type CustomertypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomertypeCountOutputType
     */
    select?: CustomertypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomertypeCountOutputType without action
   */
  export type CustomertypeCountOutputTypeCountCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
  }

  /**
   * CustomertypeCountOutputType without action
   */
  export type CustomertypeCountOutputTypeCountCustomerpaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerpaymentWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    customerdetails: number
    sales: number
    salescustomertracker: number
    customerledger: number
    customerpayment: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerdetails?: boolean | CustomerCountOutputTypeCountCustomerdetailsArgs
    sales?: boolean | CustomerCountOutputTypeCountSalesArgs
    salescustomertracker?: boolean | CustomerCountOutputTypeCountSalescustomertrackerArgs
    customerledger?: boolean | CustomerCountOutputTypeCountCustomerledgerArgs
    customerpayment?: boolean | CustomerCountOutputTypeCountCustomerpaymentArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerdetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerdetailsWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: salesWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalescustomertrackerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: salescustomertrackerWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerledgerWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerpaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerpaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>


  export type userSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly email: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly role: FieldRef<"user", 'String'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
  }


  /**
   * Model category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    category_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    category_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    category_name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    category_name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    category_name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    category_name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category to aggregate.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithAggregationInput | categoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    category_name: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | category$itemsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>


  export type categorySelectScalar = {
    id?: boolean
    category_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | category$itemsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category"
    objects: {
      items: Prisma.$itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category_name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type categoryGetPayload<S extends boolean | null | undefined | categoryDefaultArgs> = $Result.GetResult<Prisma.$categoryPayload, S>

  type categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<categoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category'], meta: { name: 'category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {categoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, categoryFindUniqueArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {categoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindFirstArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends categoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Category.
     * @param {categoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends categoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, categoryCreateArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {categoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends categoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {categoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends categoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, categoryDeleteArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Category.
     * @param {categoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, categoryUpdateArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {categoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, categoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {categoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends categoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, categoryUpsertArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoryCountArgs>(
      args?: Subset<T, categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoryGroupByArgs['orderBy'] }
        : { orderBy?: categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category model
   */
  readonly fields: categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    items<T extends category$itemsArgs<ExtArgs> = {}>(args?: Subset<T, category$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the category model
   */ 
  interface categoryFieldRefs {
    readonly id: FieldRef<"category", 'Int'>
    readonly category_name: FieldRef<"category", 'String'>
    readonly createdAt: FieldRef<"category", 'DateTime'>
    readonly updatedAt: FieldRef<"category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * category findUnique
   */
  export type categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findUniqueOrThrow
   */
  export type categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findFirst
   */
  export type categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findFirstOrThrow
   */
  export type categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findMany
   */
  export type categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category create
   */
  export type categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a category.
     */
    data: XOR<categoryCreateInput, categoryUncheckedCreateInput>
  }

  /**
   * category createMany
   */
  export type categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category update
   */
  export type categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a category.
     */
    data: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
    /**
     * Choose, which category to update.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category updateMany
   */
  export type categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
  }

  /**
   * category upsert
   */
  export type categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the category to update in case it exists.
     */
    where: categoryWhereUniqueInput
    /**
     * In case the category found by the `where` argument doesn't exist, create a new category with this data.
     */
    create: XOR<categoryCreateInput, categoryUncheckedCreateInput>
    /**
     * In case the category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
  }

  /**
   * category delete
   */
  export type categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter which category to delete.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category deleteMany
   */
  export type categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoryWhereInput
  }

  /**
   * category.items
   */
  export type category$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    cursor?: itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * category without action
   */
  export type categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
  }


  /**
   * Model units
   */

  export type AggregateUnits = {
    _count: UnitsCountAggregateOutputType | null
    _avg: UnitsAvgAggregateOutputType | null
    _sum: UnitsSumAggregateOutputType | null
    _min: UnitsMinAggregateOutputType | null
    _max: UnitsMaxAggregateOutputType | null
  }

  export type UnitsAvgAggregateOutputType = {
    id: number | null
    relation: number | null
  }

  export type UnitsSumAggregateOutputType = {
    id: number | null
    relation: number | null
  }

  export type UnitsMinAggregateOutputType = {
    id: number | null
    units_name: string | null
    units_label: string | null
    relation: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitsMaxAggregateOutputType = {
    id: number | null
    units_name: string | null
    units_label: string | null
    relation: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitsCountAggregateOutputType = {
    id: number
    units_name: number
    units_label: number
    relation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitsAvgAggregateInputType = {
    id?: true
    relation?: true
  }

  export type UnitsSumAggregateInputType = {
    id?: true
    relation?: true
  }

  export type UnitsMinAggregateInputType = {
    id?: true
    units_name?: true
    units_label?: true
    relation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitsMaxAggregateInputType = {
    id?: true
    units_name?: true
    units_label?: true
    relation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitsCountAggregateInputType = {
    id?: true
    units_name?: true
    units_label?: true
    relation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which units to aggregate.
     */
    where?: unitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of units to fetch.
     */
    orderBy?: unitsOrderByWithRelationInput | unitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: unitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned units
    **/
    _count?: true | UnitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitsMaxAggregateInputType
  }

  export type GetUnitsAggregateType<T extends UnitsAggregateArgs> = {
        [P in keyof T & keyof AggregateUnits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnits[P]>
      : GetScalarType<T[P], AggregateUnits[P]>
  }




  export type unitsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: unitsWhereInput
    orderBy?: unitsOrderByWithAggregationInput | unitsOrderByWithAggregationInput[]
    by: UnitsScalarFieldEnum[] | UnitsScalarFieldEnum
    having?: unitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitsCountAggregateInputType | true
    _avg?: UnitsAvgAggregateInputType
    _sum?: UnitsSumAggregateInputType
    _min?: UnitsMinAggregateInputType
    _max?: UnitsMaxAggregateInputType
  }

  export type UnitsGroupByOutputType = {
    id: number
    units_name: string
    units_label: string
    relation: number
    createdAt: Date
    updatedAt: Date
    _count: UnitsCountAggregateOutputType | null
    _avg: UnitsAvgAggregateOutputType | null
    _sum: UnitsSumAggregateOutputType | null
    _min: UnitsMinAggregateOutputType | null
    _max: UnitsMaxAggregateOutputType | null
  }

  type GetUnitsGroupByPayload<T extends unitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitsGroupByOutputType[P]>
            : GetScalarType<T[P], UnitsGroupByOutputType[P]>
        }
      >
    >


  export type unitsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    units_name?: boolean
    units_label?: boolean
    relation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | units$itemsArgs<ExtArgs>
    _count?: boolean | UnitsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["units"]>


  export type unitsSelectScalar = {
    id?: boolean
    units_name?: boolean
    units_label?: boolean
    relation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type unitsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | units$itemsArgs<ExtArgs>
    _count?: boolean | UnitsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $unitsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "units"
    objects: {
      items: Prisma.$itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      units_name: string
      units_label: string
      relation: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["units"]>
    composites: {}
  }

  type unitsGetPayload<S extends boolean | null | undefined | unitsDefaultArgs> = $Result.GetResult<Prisma.$unitsPayload, S>

  type unitsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<unitsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitsCountAggregateInputType | true
    }

  export interface unitsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['units'], meta: { name: 'units' } }
    /**
     * Find zero or one Units that matches the filter.
     * @param {unitsFindUniqueArgs} args - Arguments to find a Units
     * @example
     * // Get one Units
     * const units = await prisma.units.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends unitsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, unitsFindUniqueArgs<ExtArgs>>
    ): Prisma__unitsClient<$Result.GetResult<Prisma.$unitsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Units that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {unitsFindUniqueOrThrowArgs} args - Arguments to find a Units
     * @example
     * // Get one Units
     * const units = await prisma.units.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends unitsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, unitsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__unitsClient<$Result.GetResult<Prisma.$unitsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unitsFindFirstArgs} args - Arguments to find a Units
     * @example
     * // Get one Units
     * const units = await prisma.units.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends unitsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, unitsFindFirstArgs<ExtArgs>>
    ): Prisma__unitsClient<$Result.GetResult<Prisma.$unitsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Units that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unitsFindFirstOrThrowArgs} args - Arguments to find a Units
     * @example
     * // Get one Units
     * const units = await prisma.units.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends unitsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, unitsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__unitsClient<$Result.GetResult<Prisma.$unitsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unitsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.units.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.units.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitsWithIdOnly = await prisma.units.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends unitsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, unitsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unitsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Units.
     * @param {unitsCreateArgs} args - Arguments to create a Units.
     * @example
     * // Create one Units
     * const Units = await prisma.units.create({
     *   data: {
     *     // ... data to create a Units
     *   }
     * })
     * 
    **/
    create<T extends unitsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, unitsCreateArgs<ExtArgs>>
    ): Prisma__unitsClient<$Result.GetResult<Prisma.$unitsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Units.
     * @param {unitsCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const units = await prisma.units.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends unitsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, unitsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Units.
     * @param {unitsDeleteArgs} args - Arguments to delete one Units.
     * @example
     * // Delete one Units
     * const Units = await prisma.units.delete({
     *   where: {
     *     // ... filter to delete one Units
     *   }
     * })
     * 
    **/
    delete<T extends unitsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, unitsDeleteArgs<ExtArgs>>
    ): Prisma__unitsClient<$Result.GetResult<Prisma.$unitsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Units.
     * @param {unitsUpdateArgs} args - Arguments to update one Units.
     * @example
     * // Update one Units
     * const units = await prisma.units.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends unitsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, unitsUpdateArgs<ExtArgs>>
    ): Prisma__unitsClient<$Result.GetResult<Prisma.$unitsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Units.
     * @param {unitsDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.units.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends unitsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, unitsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const units = await prisma.units.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends unitsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, unitsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Units.
     * @param {unitsUpsertArgs} args - Arguments to update or create a Units.
     * @example
     * // Update or create a Units
     * const units = await prisma.units.upsert({
     *   create: {
     *     // ... data to create a Units
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Units we want to update
     *   }
     * })
    **/
    upsert<T extends unitsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, unitsUpsertArgs<ExtArgs>>
    ): Prisma__unitsClient<$Result.GetResult<Prisma.$unitsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unitsCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.units.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends unitsCountArgs>(
      args?: Subset<T, unitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitsAggregateArgs>(args: Subset<T, UnitsAggregateArgs>): Prisma.PrismaPromise<GetUnitsAggregateType<T>>

    /**
     * Group by Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends unitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: unitsGroupByArgs['orderBy'] }
        : { orderBy?: unitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, unitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the units model
   */
  readonly fields: unitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for units.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__unitsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    items<T extends units$itemsArgs<ExtArgs> = {}>(args?: Subset<T, units$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the units model
   */ 
  interface unitsFieldRefs {
    readonly id: FieldRef<"units", 'Int'>
    readonly units_name: FieldRef<"units", 'String'>
    readonly units_label: FieldRef<"units", 'String'>
    readonly relation: FieldRef<"units", 'Float'>
    readonly createdAt: FieldRef<"units", 'DateTime'>
    readonly updatedAt: FieldRef<"units", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * units findUnique
   */
  export type unitsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the units
     */
    select?: unitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitsInclude<ExtArgs> | null
    /**
     * Filter, which units to fetch.
     */
    where: unitsWhereUniqueInput
  }

  /**
   * units findUniqueOrThrow
   */
  export type unitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the units
     */
    select?: unitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitsInclude<ExtArgs> | null
    /**
     * Filter, which units to fetch.
     */
    where: unitsWhereUniqueInput
  }

  /**
   * units findFirst
   */
  export type unitsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the units
     */
    select?: unitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitsInclude<ExtArgs> | null
    /**
     * Filter, which units to fetch.
     */
    where?: unitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of units to fetch.
     */
    orderBy?: unitsOrderByWithRelationInput | unitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for units.
     */
    cursor?: unitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of units.
     */
    distinct?: UnitsScalarFieldEnum | UnitsScalarFieldEnum[]
  }

  /**
   * units findFirstOrThrow
   */
  export type unitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the units
     */
    select?: unitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitsInclude<ExtArgs> | null
    /**
     * Filter, which units to fetch.
     */
    where?: unitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of units to fetch.
     */
    orderBy?: unitsOrderByWithRelationInput | unitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for units.
     */
    cursor?: unitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of units.
     */
    distinct?: UnitsScalarFieldEnum | UnitsScalarFieldEnum[]
  }

  /**
   * units findMany
   */
  export type unitsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the units
     */
    select?: unitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitsInclude<ExtArgs> | null
    /**
     * Filter, which units to fetch.
     */
    where?: unitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of units to fetch.
     */
    orderBy?: unitsOrderByWithRelationInput | unitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing units.
     */
    cursor?: unitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` units.
     */
    skip?: number
    distinct?: UnitsScalarFieldEnum | UnitsScalarFieldEnum[]
  }

  /**
   * units create
   */
  export type unitsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the units
     */
    select?: unitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitsInclude<ExtArgs> | null
    /**
     * The data needed to create a units.
     */
    data: XOR<unitsCreateInput, unitsUncheckedCreateInput>
  }

  /**
   * units createMany
   */
  export type unitsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many units.
     */
    data: unitsCreateManyInput | unitsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * units update
   */
  export type unitsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the units
     */
    select?: unitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitsInclude<ExtArgs> | null
    /**
     * The data needed to update a units.
     */
    data: XOR<unitsUpdateInput, unitsUncheckedUpdateInput>
    /**
     * Choose, which units to update.
     */
    where: unitsWhereUniqueInput
  }

  /**
   * units updateMany
   */
  export type unitsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update units.
     */
    data: XOR<unitsUpdateManyMutationInput, unitsUncheckedUpdateManyInput>
    /**
     * Filter which units to update
     */
    where?: unitsWhereInput
  }

  /**
   * units upsert
   */
  export type unitsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the units
     */
    select?: unitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitsInclude<ExtArgs> | null
    /**
     * The filter to search for the units to update in case it exists.
     */
    where: unitsWhereUniqueInput
    /**
     * In case the units found by the `where` argument doesn't exist, create a new units with this data.
     */
    create: XOR<unitsCreateInput, unitsUncheckedCreateInput>
    /**
     * In case the units was found with the provided `where` argument, update it with this data.
     */
    update: XOR<unitsUpdateInput, unitsUncheckedUpdateInput>
  }

  /**
   * units delete
   */
  export type unitsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the units
     */
    select?: unitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitsInclude<ExtArgs> | null
    /**
     * Filter which units to delete.
     */
    where: unitsWhereUniqueInput
  }

  /**
   * units deleteMany
   */
  export type unitsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which units to delete
     */
    where?: unitsWhereInput
  }

  /**
   * units.items
   */
  export type units$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    cursor?: itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * units without action
   */
  export type unitsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the units
     */
    select?: unitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitsInclude<ExtArgs> | null
  }


  /**
   * Model brands
   */

  export type AggregateBrands = {
    _count: BrandsCountAggregateOutputType | null
    _avg: BrandsAvgAggregateOutputType | null
    _sum: BrandsSumAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  export type BrandsAvgAggregateOutputType = {
    id: number | null
  }

  export type BrandsSumAggregateOutputType = {
    id: number | null
  }

  export type BrandsMinAggregateOutputType = {
    id: number | null
    brands_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandsMaxAggregateOutputType = {
    id: number | null
    brands_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandsCountAggregateOutputType = {
    id: number
    brands_name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandsAvgAggregateInputType = {
    id?: true
  }

  export type BrandsSumAggregateInputType = {
    id?: true
  }

  export type BrandsMinAggregateInputType = {
    id?: true
    brands_name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandsMaxAggregateInputType = {
    id?: true
    brands_name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandsCountAggregateInputType = {
    id?: true
    brands_name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to aggregate.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned brands
    **/
    _count?: true | BrandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandsMaxAggregateInputType
  }

  export type GetBrandsAggregateType<T extends BrandsAggregateArgs> = {
        [P in keyof T & keyof AggregateBrands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrands[P]>
      : GetScalarType<T[P], AggregateBrands[P]>
  }




  export type brandsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandsWhereInput
    orderBy?: brandsOrderByWithAggregationInput | brandsOrderByWithAggregationInput[]
    by: BrandsScalarFieldEnum[] | BrandsScalarFieldEnum
    having?: brandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandsCountAggregateInputType | true
    _avg?: BrandsAvgAggregateInputType
    _sum?: BrandsSumAggregateInputType
    _min?: BrandsMinAggregateInputType
    _max?: BrandsMaxAggregateInputType
  }

  export type BrandsGroupByOutputType = {
    id: number
    brands_name: string
    createdAt: Date
    updatedAt: Date
    _count: BrandsCountAggregateOutputType | null
    _avg: BrandsAvgAggregateOutputType | null
    _sum: BrandsSumAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  type GetBrandsGroupByPayload<T extends brandsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandsGroupByOutputType[P]>
            : GetScalarType<T[P], BrandsGroupByOutputType[P]>
        }
      >
    >


  export type brandsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brands_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | brands$itemsArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brands"]>


  export type brandsSelectScalar = {
    id?: boolean
    brands_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type brandsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | brands$itemsArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $brandsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "brands"
    objects: {
      items: Prisma.$itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brands_name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brands"]>
    composites: {}
  }

  type brandsGetPayload<S extends boolean | null | undefined | brandsDefaultArgs> = $Result.GetResult<Prisma.$brandsPayload, S>

  type brandsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<brandsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BrandsCountAggregateInputType | true
    }

  export interface brandsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['brands'], meta: { name: 'brands' } }
    /**
     * Find zero or one Brands that matches the filter.
     * @param {brandsFindUniqueArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends brandsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, brandsFindUniqueArgs<ExtArgs>>
    ): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Brands that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {brandsFindUniqueOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends brandsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, brandsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindFirstArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends brandsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, brandsFindFirstArgs<ExtArgs>>
    ): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Brands that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindFirstOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends brandsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, brandsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brands.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brands.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandsWithIdOnly = await prisma.brands.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends brandsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, brandsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Brands.
     * @param {brandsCreateArgs} args - Arguments to create a Brands.
     * @example
     * // Create one Brands
     * const Brands = await prisma.brands.create({
     *   data: {
     *     // ... data to create a Brands
     *   }
     * })
     * 
    **/
    create<T extends brandsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, brandsCreateArgs<ExtArgs>>
    ): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Brands.
     * @param {brandsCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brands = await prisma.brands.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends brandsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, brandsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brands.
     * @param {brandsDeleteArgs} args - Arguments to delete one Brands.
     * @example
     * // Delete one Brands
     * const Brands = await prisma.brands.delete({
     *   where: {
     *     // ... filter to delete one Brands
     *   }
     * })
     * 
    **/
    delete<T extends brandsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, brandsDeleteArgs<ExtArgs>>
    ): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Brands.
     * @param {brandsUpdateArgs} args - Arguments to update one Brands.
     * @example
     * // Update one Brands
     * const brands = await prisma.brands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends brandsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, brandsUpdateArgs<ExtArgs>>
    ): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Brands.
     * @param {brandsDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends brandsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, brandsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brands = await prisma.brands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends brandsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, brandsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brands.
     * @param {brandsUpsertArgs} args - Arguments to update or create a Brands.
     * @example
     * // Update or create a Brands
     * const brands = await prisma.brands.upsert({
     *   create: {
     *     // ... data to create a Brands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brands we want to update
     *   }
     * })
    **/
    upsert<T extends brandsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, brandsUpsertArgs<ExtArgs>>
    ): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brands.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends brandsCountArgs>(
      args?: Subset<T, brandsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandsAggregateArgs>(args: Subset<T, BrandsAggregateArgs>): Prisma.PrismaPromise<GetBrandsAggregateType<T>>

    /**
     * Group by Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends brandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: brandsGroupByArgs['orderBy'] }
        : { orderBy?: brandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, brandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the brands model
   */
  readonly fields: brandsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for brands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__brandsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    items<T extends brands$itemsArgs<ExtArgs> = {}>(args?: Subset<T, brands$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the brands model
   */ 
  interface brandsFieldRefs {
    readonly id: FieldRef<"brands", 'Int'>
    readonly brands_name: FieldRef<"brands", 'String'>
    readonly createdAt: FieldRef<"brands", 'DateTime'>
    readonly updatedAt: FieldRef<"brands", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * brands findUnique
   */
  export type brandsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands findUniqueOrThrow
   */
  export type brandsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands findFirst
   */
  export type brandsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands findFirstOrThrow
   */
  export type brandsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands findMany
   */
  export type brandsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands create
   */
  export type brandsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The data needed to create a brands.
     */
    data: XOR<brandsCreateInput, brandsUncheckedCreateInput>
  }

  /**
   * brands createMany
   */
  export type brandsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many brands.
     */
    data: brandsCreateManyInput | brandsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * brands update
   */
  export type brandsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The data needed to update a brands.
     */
    data: XOR<brandsUpdateInput, brandsUncheckedUpdateInput>
    /**
     * Choose, which brands to update.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands updateMany
   */
  export type brandsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update brands.
     */
    data: XOR<brandsUpdateManyMutationInput, brandsUncheckedUpdateManyInput>
    /**
     * Filter which brands to update
     */
    where?: brandsWhereInput
  }

  /**
   * brands upsert
   */
  export type brandsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The filter to search for the brands to update in case it exists.
     */
    where: brandsWhereUniqueInput
    /**
     * In case the brands found by the `where` argument doesn't exist, create a new brands with this data.
     */
    create: XOR<brandsCreateInput, brandsUncheckedCreateInput>
    /**
     * In case the brands was found with the provided `where` argument, update it with this data.
     */
    update: XOR<brandsUpdateInput, brandsUncheckedUpdateInput>
  }

  /**
   * brands delete
   */
  export type brandsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter which brands to delete.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands deleteMany
   */
  export type brandsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to delete
     */
    where?: brandsWhereInput
  }

  /**
   * brands.items
   */
  export type brands$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    cursor?: itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * brands without action
   */
  export type brandsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
  }


  /**
   * Model items
   */

  export type AggregateItems = {
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  export type ItemsAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    brandsId: number | null
    unitsId: number | null
  }

  export type ItemsSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    brandsId: number | null
    unitsId: number | null
  }

  export type ItemsMinAggregateOutputType = {
    id: number | null
    items_name: string | null
    categoryId: number | null
    description: string | null
    brandsId: number | null
    unitsId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemsMaxAggregateOutputType = {
    id: number | null
    items_name: string | null
    categoryId: number | null
    description: string | null
    brandsId: number | null
    unitsId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemsCountAggregateOutputType = {
    id: number
    items_name: number
    categoryId: number
    description: number
    brandsId: number
    unitsId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemsAvgAggregateInputType = {
    id?: true
    categoryId?: true
    brandsId?: true
    unitsId?: true
  }

  export type ItemsSumAggregateInputType = {
    id?: true
    categoryId?: true
    brandsId?: true
    unitsId?: true
  }

  export type ItemsMinAggregateInputType = {
    id?: true
    items_name?: true
    categoryId?: true
    description?: true
    brandsId?: true
    unitsId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemsMaxAggregateInputType = {
    id?: true
    items_name?: true
    categoryId?: true
    description?: true
    brandsId?: true
    unitsId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemsCountAggregateInputType = {
    id?: true
    items_name?: true
    categoryId?: true
    description?: true
    brandsId?: true
    unitsId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items to aggregate.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned items
    **/
    _count?: true | ItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemsMaxAggregateInputType
  }

  export type GetItemsAggregateType<T extends ItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItems[P]>
      : GetScalarType<T[P], AggregateItems[P]>
  }




  export type itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithAggregationInput | itemsOrderByWithAggregationInput[]
    by: ItemsScalarFieldEnum[] | ItemsScalarFieldEnum
    having?: itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemsCountAggregateInputType | true
    _avg?: ItemsAvgAggregateInputType
    _sum?: ItemsSumAggregateInputType
    _min?: ItemsMinAggregateInputType
    _max?: ItemsMaxAggregateInputType
  }

  export type ItemsGroupByOutputType = {
    id: number
    items_name: string
    categoryId: number
    description: string
    brandsId: number
    unitsId: number
    createdAt: Date
    updatedAt: Date
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  type GetItemsGroupByPayload<T extends itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemsGroupByOutputType[P]>
            : GetScalarType<T[P], ItemsGroupByOutputType[P]>
        }
      >
    >


  export type itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    items_name?: boolean
    categoryId?: boolean
    description?: boolean
    brandsId?: boolean
    unitsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseitems?: boolean | items$purchaseitemsArgs<ExtArgs>
    Purchase?: boolean | items$PurchaseArgs<ExtArgs>
    sales?: boolean | items$salesArgs<ExtArgs>
    items_category?: boolean | categoryDefaultArgs<ExtArgs>
    items_brands?: boolean | brandsDefaultArgs<ExtArgs>
    items_units?: boolean | unitsDefaultArgs<ExtArgs>
    _count?: boolean | ItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["items"]>


  export type itemsSelectScalar = {
    id?: boolean
    items_name?: boolean
    categoryId?: boolean
    description?: boolean
    brandsId?: boolean
    unitsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseitems?: boolean | items$purchaseitemsArgs<ExtArgs>
    Purchase?: boolean | items$PurchaseArgs<ExtArgs>
    sales?: boolean | items$salesArgs<ExtArgs>
    items_category?: boolean | categoryDefaultArgs<ExtArgs>
    items_brands?: boolean | brandsDefaultArgs<ExtArgs>
    items_units?: boolean | unitsDefaultArgs<ExtArgs>
    _count?: boolean | ItemsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "items"
    objects: {
      purchaseitems: Prisma.$purchaseitemsPayload<ExtArgs>[]
      Purchase: Prisma.$purchasePayload<ExtArgs>[]
      sales: Prisma.$salesPayload<ExtArgs>[]
      items_category: Prisma.$categoryPayload<ExtArgs>
      items_brands: Prisma.$brandsPayload<ExtArgs>
      items_units: Prisma.$unitsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      items_name: string
      categoryId: number
      description: string
      brandsId: number
      unitsId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["items"]>
    composites: {}
  }

  type itemsGetPayload<S extends boolean | null | undefined | itemsDefaultArgs> = $Result.GetResult<Prisma.$itemsPayload, S>

  type itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<itemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemsCountAggregateInputType | true
    }

  export interface itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['items'], meta: { name: 'items' } }
    /**
     * Find zero or one Items that matches the filter.
     * @param {itemsFindUniqueArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends itemsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, itemsFindUniqueArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Items that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {itemsFindUniqueOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends itemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, itemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindFirstArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends itemsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, itemsFindFirstArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindFirstOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends itemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, itemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.items.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemsWithIdOnly = await prisma.items.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends itemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, itemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Items.
     * @param {itemsCreateArgs} args - Arguments to create a Items.
     * @example
     * // Create one Items
     * const Items = await prisma.items.create({
     *   data: {
     *     // ... data to create a Items
     *   }
     * })
     * 
    **/
    create<T extends itemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, itemsCreateArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Items.
     * @param {itemsCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const items = await prisma.items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends itemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, itemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Items.
     * @param {itemsDeleteArgs} args - Arguments to delete one Items.
     * @example
     * // Delete one Items
     * const Items = await prisma.items.delete({
     *   where: {
     *     // ... filter to delete one Items
     *   }
     * })
     * 
    **/
    delete<T extends itemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, itemsDeleteArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Items.
     * @param {itemsUpdateArgs} args - Arguments to update one Items.
     * @example
     * // Update one Items
     * const items = await prisma.items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends itemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, itemsUpdateArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {itemsDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends itemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, itemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const items = await prisma.items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends itemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, itemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Items.
     * @param {itemsUpsertArgs} args - Arguments to update or create a Items.
     * @example
     * // Update or create a Items
     * const items = await prisma.items.upsert({
     *   create: {
     *     // ... data to create a Items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Items we want to update
     *   }
     * })
    **/
    upsert<T extends itemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, itemsUpsertArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.items.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends itemsCountArgs>(
      args?: Subset<T, itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemsAggregateArgs>(args: Subset<T, ItemsAggregateArgs>): Prisma.PrismaPromise<GetItemsAggregateType<T>>

    /**
     * Group by Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itemsGroupByArgs['orderBy'] }
        : { orderBy?: itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the items model
   */
  readonly fields: itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    purchaseitems<T extends items$purchaseitemsArgs<ExtArgs> = {}>(args?: Subset<T, items$purchaseitemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchaseitemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Purchase<T extends items$PurchaseArgs<ExtArgs> = {}>(args?: Subset<T, items$PurchaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'findMany'> | Null>;

    sales<T extends items$salesArgs<ExtArgs> = {}>(args?: Subset<T, items$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, 'findMany'> | Null>;

    items_category<T extends categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoryDefaultArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    items_brands<T extends brandsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandsDefaultArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    items_units<T extends unitsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, unitsDefaultArgs<ExtArgs>>): Prisma__unitsClient<$Result.GetResult<Prisma.$unitsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the items model
   */ 
  interface itemsFieldRefs {
    readonly id: FieldRef<"items", 'Int'>
    readonly items_name: FieldRef<"items", 'String'>
    readonly categoryId: FieldRef<"items", 'Int'>
    readonly description: FieldRef<"items", 'String'>
    readonly brandsId: FieldRef<"items", 'Int'>
    readonly unitsId: FieldRef<"items", 'Int'>
    readonly createdAt: FieldRef<"items", 'DateTime'>
    readonly updatedAt: FieldRef<"items", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * items findUnique
   */
  export type itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items findUniqueOrThrow
   */
  export type itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items findFirst
   */
  export type itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items findFirstOrThrow
   */
  export type itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items findMany
   */
  export type itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items create
   */
  export type itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a items.
     */
    data: XOR<itemsCreateInput, itemsUncheckedCreateInput>
  }

  /**
   * items createMany
   */
  export type itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many items.
     */
    data: itemsCreateManyInput | itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * items update
   */
  export type itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a items.
     */
    data: XOR<itemsUpdateInput, itemsUncheckedUpdateInput>
    /**
     * Choose, which items to update.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items updateMany
   */
  export type itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update items.
     */
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyInput>
    /**
     * Filter which items to update
     */
    where?: itemsWhereInput
  }

  /**
   * items upsert
   */
  export type itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the items to update in case it exists.
     */
    where: itemsWhereUniqueInput
    /**
     * In case the items found by the `where` argument doesn't exist, create a new items with this data.
     */
    create: XOR<itemsCreateInput, itemsUncheckedCreateInput>
    /**
     * In case the items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemsUpdateInput, itemsUncheckedUpdateInput>
  }

  /**
   * items delete
   */
  export type itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter which items to delete.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items deleteMany
   */
  export type itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items to delete
     */
    where?: itemsWhereInput
  }

  /**
   * items.purchaseitems
   */
  export type items$purchaseitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseitems
     */
    select?: purchaseitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseitemsInclude<ExtArgs> | null
    where?: purchaseitemsWhereInput
    orderBy?: purchaseitemsOrderByWithRelationInput | purchaseitemsOrderByWithRelationInput[]
    cursor?: purchaseitemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseitemsScalarFieldEnum | PurchaseitemsScalarFieldEnum[]
  }

  /**
   * items.Purchase
   */
  export type items$PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseInclude<ExtArgs> | null
    where?: purchaseWhereInput
    orderBy?: purchaseOrderByWithRelationInput | purchaseOrderByWithRelationInput[]
    cursor?: purchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * items.sales
   */
  export type items$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    where?: salesWhereInput
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    cursor?: salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * items without action
   */
  export type itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
  }


  /**
   * Model supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    supplier_name: string | null
    contact_person: string | null
    mobile_number: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    supplier_name: string | null
    contact_person: string | null
    mobile_number: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    supplier_name: number
    contact_person: number
    mobile_number: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    supplier_name?: true
    contact_person?: true
    mobile_number?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    supplier_name?: true
    contact_person?: true
    mobile_number?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    supplier_name?: true
    contact_person?: true
    mobile_number?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supplier to aggregate.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type supplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: supplierWhereInput
    orderBy?: supplierOrderByWithAggregationInput | supplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: supplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends supplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type supplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier_name?: boolean
    contact_person?: boolean
    mobile_number?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseitems?: boolean | supplier$purchaseitemsArgs<ExtArgs>
    Purchase?: boolean | supplier$PurchaseArgs<ExtArgs>
    purchasesuppliertrack?: boolean | supplier$purchasesuppliertrackArgs<ExtArgs>
    transaction?: boolean | supplier$transactionArgs<ExtArgs>
    supplierledger?: boolean | supplier$supplierledgerArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>


  export type supplierSelectScalar = {
    id?: boolean
    supplier_name?: boolean
    contact_person?: boolean
    mobile_number?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type supplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseitems?: boolean | supplier$purchaseitemsArgs<ExtArgs>
    Purchase?: boolean | supplier$PurchaseArgs<ExtArgs>
    purchasesuppliertrack?: boolean | supplier$purchasesuppliertrackArgs<ExtArgs>
    transaction?: boolean | supplier$transactionArgs<ExtArgs>
    supplierledger?: boolean | supplier$supplierledgerArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $supplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "supplier"
    objects: {
      purchaseitems: Prisma.$purchaseitemsPayload<ExtArgs>[]
      Purchase: Prisma.$purchasePayload<ExtArgs>[]
      purchasesuppliertrack: Prisma.$purchasesuppliertrackPayload<ExtArgs>[]
      transaction: Prisma.$transactionPayload<ExtArgs>[]
      supplierledger: Prisma.$supplierledgerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplier_name: string
      contact_person: string
      mobile_number: string
      address: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type supplierGetPayload<S extends boolean | null | undefined | supplierDefaultArgs> = $Result.GetResult<Prisma.$supplierPayload, S>

  type supplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<supplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface supplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['supplier'], meta: { name: 'supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {supplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends supplierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, supplierFindUniqueArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {supplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends supplierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends supplierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierFindFirstArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends supplierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends supplierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Supplier.
     * @param {supplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends supplierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, supplierCreateArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Suppliers.
     * @param {supplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends supplierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {supplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends supplierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, supplierDeleteArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {supplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends supplierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, supplierUpdateArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {supplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends supplierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends supplierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, supplierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {supplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends supplierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, supplierUpsertArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends supplierCountArgs>(
      args?: Subset<T, supplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends supplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: supplierGroupByArgs['orderBy'] }
        : { orderBy?: supplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, supplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the supplier model
   */
  readonly fields: supplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__supplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    purchaseitems<T extends supplier$purchaseitemsArgs<ExtArgs> = {}>(args?: Subset<T, supplier$purchaseitemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchaseitemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Purchase<T extends supplier$PurchaseArgs<ExtArgs> = {}>(args?: Subset<T, supplier$PurchaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'findMany'> | Null>;

    purchasesuppliertrack<T extends supplier$purchasesuppliertrackArgs<ExtArgs> = {}>(args?: Subset<T, supplier$purchasesuppliertrackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchasesuppliertrackPayload<ExtArgs>, T, 'findMany'> | Null>;

    transaction<T extends supplier$transactionArgs<ExtArgs> = {}>(args?: Subset<T, supplier$transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    supplierledger<T extends supplier$supplierledgerArgs<ExtArgs> = {}>(args?: Subset<T, supplier$supplierledgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supplierledgerPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the supplier model
   */ 
  interface supplierFieldRefs {
    readonly id: FieldRef<"supplier", 'Int'>
    readonly supplier_name: FieldRef<"supplier", 'String'>
    readonly contact_person: FieldRef<"supplier", 'String'>
    readonly mobile_number: FieldRef<"supplier", 'String'>
    readonly address: FieldRef<"supplier", 'String'>
    readonly createdAt: FieldRef<"supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * supplier findUnique
   */
  export type supplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where: supplierWhereUniqueInput
  }

  /**
   * supplier findUniqueOrThrow
   */
  export type supplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where: supplierWhereUniqueInput
  }

  /**
   * supplier findFirst
   */
  export type supplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * supplier findFirstOrThrow
   */
  export type supplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * supplier findMany
   */
  export type supplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which suppliers to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * supplier create
   */
  export type supplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * The data needed to create a supplier.
     */
    data: XOR<supplierCreateInput, supplierUncheckedCreateInput>
  }

  /**
   * supplier createMany
   */
  export type supplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many suppliers.
     */
    data: supplierCreateManyInput | supplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * supplier update
   */
  export type supplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * The data needed to update a supplier.
     */
    data: XOR<supplierUpdateInput, supplierUncheckedUpdateInput>
    /**
     * Choose, which supplier to update.
     */
    where: supplierWhereUniqueInput
  }

  /**
   * supplier updateMany
   */
  export type supplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update suppliers.
     */
    data: XOR<supplierUpdateManyMutationInput, supplierUncheckedUpdateManyInput>
    /**
     * Filter which suppliers to update
     */
    where?: supplierWhereInput
  }

  /**
   * supplier upsert
   */
  export type supplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * The filter to search for the supplier to update in case it exists.
     */
    where: supplierWhereUniqueInput
    /**
     * In case the supplier found by the `where` argument doesn't exist, create a new supplier with this data.
     */
    create: XOR<supplierCreateInput, supplierUncheckedCreateInput>
    /**
     * In case the supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<supplierUpdateInput, supplierUncheckedUpdateInput>
  }

  /**
   * supplier delete
   */
  export type supplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter which supplier to delete.
     */
    where: supplierWhereUniqueInput
  }

  /**
   * supplier deleteMany
   */
  export type supplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which suppliers to delete
     */
    where?: supplierWhereInput
  }

  /**
   * supplier.purchaseitems
   */
  export type supplier$purchaseitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseitems
     */
    select?: purchaseitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseitemsInclude<ExtArgs> | null
    where?: purchaseitemsWhereInput
    orderBy?: purchaseitemsOrderByWithRelationInput | purchaseitemsOrderByWithRelationInput[]
    cursor?: purchaseitemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseitemsScalarFieldEnum | PurchaseitemsScalarFieldEnum[]
  }

  /**
   * supplier.Purchase
   */
  export type supplier$PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseInclude<ExtArgs> | null
    where?: purchaseWhereInput
    orderBy?: purchaseOrderByWithRelationInput | purchaseOrderByWithRelationInput[]
    cursor?: purchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * supplier.purchasesuppliertrack
   */
  export type supplier$purchasesuppliertrackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchasesuppliertrack
     */
    select?: purchasesuppliertrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchasesuppliertrackInclude<ExtArgs> | null
    where?: purchasesuppliertrackWhereInput
    orderBy?: purchasesuppliertrackOrderByWithRelationInput | purchasesuppliertrackOrderByWithRelationInput[]
    cursor?: purchasesuppliertrackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesuppliertrackScalarFieldEnum | PurchasesuppliertrackScalarFieldEnum[]
  }

  /**
   * supplier.transaction
   */
  export type supplier$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    cursor?: transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * supplier.supplierledger
   */
  export type supplier$supplierledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplierledger
     */
    select?: supplierledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierledgerInclude<ExtArgs> | null
    where?: supplierledgerWhereInput
    orderBy?: supplierledgerOrderByWithRelationInput | supplierledgerOrderByWithRelationInput[]
    cursor?: supplierledgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierledgerScalarFieldEnum | SupplierledgerScalarFieldEnum[]
  }

  /**
   * supplier without action
   */
  export type supplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
  }


  /**
   * Model purchaseitems
   */

  export type AggregatePurchaseitems = {
    _count: PurchaseitemsCountAggregateOutputType | null
    _avg: PurchaseitemsAvgAggregateOutputType | null
    _sum: PurchaseitemsSumAggregateOutputType | null
    _min: PurchaseitemsMinAggregateOutputType | null
    _max: PurchaseitemsMaxAggregateOutputType | null
  }

  export type PurchaseitemsAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    supplierId: number | null
    purchase_qty: number | null
    price_per_unit: number | null
    price_avg: number | null
    purchase_total: number | null
    subtotal_amount: number | null
    purchase_update_qty: number | null
    tax_Id: number | null
  }

  export type PurchaseitemsSumAggregateOutputType = {
    id: number | null
    itemId: number | null
    supplierId: number | null
    purchase_qty: number | null
    price_per_unit: number | null
    price_avg: number | null
    purchase_total: number | null
    subtotal_amount: number | null
    purchase_update_qty: number | null
    tax_Id: number | null
  }

  export type PurchaseitemsMinAggregateOutputType = {
    id: number | null
    itemId: number | null
    supplierId: number | null
    purchase_qty: number | null
    price_per_unit: number | null
    price_avg: number | null
    purchase_total: number | null
    subtotal_amount: number | null
    purchase_update_qty: number | null
    tax_Id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseitemsMaxAggregateOutputType = {
    id: number | null
    itemId: number | null
    supplierId: number | null
    purchase_qty: number | null
    price_per_unit: number | null
    price_avg: number | null
    purchase_total: number | null
    subtotal_amount: number | null
    purchase_update_qty: number | null
    tax_Id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseitemsCountAggregateOutputType = {
    id: number
    itemId: number
    supplierId: number
    purchase_qty: number
    price_per_unit: number
    price_avg: number
    purchase_total: number
    subtotal_amount: number
    purchase_update_qty: number
    tax_Id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseitemsAvgAggregateInputType = {
    id?: true
    itemId?: true
    supplierId?: true
    purchase_qty?: true
    price_per_unit?: true
    price_avg?: true
    purchase_total?: true
    subtotal_amount?: true
    purchase_update_qty?: true
    tax_Id?: true
  }

  export type PurchaseitemsSumAggregateInputType = {
    id?: true
    itemId?: true
    supplierId?: true
    purchase_qty?: true
    price_per_unit?: true
    price_avg?: true
    purchase_total?: true
    subtotal_amount?: true
    purchase_update_qty?: true
    tax_Id?: true
  }

  export type PurchaseitemsMinAggregateInputType = {
    id?: true
    itemId?: true
    supplierId?: true
    purchase_qty?: true
    price_per_unit?: true
    price_avg?: true
    purchase_total?: true
    subtotal_amount?: true
    purchase_update_qty?: true
    tax_Id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseitemsMaxAggregateInputType = {
    id?: true
    itemId?: true
    supplierId?: true
    purchase_qty?: true
    price_per_unit?: true
    price_avg?: true
    purchase_total?: true
    subtotal_amount?: true
    purchase_update_qty?: true
    tax_Id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseitemsCountAggregateInputType = {
    id?: true
    itemId?: true
    supplierId?: true
    purchase_qty?: true
    price_per_unit?: true
    price_avg?: true
    purchase_total?: true
    subtotal_amount?: true
    purchase_update_qty?: true
    tax_Id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseitemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchaseitems to aggregate.
     */
    where?: purchaseitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchaseitems to fetch.
     */
    orderBy?: purchaseitemsOrderByWithRelationInput | purchaseitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: purchaseitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchaseitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchaseitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned purchaseitems
    **/
    _count?: true | PurchaseitemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseitemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseitemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseitemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseitemsMaxAggregateInputType
  }

  export type GetPurchaseitemsAggregateType<T extends PurchaseitemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseitems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseitems[P]>
      : GetScalarType<T[P], AggregatePurchaseitems[P]>
  }




  export type purchaseitemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: purchaseitemsWhereInput
    orderBy?: purchaseitemsOrderByWithAggregationInput | purchaseitemsOrderByWithAggregationInput[]
    by: PurchaseitemsScalarFieldEnum[] | PurchaseitemsScalarFieldEnum
    having?: purchaseitemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseitemsCountAggregateInputType | true
    _avg?: PurchaseitemsAvgAggregateInputType
    _sum?: PurchaseitemsSumAggregateInputType
    _min?: PurchaseitemsMinAggregateInputType
    _max?: PurchaseitemsMaxAggregateInputType
  }

  export type PurchaseitemsGroupByOutputType = {
    id: number
    itemId: number
    supplierId: number
    purchase_qty: number
    price_per_unit: number
    price_avg: number
    purchase_total: number
    subtotal_amount: number
    purchase_update_qty: number
    tax_Id: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseitemsCountAggregateOutputType | null
    _avg: PurchaseitemsAvgAggregateOutputType | null
    _sum: PurchaseitemsSumAggregateOutputType | null
    _min: PurchaseitemsMinAggregateOutputType | null
    _max: PurchaseitemsMaxAggregateOutputType | null
  }

  type GetPurchaseitemsGroupByPayload<T extends purchaseitemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseitemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseitemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseitemsGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseitemsGroupByOutputType[P]>
        }
      >
    >


  export type purchaseitemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    supplierId?: boolean
    purchase_qty?: boolean
    price_per_unit?: boolean
    price_avg?: boolean
    purchase_total?: boolean
    subtotal_amount?: boolean
    purchase_update_qty?: boolean
    tax_Id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseitems_items?: boolean | itemsDefaultArgs<ExtArgs>
    purchaseitemsId?: boolean | supplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseitems"]>


  export type purchaseitemsSelectScalar = {
    id?: boolean
    itemId?: boolean
    supplierId?: boolean
    purchase_qty?: boolean
    price_per_unit?: boolean
    price_avg?: boolean
    purchase_total?: boolean
    subtotal_amount?: boolean
    purchase_update_qty?: boolean
    tax_Id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type purchaseitemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseitems_items?: boolean | itemsDefaultArgs<ExtArgs>
    purchaseitemsId?: boolean | supplierDefaultArgs<ExtArgs>
  }

  export type $purchaseitemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "purchaseitems"
    objects: {
      purchaseitems_items: Prisma.$itemsPayload<ExtArgs>
      purchaseitemsId: Prisma.$supplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: number
      supplierId: number
      purchase_qty: number
      price_per_unit: number
      price_avg: number
      purchase_total: number
      subtotal_amount: number
      purchase_update_qty: number
      tax_Id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseitems"]>
    composites: {}
  }

  type purchaseitemsGetPayload<S extends boolean | null | undefined | purchaseitemsDefaultArgs> = $Result.GetResult<Prisma.$purchaseitemsPayload, S>

  type purchaseitemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<purchaseitemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseitemsCountAggregateInputType | true
    }

  export interface purchaseitemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['purchaseitems'], meta: { name: 'purchaseitems' } }
    /**
     * Find zero or one Purchaseitems that matches the filter.
     * @param {purchaseitemsFindUniqueArgs} args - Arguments to find a Purchaseitems
     * @example
     * // Get one Purchaseitems
     * const purchaseitems = await prisma.purchaseitems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends purchaseitemsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseitemsFindUniqueArgs<ExtArgs>>
    ): Prisma__purchaseitemsClient<$Result.GetResult<Prisma.$purchaseitemsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Purchaseitems that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {purchaseitemsFindUniqueOrThrowArgs} args - Arguments to find a Purchaseitems
     * @example
     * // Get one Purchaseitems
     * const purchaseitems = await prisma.purchaseitems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends purchaseitemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseitemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__purchaseitemsClient<$Result.GetResult<Prisma.$purchaseitemsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Purchaseitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseitemsFindFirstArgs} args - Arguments to find a Purchaseitems
     * @example
     * // Get one Purchaseitems
     * const purchaseitems = await prisma.purchaseitems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends purchaseitemsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseitemsFindFirstArgs<ExtArgs>>
    ): Prisma__purchaseitemsClient<$Result.GetResult<Prisma.$purchaseitemsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Purchaseitems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseitemsFindFirstOrThrowArgs} args - Arguments to find a Purchaseitems
     * @example
     * // Get one Purchaseitems
     * const purchaseitems = await prisma.purchaseitems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends purchaseitemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseitemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__purchaseitemsClient<$Result.GetResult<Prisma.$purchaseitemsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Purchaseitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseitemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchaseitems
     * const purchaseitems = await prisma.purchaseitems.findMany()
     * 
     * // Get first 10 Purchaseitems
     * const purchaseitems = await prisma.purchaseitems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseitemsWithIdOnly = await prisma.purchaseitems.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends purchaseitemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseitemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchaseitemsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Purchaseitems.
     * @param {purchaseitemsCreateArgs} args - Arguments to create a Purchaseitems.
     * @example
     * // Create one Purchaseitems
     * const Purchaseitems = await prisma.purchaseitems.create({
     *   data: {
     *     // ... data to create a Purchaseitems
     *   }
     * })
     * 
    **/
    create<T extends purchaseitemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseitemsCreateArgs<ExtArgs>>
    ): Prisma__purchaseitemsClient<$Result.GetResult<Prisma.$purchaseitemsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Purchaseitems.
     * @param {purchaseitemsCreateManyArgs} args - Arguments to create many Purchaseitems.
     * @example
     * // Create many Purchaseitems
     * const purchaseitems = await prisma.purchaseitems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends purchaseitemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseitemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Purchaseitems.
     * @param {purchaseitemsDeleteArgs} args - Arguments to delete one Purchaseitems.
     * @example
     * // Delete one Purchaseitems
     * const Purchaseitems = await prisma.purchaseitems.delete({
     *   where: {
     *     // ... filter to delete one Purchaseitems
     *   }
     * })
     * 
    **/
    delete<T extends purchaseitemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseitemsDeleteArgs<ExtArgs>>
    ): Prisma__purchaseitemsClient<$Result.GetResult<Prisma.$purchaseitemsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Purchaseitems.
     * @param {purchaseitemsUpdateArgs} args - Arguments to update one Purchaseitems.
     * @example
     * // Update one Purchaseitems
     * const purchaseitems = await prisma.purchaseitems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends purchaseitemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseitemsUpdateArgs<ExtArgs>>
    ): Prisma__purchaseitemsClient<$Result.GetResult<Prisma.$purchaseitemsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Purchaseitems.
     * @param {purchaseitemsDeleteManyArgs} args - Arguments to filter Purchaseitems to delete.
     * @example
     * // Delete a few Purchaseitems
     * const { count } = await prisma.purchaseitems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends purchaseitemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseitemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchaseitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseitemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchaseitems
     * const purchaseitems = await prisma.purchaseitems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends purchaseitemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseitemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchaseitems.
     * @param {purchaseitemsUpsertArgs} args - Arguments to update or create a Purchaseitems.
     * @example
     * // Update or create a Purchaseitems
     * const purchaseitems = await prisma.purchaseitems.upsert({
     *   create: {
     *     // ... data to create a Purchaseitems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchaseitems we want to update
     *   }
     * })
    **/
    upsert<T extends purchaseitemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseitemsUpsertArgs<ExtArgs>>
    ): Prisma__purchaseitemsClient<$Result.GetResult<Prisma.$purchaseitemsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Purchaseitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseitemsCountArgs} args - Arguments to filter Purchaseitems to count.
     * @example
     * // Count the number of Purchaseitems
     * const count = await prisma.purchaseitems.count({
     *   where: {
     *     // ... the filter for the Purchaseitems we want to count
     *   }
     * })
    **/
    count<T extends purchaseitemsCountArgs>(
      args?: Subset<T, purchaseitemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseitemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchaseitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseitemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseitemsAggregateArgs>(args: Subset<T, PurchaseitemsAggregateArgs>): Prisma.PrismaPromise<GetPurchaseitemsAggregateType<T>>

    /**
     * Group by Purchaseitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseitemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends purchaseitemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: purchaseitemsGroupByArgs['orderBy'] }
        : { orderBy?: purchaseitemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, purchaseitemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseitemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the purchaseitems model
   */
  readonly fields: purchaseitemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for purchaseitems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__purchaseitemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    purchaseitems_items<T extends itemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, itemsDefaultArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    purchaseitemsId<T extends supplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, supplierDefaultArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the purchaseitems model
   */ 
  interface purchaseitemsFieldRefs {
    readonly id: FieldRef<"purchaseitems", 'Int'>
    readonly itemId: FieldRef<"purchaseitems", 'Int'>
    readonly supplierId: FieldRef<"purchaseitems", 'Int'>
    readonly purchase_qty: FieldRef<"purchaseitems", 'Float'>
    readonly price_per_unit: FieldRef<"purchaseitems", 'Float'>
    readonly price_avg: FieldRef<"purchaseitems", 'Float'>
    readonly purchase_total: FieldRef<"purchaseitems", 'Float'>
    readonly subtotal_amount: FieldRef<"purchaseitems", 'Float'>
    readonly purchase_update_qty: FieldRef<"purchaseitems", 'Float'>
    readonly tax_Id: FieldRef<"purchaseitems", 'Int'>
    readonly createdAt: FieldRef<"purchaseitems", 'DateTime'>
    readonly updatedAt: FieldRef<"purchaseitems", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * purchaseitems findUnique
   */
  export type purchaseitemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseitems
     */
    select?: purchaseitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseitemsInclude<ExtArgs> | null
    /**
     * Filter, which purchaseitems to fetch.
     */
    where: purchaseitemsWhereUniqueInput
  }

  /**
   * purchaseitems findUniqueOrThrow
   */
  export type purchaseitemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseitems
     */
    select?: purchaseitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseitemsInclude<ExtArgs> | null
    /**
     * Filter, which purchaseitems to fetch.
     */
    where: purchaseitemsWhereUniqueInput
  }

  /**
   * purchaseitems findFirst
   */
  export type purchaseitemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseitems
     */
    select?: purchaseitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseitemsInclude<ExtArgs> | null
    /**
     * Filter, which purchaseitems to fetch.
     */
    where?: purchaseitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchaseitems to fetch.
     */
    orderBy?: purchaseitemsOrderByWithRelationInput | purchaseitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchaseitems.
     */
    cursor?: purchaseitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchaseitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchaseitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchaseitems.
     */
    distinct?: PurchaseitemsScalarFieldEnum | PurchaseitemsScalarFieldEnum[]
  }

  /**
   * purchaseitems findFirstOrThrow
   */
  export type purchaseitemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseitems
     */
    select?: purchaseitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseitemsInclude<ExtArgs> | null
    /**
     * Filter, which purchaseitems to fetch.
     */
    where?: purchaseitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchaseitems to fetch.
     */
    orderBy?: purchaseitemsOrderByWithRelationInput | purchaseitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchaseitems.
     */
    cursor?: purchaseitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchaseitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchaseitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchaseitems.
     */
    distinct?: PurchaseitemsScalarFieldEnum | PurchaseitemsScalarFieldEnum[]
  }

  /**
   * purchaseitems findMany
   */
  export type purchaseitemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseitems
     */
    select?: purchaseitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseitemsInclude<ExtArgs> | null
    /**
     * Filter, which purchaseitems to fetch.
     */
    where?: purchaseitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchaseitems to fetch.
     */
    orderBy?: purchaseitemsOrderByWithRelationInput | purchaseitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing purchaseitems.
     */
    cursor?: purchaseitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchaseitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchaseitems.
     */
    skip?: number
    distinct?: PurchaseitemsScalarFieldEnum | PurchaseitemsScalarFieldEnum[]
  }

  /**
   * purchaseitems create
   */
  export type purchaseitemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseitems
     */
    select?: purchaseitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseitemsInclude<ExtArgs> | null
    /**
     * The data needed to create a purchaseitems.
     */
    data: XOR<purchaseitemsCreateInput, purchaseitemsUncheckedCreateInput>
  }

  /**
   * purchaseitems createMany
   */
  export type purchaseitemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many purchaseitems.
     */
    data: purchaseitemsCreateManyInput | purchaseitemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * purchaseitems update
   */
  export type purchaseitemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseitems
     */
    select?: purchaseitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseitemsInclude<ExtArgs> | null
    /**
     * The data needed to update a purchaseitems.
     */
    data: XOR<purchaseitemsUpdateInput, purchaseitemsUncheckedUpdateInput>
    /**
     * Choose, which purchaseitems to update.
     */
    where: purchaseitemsWhereUniqueInput
  }

  /**
   * purchaseitems updateMany
   */
  export type purchaseitemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update purchaseitems.
     */
    data: XOR<purchaseitemsUpdateManyMutationInput, purchaseitemsUncheckedUpdateManyInput>
    /**
     * Filter which purchaseitems to update
     */
    where?: purchaseitemsWhereInput
  }

  /**
   * purchaseitems upsert
   */
  export type purchaseitemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseitems
     */
    select?: purchaseitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseitemsInclude<ExtArgs> | null
    /**
     * The filter to search for the purchaseitems to update in case it exists.
     */
    where: purchaseitemsWhereUniqueInput
    /**
     * In case the purchaseitems found by the `where` argument doesn't exist, create a new purchaseitems with this data.
     */
    create: XOR<purchaseitemsCreateInput, purchaseitemsUncheckedCreateInput>
    /**
     * In case the purchaseitems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<purchaseitemsUpdateInput, purchaseitemsUncheckedUpdateInput>
  }

  /**
   * purchaseitems delete
   */
  export type purchaseitemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseitems
     */
    select?: purchaseitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseitemsInclude<ExtArgs> | null
    /**
     * Filter which purchaseitems to delete.
     */
    where: purchaseitemsWhereUniqueInput
  }

  /**
   * purchaseitems deleteMany
   */
  export type purchaseitemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchaseitems to delete
     */
    where?: purchaseitemsWhereInput
  }

  /**
   * purchaseitems without action
   */
  export type purchaseitemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseitems
     */
    select?: purchaseitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseitemsInclude<ExtArgs> | null
  }


  /**
   * Model purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    supplierId: number | null
    purchase_qty: number | null
    price_per_unit: number | null
    purchase_total: number | null
    subtotal_amount: number | null
    tax_Id: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    id: number | null
    itemId: number | null
    supplierId: number | null
    purchase_qty: number | null
    price_per_unit: number | null
    purchase_total: number | null
    subtotal_amount: number | null
    tax_Id: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: number | null
    itemId: number | null
    supplierId: number | null
    purchase_qty: number | null
    price_per_unit: number | null
    purchase_total: number | null
    subtotal_amount: number | null
    tax_Id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: number | null
    itemId: number | null
    supplierId: number | null
    purchase_qty: number | null
    price_per_unit: number | null
    purchase_total: number | null
    subtotal_amount: number | null
    tax_Id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    itemId: number
    supplierId: number
    purchase_qty: number
    price_per_unit: number
    purchase_total: number
    subtotal_amount: number
    tax_Id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    id?: true
    itemId?: true
    supplierId?: true
    purchase_qty?: true
    price_per_unit?: true
    purchase_total?: true
    subtotal_amount?: true
    tax_Id?: true
  }

  export type PurchaseSumAggregateInputType = {
    id?: true
    itemId?: true
    supplierId?: true
    purchase_qty?: true
    price_per_unit?: true
    purchase_total?: true
    subtotal_amount?: true
    tax_Id?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    itemId?: true
    supplierId?: true
    purchase_qty?: true
    price_per_unit?: true
    purchase_total?: true
    subtotal_amount?: true
    tax_Id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    itemId?: true
    supplierId?: true
    purchase_qty?: true
    price_per_unit?: true
    purchase_total?: true
    subtotal_amount?: true
    tax_Id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    itemId?: true
    supplierId?: true
    purchase_qty?: true
    price_per_unit?: true
    purchase_total?: true
    subtotal_amount?: true
    tax_Id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchase to aggregate.
     */
    where?: purchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchases to fetch.
     */
    orderBy?: purchaseOrderByWithRelationInput | purchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: purchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type purchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: purchaseWhereInput
    orderBy?: purchaseOrderByWithAggregationInput | purchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: purchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: number
    itemId: number
    supplierId: number
    purchase_qty: number
    price_per_unit: number
    purchase_total: number
    subtotal_amount: number
    tax_Id: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends purchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type purchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    supplierId?: boolean
    purchase_qty?: boolean
    price_per_unit?: boolean
    purchase_total?: boolean
    subtotal_amount?: boolean
    tax_Id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchase_items?: boolean | itemsDefaultArgs<ExtArgs>
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>


  export type purchaseSelectScalar = {
    id?: boolean
    itemId?: boolean
    supplierId?: boolean
    purchase_qty?: boolean
    price_per_unit?: boolean
    purchase_total?: boolean
    subtotal_amount?: boolean
    tax_Id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type purchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_items?: boolean | itemsDefaultArgs<ExtArgs>
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }

  export type $purchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "purchase"
    objects: {
      purchase_items: Prisma.$itemsPayload<ExtArgs>
      supplier: Prisma.$supplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: number
      supplierId: number
      purchase_qty: number
      price_per_unit: number
      purchase_total: number
      subtotal_amount: number
      tax_Id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type purchaseGetPayload<S extends boolean | null | undefined | purchaseDefaultArgs> = $Result.GetResult<Prisma.$purchasePayload, S>

  type purchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<purchaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface purchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['purchase'], meta: { name: 'purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {purchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends purchaseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseFindUniqueArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {purchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends purchaseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends purchaseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseFindFirstArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends purchaseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends purchaseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Purchase.
     * @param {purchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
    **/
    create<T extends purchaseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseCreateArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Purchases.
     * @param {purchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends purchaseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Purchase.
     * @param {purchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
    **/
    delete<T extends purchaseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseDeleteArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Purchase.
     * @param {purchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends purchaseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseUpdateArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Purchases.
     * @param {purchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends purchaseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends purchaseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {purchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
    **/
    upsert<T extends purchaseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseUpsertArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends purchaseCountArgs>(
      args?: Subset<T, purchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends purchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: purchaseGroupByArgs['orderBy'] }
        : { orderBy?: purchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, purchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the purchase model
   */
  readonly fields: purchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__purchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    purchase_items<T extends itemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, itemsDefaultArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    supplier<T extends supplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, supplierDefaultArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the purchase model
   */ 
  interface purchaseFieldRefs {
    readonly id: FieldRef<"purchase", 'Int'>
    readonly itemId: FieldRef<"purchase", 'Int'>
    readonly supplierId: FieldRef<"purchase", 'Int'>
    readonly purchase_qty: FieldRef<"purchase", 'Float'>
    readonly price_per_unit: FieldRef<"purchase", 'Float'>
    readonly purchase_total: FieldRef<"purchase", 'Float'>
    readonly subtotal_amount: FieldRef<"purchase", 'Float'>
    readonly tax_Id: FieldRef<"purchase", 'Int'>
    readonly createdAt: FieldRef<"purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * purchase findUnique
   */
  export type purchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseInclude<ExtArgs> | null
    /**
     * Filter, which purchase to fetch.
     */
    where: purchaseWhereUniqueInput
  }

  /**
   * purchase findUniqueOrThrow
   */
  export type purchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseInclude<ExtArgs> | null
    /**
     * Filter, which purchase to fetch.
     */
    where: purchaseWhereUniqueInput
  }

  /**
   * purchase findFirst
   */
  export type purchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseInclude<ExtArgs> | null
    /**
     * Filter, which purchase to fetch.
     */
    where?: purchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchases to fetch.
     */
    orderBy?: purchaseOrderByWithRelationInput | purchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchases.
     */
    cursor?: purchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * purchase findFirstOrThrow
   */
  export type purchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseInclude<ExtArgs> | null
    /**
     * Filter, which purchase to fetch.
     */
    where?: purchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchases to fetch.
     */
    orderBy?: purchaseOrderByWithRelationInput | purchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchases.
     */
    cursor?: purchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * purchase findMany
   */
  export type purchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseInclude<ExtArgs> | null
    /**
     * Filter, which purchases to fetch.
     */
    where?: purchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchases to fetch.
     */
    orderBy?: purchaseOrderByWithRelationInput | purchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing purchases.
     */
    cursor?: purchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * purchase create
   */
  export type purchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a purchase.
     */
    data: XOR<purchaseCreateInput, purchaseUncheckedCreateInput>
  }

  /**
   * purchase createMany
   */
  export type purchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many purchases.
     */
    data: purchaseCreateManyInput | purchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * purchase update
   */
  export type purchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a purchase.
     */
    data: XOR<purchaseUpdateInput, purchaseUncheckedUpdateInput>
    /**
     * Choose, which purchase to update.
     */
    where: purchaseWhereUniqueInput
  }

  /**
   * purchase updateMany
   */
  export type purchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update purchases.
     */
    data: XOR<purchaseUpdateManyMutationInput, purchaseUncheckedUpdateManyInput>
    /**
     * Filter which purchases to update
     */
    where?: purchaseWhereInput
  }

  /**
   * purchase upsert
   */
  export type purchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the purchase to update in case it exists.
     */
    where: purchaseWhereUniqueInput
    /**
     * In case the purchase found by the `where` argument doesn't exist, create a new purchase with this data.
     */
    create: XOR<purchaseCreateInput, purchaseUncheckedCreateInput>
    /**
     * In case the purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<purchaseUpdateInput, purchaseUncheckedUpdateInput>
  }

  /**
   * purchase delete
   */
  export type purchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseInclude<ExtArgs> | null
    /**
     * Filter which purchase to delete.
     */
    where: purchaseWhereUniqueInput
  }

  /**
   * purchase deleteMany
   */
  export type purchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchases to delete
     */
    where?: purchaseWhereInput
  }

  /**
   * purchase without action
   */
  export type purchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchaseInclude<ExtArgs> | null
  }


  /**
   * Model sales
   */

  export type AggregateSales = {
    _count: SalesCountAggregateOutputType | null
    _avg: SalesAvgAggregateOutputType | null
    _sum: SalesSumAggregateOutputType | null
    _min: SalesMinAggregateOutputType | null
    _max: SalesMaxAggregateOutputType | null
  }

  export type SalesAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    customerId: number | null
    sale_qty: number | null
    sales_price: number | null
    discount: number | null
    transport_cost: number | null
  }

  export type SalesSumAggregateOutputType = {
    id: number | null
    itemId: number | null
    customerId: number | null
    sale_qty: number | null
    sales_price: number | null
    discount: number | null
    transport_cost: number | null
  }

  export type SalesMinAggregateOutputType = {
    id: number | null
    itemId: number | null
    customerId: number | null
    sale_qty: number | null
    sales_price: number | null
    discount: number | null
    transport_cost: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesMaxAggregateOutputType = {
    id: number | null
    itemId: number | null
    customerId: number | null
    sale_qty: number | null
    sales_price: number | null
    discount: number | null
    transport_cost: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesCountAggregateOutputType = {
    id: number
    itemId: number
    customerId: number
    sale_qty: number
    sales_price: number
    discount: number
    transport_cost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesAvgAggregateInputType = {
    id?: true
    itemId?: true
    customerId?: true
    sale_qty?: true
    sales_price?: true
    discount?: true
    transport_cost?: true
  }

  export type SalesSumAggregateInputType = {
    id?: true
    itemId?: true
    customerId?: true
    sale_qty?: true
    sales_price?: true
    discount?: true
    transport_cost?: true
  }

  export type SalesMinAggregateInputType = {
    id?: true
    itemId?: true
    customerId?: true
    sale_qty?: true
    sales_price?: true
    discount?: true
    transport_cost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesMaxAggregateInputType = {
    id?: true
    itemId?: true
    customerId?: true
    sale_qty?: true
    sales_price?: true
    discount?: true
    transport_cost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesCountAggregateInputType = {
    id?: true
    itemId?: true
    customerId?: true
    sale_qty?: true
    sales_price?: true
    discount?: true
    transport_cost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sales to aggregate.
     */
    where?: salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales to fetch.
     */
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sales
    **/
    _count?: true | SalesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesMaxAggregateInputType
  }

  export type GetSalesAggregateType<T extends SalesAggregateArgs> = {
        [P in keyof T & keyof AggregateSales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSales[P]>
      : GetScalarType<T[P], AggregateSales[P]>
  }




  export type salesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: salesWhereInput
    orderBy?: salesOrderByWithAggregationInput | salesOrderByWithAggregationInput[]
    by: SalesScalarFieldEnum[] | SalesScalarFieldEnum
    having?: salesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesCountAggregateInputType | true
    _avg?: SalesAvgAggregateInputType
    _sum?: SalesSumAggregateInputType
    _min?: SalesMinAggregateInputType
    _max?: SalesMaxAggregateInputType
  }

  export type SalesGroupByOutputType = {
    id: number
    itemId: number
    customerId: number
    sale_qty: number
    sales_price: number
    discount: number
    transport_cost: number
    createdAt: Date
    updatedAt: Date
    _count: SalesCountAggregateOutputType | null
    _avg: SalesAvgAggregateOutputType | null
    _sum: SalesSumAggregateOutputType | null
    _min: SalesMinAggregateOutputType | null
    _max: SalesMaxAggregateOutputType | null
  }

  type GetSalesGroupByPayload<T extends salesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesGroupByOutputType[P]>
            : GetScalarType<T[P], SalesGroupByOutputType[P]>
        }
      >
    >


  export type salesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    customerId?: boolean
    sale_qty?: boolean
    sales_price?: boolean
    discount?: boolean
    transport_cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | itemsDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sales"]>


  export type salesSelectScalar = {
    id?: boolean
    itemId?: boolean
    customerId?: boolean
    sale_qty?: boolean
    sales_price?: boolean
    discount?: boolean
    transport_cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type salesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | itemsDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }

  export type $salesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sales"
    objects: {
      items: Prisma.$itemsPayload<ExtArgs>
      customer: Prisma.$customerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: number
      customerId: number
      sale_qty: number
      sales_price: number
      discount: number
      transport_cost: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sales"]>
    composites: {}
  }

  type salesGetPayload<S extends boolean | null | undefined | salesDefaultArgs> = $Result.GetResult<Prisma.$salesPayload, S>

  type salesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<salesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalesCountAggregateInputType | true
    }

  export interface salesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sales'], meta: { name: 'sales' } }
    /**
     * Find zero or one Sales that matches the filter.
     * @param {salesFindUniqueArgs} args - Arguments to find a Sales
     * @example
     * // Get one Sales
     * const sales = await prisma.sales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends salesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, salesFindUniqueArgs<ExtArgs>>
    ): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sales that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {salesFindUniqueOrThrowArgs} args - Arguments to find a Sales
     * @example
     * // Get one Sales
     * const sales = await prisma.sales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends salesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, salesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesFindFirstArgs} args - Arguments to find a Sales
     * @example
     * // Get one Sales
     * const sales = await prisma.sales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends salesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, salesFindFirstArgs<ExtArgs>>
    ): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesFindFirstOrThrowArgs} args - Arguments to find a Sales
     * @example
     * // Get one Sales
     * const sales = await prisma.sales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends salesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, salesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sales.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesWithIdOnly = await prisma.sales.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends salesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sales.
     * @param {salesCreateArgs} args - Arguments to create a Sales.
     * @example
     * // Create one Sales
     * const Sales = await prisma.sales.create({
     *   data: {
     *     // ... data to create a Sales
     *   }
     * })
     * 
    **/
    create<T extends salesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, salesCreateArgs<ExtArgs>>
    ): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sales.
     * @param {salesCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sales = await prisma.sales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends salesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sales.
     * @param {salesDeleteArgs} args - Arguments to delete one Sales.
     * @example
     * // Delete one Sales
     * const Sales = await prisma.sales.delete({
     *   where: {
     *     // ... filter to delete one Sales
     *   }
     * })
     * 
    **/
    delete<T extends salesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, salesDeleteArgs<ExtArgs>>
    ): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sales.
     * @param {salesUpdateArgs} args - Arguments to update one Sales.
     * @example
     * // Update one Sales
     * const sales = await prisma.sales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends salesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, salesUpdateArgs<ExtArgs>>
    ): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sales.
     * @param {salesDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends salesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sales = await prisma.sales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends salesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, salesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sales.
     * @param {salesUpsertArgs} args - Arguments to update or create a Sales.
     * @example
     * // Update or create a Sales
     * const sales = await prisma.sales.upsert({
     *   create: {
     *     // ... data to create a Sales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sales we want to update
     *   }
     * })
    **/
    upsert<T extends salesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, salesUpsertArgs<ExtArgs>>
    ): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sales.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends salesCountArgs>(
      args?: Subset<T, salesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesAggregateArgs>(args: Subset<T, SalesAggregateArgs>): Prisma.PrismaPromise<GetSalesAggregateType<T>>

    /**
     * Group by Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends salesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: salesGroupByArgs['orderBy'] }
        : { orderBy?: salesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, salesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sales model
   */
  readonly fields: salesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__salesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    items<T extends itemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, itemsDefaultArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the sales model
   */ 
  interface salesFieldRefs {
    readonly id: FieldRef<"sales", 'Int'>
    readonly itemId: FieldRef<"sales", 'Int'>
    readonly customerId: FieldRef<"sales", 'Int'>
    readonly sale_qty: FieldRef<"sales", 'Float'>
    readonly sales_price: FieldRef<"sales", 'Float'>
    readonly discount: FieldRef<"sales", 'Float'>
    readonly transport_cost: FieldRef<"sales", 'Float'>
    readonly createdAt: FieldRef<"sales", 'DateTime'>
    readonly updatedAt: FieldRef<"sales", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sales findUnique
   */
  export type salesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * Filter, which sales to fetch.
     */
    where: salesWhereUniqueInput
  }

  /**
   * sales findUniqueOrThrow
   */
  export type salesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * Filter, which sales to fetch.
     */
    where: salesWhereUniqueInput
  }

  /**
   * sales findFirst
   */
  export type salesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * Filter, which sales to fetch.
     */
    where?: salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales to fetch.
     */
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sales.
     */
    cursor?: salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sales.
     */
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * sales findFirstOrThrow
   */
  export type salesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * Filter, which sales to fetch.
     */
    where?: salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales to fetch.
     */
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sales.
     */
    cursor?: salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sales.
     */
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * sales findMany
   */
  export type salesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * Filter, which sales to fetch.
     */
    where?: salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales to fetch.
     */
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sales.
     */
    cursor?: salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales.
     */
    skip?: number
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * sales create
   */
  export type salesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * The data needed to create a sales.
     */
    data: XOR<salesCreateInput, salesUncheckedCreateInput>
  }

  /**
   * sales createMany
   */
  export type salesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sales.
     */
    data: salesCreateManyInput | salesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sales update
   */
  export type salesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * The data needed to update a sales.
     */
    data: XOR<salesUpdateInput, salesUncheckedUpdateInput>
    /**
     * Choose, which sales to update.
     */
    where: salesWhereUniqueInput
  }

  /**
   * sales updateMany
   */
  export type salesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sales.
     */
    data: XOR<salesUpdateManyMutationInput, salesUncheckedUpdateManyInput>
    /**
     * Filter which sales to update
     */
    where?: salesWhereInput
  }

  /**
   * sales upsert
   */
  export type salesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * The filter to search for the sales to update in case it exists.
     */
    where: salesWhereUniqueInput
    /**
     * In case the sales found by the `where` argument doesn't exist, create a new sales with this data.
     */
    create: XOR<salesCreateInput, salesUncheckedCreateInput>
    /**
     * In case the sales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<salesUpdateInput, salesUncheckedUpdateInput>
  }

  /**
   * sales delete
   */
  export type salesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * Filter which sales to delete.
     */
    where: salesWhereUniqueInput
  }

  /**
   * sales deleteMany
   */
  export type salesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sales to delete
     */
    where?: salesWhereInput
  }

  /**
   * sales without action
   */
  export type salesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
  }


  /**
   * Model customertype
   */

  export type AggregateCustomertype = {
    _count: CustomertypeCountAggregateOutputType | null
    _avg: CustomertypeAvgAggregateOutputType | null
    _sum: CustomertypeSumAggregateOutputType | null
    _min: CustomertypeMinAggregateOutputType | null
    _max: CustomertypeMaxAggregateOutputType | null
  }

  export type CustomertypeAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomertypeSumAggregateOutputType = {
    id: number | null
  }

  export type CustomertypeMinAggregateOutputType = {
    id: number | null
    type_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomertypeMaxAggregateOutputType = {
    id: number | null
    type_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomertypeCountAggregateOutputType = {
    id: number
    type_name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomertypeAvgAggregateInputType = {
    id?: true
  }

  export type CustomertypeSumAggregateInputType = {
    id?: true
  }

  export type CustomertypeMinAggregateInputType = {
    id?: true
    type_name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomertypeMaxAggregateInputType = {
    id?: true
    type_name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomertypeCountAggregateInputType = {
    id?: true
    type_name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomertypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customertype to aggregate.
     */
    where?: customertypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customertypes to fetch.
     */
    orderBy?: customertypeOrderByWithRelationInput | customertypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customertypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customertypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customertypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customertypes
    **/
    _count?: true | CustomertypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomertypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomertypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomertypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomertypeMaxAggregateInputType
  }

  export type GetCustomertypeAggregateType<T extends CustomertypeAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomertype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomertype[P]>
      : GetScalarType<T[P], AggregateCustomertype[P]>
  }




  export type customertypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customertypeWhereInput
    orderBy?: customertypeOrderByWithAggregationInput | customertypeOrderByWithAggregationInput[]
    by: CustomertypeScalarFieldEnum[] | CustomertypeScalarFieldEnum
    having?: customertypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomertypeCountAggregateInputType | true
    _avg?: CustomertypeAvgAggregateInputType
    _sum?: CustomertypeSumAggregateInputType
    _min?: CustomertypeMinAggregateInputType
    _max?: CustomertypeMaxAggregateInputType
  }

  export type CustomertypeGroupByOutputType = {
    id: number
    type_name: string
    createdAt: Date
    updatedAt: Date
    _count: CustomertypeCountAggregateOutputType | null
    _avg: CustomertypeAvgAggregateOutputType | null
    _sum: CustomertypeSumAggregateOutputType | null
    _min: CustomertypeMinAggregateOutputType | null
    _max: CustomertypeMaxAggregateOutputType | null
  }

  type GetCustomertypeGroupByPayload<T extends customertypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomertypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomertypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomertypeGroupByOutputType[P]>
            : GetScalarType<T[P], CustomertypeGroupByOutputType[P]>
        }
      >
    >


  export type customertypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | customertype$customerArgs<ExtArgs>
    customerpayment?: boolean | customertype$customerpaymentArgs<ExtArgs>
    _count?: boolean | CustomertypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customertype"]>


  export type customertypeSelectScalar = {
    id?: boolean
    type_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type customertypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customertype$customerArgs<ExtArgs>
    customerpayment?: boolean | customertype$customerpaymentArgs<ExtArgs>
    _count?: boolean | CustomertypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $customertypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customertype"
    objects: {
      customer: Prisma.$customerPayload<ExtArgs>[]
      customerpayment: Prisma.$customerpaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type_name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customertype"]>
    composites: {}
  }

  type customertypeGetPayload<S extends boolean | null | undefined | customertypeDefaultArgs> = $Result.GetResult<Prisma.$customertypePayload, S>

  type customertypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<customertypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomertypeCountAggregateInputType | true
    }

  export interface customertypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customertype'], meta: { name: 'customertype' } }
    /**
     * Find zero or one Customertype that matches the filter.
     * @param {customertypeFindUniqueArgs} args - Arguments to find a Customertype
     * @example
     * // Get one Customertype
     * const customertype = await prisma.customertype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends customertypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, customertypeFindUniqueArgs<ExtArgs>>
    ): Prisma__customertypeClient<$Result.GetResult<Prisma.$customertypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Customertype that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {customertypeFindUniqueOrThrowArgs} args - Arguments to find a Customertype
     * @example
     * // Get one Customertype
     * const customertype = await prisma.customertype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends customertypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customertypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__customertypeClient<$Result.GetResult<Prisma.$customertypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Customertype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customertypeFindFirstArgs} args - Arguments to find a Customertype
     * @example
     * // Get one Customertype
     * const customertype = await prisma.customertype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends customertypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, customertypeFindFirstArgs<ExtArgs>>
    ): Prisma__customertypeClient<$Result.GetResult<Prisma.$customertypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Customertype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customertypeFindFirstOrThrowArgs} args - Arguments to find a Customertype
     * @example
     * // Get one Customertype
     * const customertype = await prisma.customertype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends customertypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customertypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__customertypeClient<$Result.GetResult<Prisma.$customertypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Customertypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customertypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customertypes
     * const customertypes = await prisma.customertype.findMany()
     * 
     * // Get first 10 Customertypes
     * const customertypes = await prisma.customertype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customertypeWithIdOnly = await prisma.customertype.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends customertypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customertypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customertypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Customertype.
     * @param {customertypeCreateArgs} args - Arguments to create a Customertype.
     * @example
     * // Create one Customertype
     * const Customertype = await prisma.customertype.create({
     *   data: {
     *     // ... data to create a Customertype
     *   }
     * })
     * 
    **/
    create<T extends customertypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, customertypeCreateArgs<ExtArgs>>
    ): Prisma__customertypeClient<$Result.GetResult<Prisma.$customertypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Customertypes.
     * @param {customertypeCreateManyArgs} args - Arguments to create many Customertypes.
     * @example
     * // Create many Customertypes
     * const customertype = await prisma.customertype.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends customertypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customertypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customertype.
     * @param {customertypeDeleteArgs} args - Arguments to delete one Customertype.
     * @example
     * // Delete one Customertype
     * const Customertype = await prisma.customertype.delete({
     *   where: {
     *     // ... filter to delete one Customertype
     *   }
     * })
     * 
    **/
    delete<T extends customertypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, customertypeDeleteArgs<ExtArgs>>
    ): Prisma__customertypeClient<$Result.GetResult<Prisma.$customertypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Customertype.
     * @param {customertypeUpdateArgs} args - Arguments to update one Customertype.
     * @example
     * // Update one Customertype
     * const customertype = await prisma.customertype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends customertypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, customertypeUpdateArgs<ExtArgs>>
    ): Prisma__customertypeClient<$Result.GetResult<Prisma.$customertypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Customertypes.
     * @param {customertypeDeleteManyArgs} args - Arguments to filter Customertypes to delete.
     * @example
     * // Delete a few Customertypes
     * const { count } = await prisma.customertype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends customertypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customertypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customertypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customertypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customertypes
     * const customertype = await prisma.customertype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends customertypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, customertypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customertype.
     * @param {customertypeUpsertArgs} args - Arguments to update or create a Customertype.
     * @example
     * // Update or create a Customertype
     * const customertype = await prisma.customertype.upsert({
     *   create: {
     *     // ... data to create a Customertype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customertype we want to update
     *   }
     * })
    **/
    upsert<T extends customertypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, customertypeUpsertArgs<ExtArgs>>
    ): Prisma__customertypeClient<$Result.GetResult<Prisma.$customertypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Customertypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customertypeCountArgs} args - Arguments to filter Customertypes to count.
     * @example
     * // Count the number of Customertypes
     * const count = await prisma.customertype.count({
     *   where: {
     *     // ... the filter for the Customertypes we want to count
     *   }
     * })
    **/
    count<T extends customertypeCountArgs>(
      args?: Subset<T, customertypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomertypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customertype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomertypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomertypeAggregateArgs>(args: Subset<T, CustomertypeAggregateArgs>): Prisma.PrismaPromise<GetCustomertypeAggregateType<T>>

    /**
     * Group by Customertype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customertypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customertypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customertypeGroupByArgs['orderBy'] }
        : { orderBy?: customertypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customertypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomertypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customertype model
   */
  readonly fields: customertypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customertype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customertypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    customer<T extends customertype$customerArgs<ExtArgs> = {}>(args?: Subset<T, customertype$customerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findMany'> | Null>;

    customerpayment<T extends customertype$customerpaymentArgs<ExtArgs> = {}>(args?: Subset<T, customertype$customerpaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerpaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the customertype model
   */ 
  interface customertypeFieldRefs {
    readonly id: FieldRef<"customertype", 'Int'>
    readonly type_name: FieldRef<"customertype", 'String'>
    readonly createdAt: FieldRef<"customertype", 'DateTime'>
    readonly updatedAt: FieldRef<"customertype", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customertype findUnique
   */
  export type customertypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customertype
     */
    select?: customertypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customertypeInclude<ExtArgs> | null
    /**
     * Filter, which customertype to fetch.
     */
    where: customertypeWhereUniqueInput
  }

  /**
   * customertype findUniqueOrThrow
   */
  export type customertypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customertype
     */
    select?: customertypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customertypeInclude<ExtArgs> | null
    /**
     * Filter, which customertype to fetch.
     */
    where: customertypeWhereUniqueInput
  }

  /**
   * customertype findFirst
   */
  export type customertypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customertype
     */
    select?: customertypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customertypeInclude<ExtArgs> | null
    /**
     * Filter, which customertype to fetch.
     */
    where?: customertypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customertypes to fetch.
     */
    orderBy?: customertypeOrderByWithRelationInput | customertypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customertypes.
     */
    cursor?: customertypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customertypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customertypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customertypes.
     */
    distinct?: CustomertypeScalarFieldEnum | CustomertypeScalarFieldEnum[]
  }

  /**
   * customertype findFirstOrThrow
   */
  export type customertypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customertype
     */
    select?: customertypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customertypeInclude<ExtArgs> | null
    /**
     * Filter, which customertype to fetch.
     */
    where?: customertypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customertypes to fetch.
     */
    orderBy?: customertypeOrderByWithRelationInput | customertypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customertypes.
     */
    cursor?: customertypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customertypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customertypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customertypes.
     */
    distinct?: CustomertypeScalarFieldEnum | CustomertypeScalarFieldEnum[]
  }

  /**
   * customertype findMany
   */
  export type customertypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customertype
     */
    select?: customertypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customertypeInclude<ExtArgs> | null
    /**
     * Filter, which customertypes to fetch.
     */
    where?: customertypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customertypes to fetch.
     */
    orderBy?: customertypeOrderByWithRelationInput | customertypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customertypes.
     */
    cursor?: customertypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customertypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customertypes.
     */
    skip?: number
    distinct?: CustomertypeScalarFieldEnum | CustomertypeScalarFieldEnum[]
  }

  /**
   * customertype create
   */
  export type customertypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customertype
     */
    select?: customertypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customertypeInclude<ExtArgs> | null
    /**
     * The data needed to create a customertype.
     */
    data: XOR<customertypeCreateInput, customertypeUncheckedCreateInput>
  }

  /**
   * customertype createMany
   */
  export type customertypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customertypes.
     */
    data: customertypeCreateManyInput | customertypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customertype update
   */
  export type customertypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customertype
     */
    select?: customertypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customertypeInclude<ExtArgs> | null
    /**
     * The data needed to update a customertype.
     */
    data: XOR<customertypeUpdateInput, customertypeUncheckedUpdateInput>
    /**
     * Choose, which customertype to update.
     */
    where: customertypeWhereUniqueInput
  }

  /**
   * customertype updateMany
   */
  export type customertypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customertypes.
     */
    data: XOR<customertypeUpdateManyMutationInput, customertypeUncheckedUpdateManyInput>
    /**
     * Filter which customertypes to update
     */
    where?: customertypeWhereInput
  }

  /**
   * customertype upsert
   */
  export type customertypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customertype
     */
    select?: customertypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customertypeInclude<ExtArgs> | null
    /**
     * The filter to search for the customertype to update in case it exists.
     */
    where: customertypeWhereUniqueInput
    /**
     * In case the customertype found by the `where` argument doesn't exist, create a new customertype with this data.
     */
    create: XOR<customertypeCreateInput, customertypeUncheckedCreateInput>
    /**
     * In case the customertype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customertypeUpdateInput, customertypeUncheckedUpdateInput>
  }

  /**
   * customertype delete
   */
  export type customertypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customertype
     */
    select?: customertypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customertypeInclude<ExtArgs> | null
    /**
     * Filter which customertype to delete.
     */
    where: customertypeWhereUniqueInput
  }

  /**
   * customertype deleteMany
   */
  export type customertypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customertypes to delete
     */
    where?: customertypeWhereInput
  }

  /**
   * customertype.customer
   */
  export type customertype$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    cursor?: customerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customertype.customerpayment
   */
  export type customertype$customerpaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerpayment
     */
    select?: customerpaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerpaymentInclude<ExtArgs> | null
    where?: customerpaymentWhereInput
    orderBy?: customerpaymentOrderByWithRelationInput | customerpaymentOrderByWithRelationInput[]
    cursor?: customerpaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerpaymentScalarFieldEnum | CustomerpaymentScalarFieldEnum[]
  }

  /**
   * customertype without action
   */
  export type customertypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customertype
     */
    select?: customertypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customertypeInclude<ExtArgs> | null
  }


  /**
   * Model customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
    customertypeId: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
    customertypeId: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    customer_name: string | null
    customertypeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    customer_name: string | null
    customertypeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    customer_name: number
    customertypeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
    customertypeId?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
    customertypeId?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    customer_name?: true
    customertypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    customer_name?: true
    customertypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    customer_name?: true
    customertypeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer to aggregate.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type customerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
    orderBy?: customerOrderByWithAggregationInput | customerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: customerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    customer_name: string
    customertypeId: number
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends customerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type customerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_name?: boolean
    customertypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean | customertypeDefaultArgs<ExtArgs>
    customerdetails?: boolean | customer$customerdetailsArgs<ExtArgs>
    sales?: boolean | customer$salesArgs<ExtArgs>
    salescustomertracker?: boolean | customer$salescustomertrackerArgs<ExtArgs>
    customerledger?: boolean | customer$customerledgerArgs<ExtArgs>
    customerpayment?: boolean | customer$customerpaymentArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>


  export type customerSelectScalar = {
    id?: boolean
    customer_name?: boolean
    customertypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type customerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerId?: boolean | customertypeDefaultArgs<ExtArgs>
    customerdetails?: boolean | customer$customerdetailsArgs<ExtArgs>
    sales?: boolean | customer$salesArgs<ExtArgs>
    salescustomertracker?: boolean | customer$salescustomertrackerArgs<ExtArgs>
    customerledger?: boolean | customer$customerledgerArgs<ExtArgs>
    customerpayment?: boolean | customer$customerpaymentArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $customerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer"
    objects: {
      customerId: Prisma.$customertypePayload<ExtArgs>
      customerdetails: Prisma.$customerdetailsPayload<ExtArgs>[]
      sales: Prisma.$salesPayload<ExtArgs>[]
      salescustomertracker: Prisma.$salescustomertrackerPayload<ExtArgs>[]
      customerledger: Prisma.$customerledgerPayload<ExtArgs>[]
      customerpayment: Prisma.$customerpaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customer_name: string
      customertypeId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type customerGetPayload<S extends boolean | null | undefined | customerDefaultArgs> = $Result.GetResult<Prisma.$customerPayload, S>

  type customerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<customerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface customerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer'], meta: { name: 'customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {customerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends customerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, customerFindUniqueArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {customerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends customerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends customerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, customerFindFirstArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends customerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends customerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Customer.
     * @param {customerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends customerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, customerCreateArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {customerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends customerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {customerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends customerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, customerDeleteArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {customerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends customerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, customerUpdateArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {customerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends customerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends customerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, customerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {customerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends customerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, customerUpsertArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customerCountArgs>(
      args?: Subset<T, customerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerGroupByArgs['orderBy'] }
        : { orderBy?: customerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer model
   */
  readonly fields: customerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    customerId<T extends customertypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customertypeDefaultArgs<ExtArgs>>): Prisma__customertypeClient<$Result.GetResult<Prisma.$customertypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    customerdetails<T extends customer$customerdetailsArgs<ExtArgs> = {}>(args?: Subset<T, customer$customerdetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerdetailsPayload<ExtArgs>, T, 'findMany'> | Null>;

    sales<T extends customer$salesArgs<ExtArgs> = {}>(args?: Subset<T, customer$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, 'findMany'> | Null>;

    salescustomertracker<T extends customer$salescustomertrackerArgs<ExtArgs> = {}>(args?: Subset<T, customer$salescustomertrackerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salescustomertrackerPayload<ExtArgs>, T, 'findMany'> | Null>;

    customerledger<T extends customer$customerledgerArgs<ExtArgs> = {}>(args?: Subset<T, customer$customerledgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerledgerPayload<ExtArgs>, T, 'findMany'> | Null>;

    customerpayment<T extends customer$customerpaymentArgs<ExtArgs> = {}>(args?: Subset<T, customer$customerpaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerpaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the customer model
   */ 
  interface customerFieldRefs {
    readonly id: FieldRef<"customer", 'Int'>
    readonly customer_name: FieldRef<"customer", 'String'>
    readonly customertypeId: FieldRef<"customer", 'Int'>
    readonly createdAt: FieldRef<"customer", 'DateTime'>
    readonly updatedAt: FieldRef<"customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customer findUnique
   */
  export type customerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findUniqueOrThrow
   */
  export type customerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findFirst
   */
  export type customerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findFirstOrThrow
   */
  export type customerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findMany
   */
  export type customerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer create
   */
  export type customerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to create a customer.
     */
    data: XOR<customerCreateInput, customerUncheckedCreateInput>
  }

  /**
   * customer createMany
   */
  export type customerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer update
   */
  export type customerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to update a customer.
     */
    data: XOR<customerUpdateInput, customerUncheckedUpdateInput>
    /**
     * Choose, which customer to update.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer updateMany
   */
  export type customerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
  }

  /**
   * customer upsert
   */
  export type customerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The filter to search for the customer to update in case it exists.
     */
    where: customerWhereUniqueInput
    /**
     * In case the customer found by the `where` argument doesn't exist, create a new customer with this data.
     */
    create: XOR<customerCreateInput, customerUncheckedCreateInput>
    /**
     * In case the customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerUpdateInput, customerUncheckedUpdateInput>
  }

  /**
   * customer delete
   */
  export type customerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter which customer to delete.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer deleteMany
   */
  export type customerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customerWhereInput
  }

  /**
   * customer.customerdetails
   */
  export type customer$customerdetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerdetails
     */
    select?: customerdetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerdetailsInclude<ExtArgs> | null
    where?: customerdetailsWhereInput
    orderBy?: customerdetailsOrderByWithRelationInput | customerdetailsOrderByWithRelationInput[]
    cursor?: customerdetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerdetailsScalarFieldEnum | CustomerdetailsScalarFieldEnum[]
  }

  /**
   * customer.sales
   */
  export type customer$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    where?: salesWhereInput
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    cursor?: salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * customer.salescustomertracker
   */
  export type customer$salescustomertrackerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salescustomertracker
     */
    select?: salescustomertrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salescustomertrackerInclude<ExtArgs> | null
    where?: salescustomertrackerWhereInput
    orderBy?: salescustomertrackerOrderByWithRelationInput | salescustomertrackerOrderByWithRelationInput[]
    cursor?: salescustomertrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalescustomertrackerScalarFieldEnum | SalescustomertrackerScalarFieldEnum[]
  }

  /**
   * customer.customerledger
   */
  export type customer$customerledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerledger
     */
    select?: customerledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerledgerInclude<ExtArgs> | null
    where?: customerledgerWhereInput
    orderBy?: customerledgerOrderByWithRelationInput | customerledgerOrderByWithRelationInput[]
    cursor?: customerledgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerledgerScalarFieldEnum | CustomerledgerScalarFieldEnum[]
  }

  /**
   * customer.customerpayment
   */
  export type customer$customerpaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerpayment
     */
    select?: customerpaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerpaymentInclude<ExtArgs> | null
    where?: customerpaymentWhereInput
    orderBy?: customerpaymentOrderByWithRelationInput | customerpaymentOrderByWithRelationInput[]
    cursor?: customerpaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerpaymentScalarFieldEnum | CustomerpaymentScalarFieldEnum[]
  }

  /**
   * customer without action
   */
  export type customerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
  }


  /**
   * Model salescustomertracker
   */

  export type AggregateSalescustomertracker = {
    _count: SalescustomertrackerCountAggregateOutputType | null
    _avg: SalescustomertrackerAvgAggregateOutputType | null
    _sum: SalescustomertrackerSumAggregateOutputType | null
    _min: SalescustomertrackerMinAggregateOutputType | null
    _max: SalescustomertrackerMaxAggregateOutputType | null
  }

  export type SalescustomertrackerAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    curr_balance: number | null
  }

  export type SalescustomertrackerSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    curr_balance: number | null
  }

  export type SalescustomertrackerMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    curr_balance: number | null
    payment_type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalescustomertrackerMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    curr_balance: number | null
    payment_type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalescustomertrackerCountAggregateOutputType = {
    id: number
    customerId: number
    curr_balance: number
    payment_type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalescustomertrackerAvgAggregateInputType = {
    id?: true
    customerId?: true
    curr_balance?: true
  }

  export type SalescustomertrackerSumAggregateInputType = {
    id?: true
    customerId?: true
    curr_balance?: true
  }

  export type SalescustomertrackerMinAggregateInputType = {
    id?: true
    customerId?: true
    curr_balance?: true
    payment_type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalescustomertrackerMaxAggregateInputType = {
    id?: true
    customerId?: true
    curr_balance?: true
    payment_type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalescustomertrackerCountAggregateInputType = {
    id?: true
    customerId?: true
    curr_balance?: true
    payment_type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalescustomertrackerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which salescustomertracker to aggregate.
     */
    where?: salescustomertrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salescustomertrackers to fetch.
     */
    orderBy?: salescustomertrackerOrderByWithRelationInput | salescustomertrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: salescustomertrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salescustomertrackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salescustomertrackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned salescustomertrackers
    **/
    _count?: true | SalescustomertrackerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalescustomertrackerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalescustomertrackerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalescustomertrackerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalescustomertrackerMaxAggregateInputType
  }

  export type GetSalescustomertrackerAggregateType<T extends SalescustomertrackerAggregateArgs> = {
        [P in keyof T & keyof AggregateSalescustomertracker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalescustomertracker[P]>
      : GetScalarType<T[P], AggregateSalescustomertracker[P]>
  }




  export type salescustomertrackerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: salescustomertrackerWhereInput
    orderBy?: salescustomertrackerOrderByWithAggregationInput | salescustomertrackerOrderByWithAggregationInput[]
    by: SalescustomertrackerScalarFieldEnum[] | SalescustomertrackerScalarFieldEnum
    having?: salescustomertrackerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalescustomertrackerCountAggregateInputType | true
    _avg?: SalescustomertrackerAvgAggregateInputType
    _sum?: SalescustomertrackerSumAggregateInputType
    _min?: SalescustomertrackerMinAggregateInputType
    _max?: SalescustomertrackerMaxAggregateInputType
  }

  export type SalescustomertrackerGroupByOutputType = {
    id: number
    customerId: number
    curr_balance: number
    payment_type: string
    createdAt: Date
    updatedAt: Date
    _count: SalescustomertrackerCountAggregateOutputType | null
    _avg: SalescustomertrackerAvgAggregateOutputType | null
    _sum: SalescustomertrackerSumAggregateOutputType | null
    _min: SalescustomertrackerMinAggregateOutputType | null
    _max: SalescustomertrackerMaxAggregateOutputType | null
  }

  type GetSalescustomertrackerGroupByPayload<T extends salescustomertrackerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalescustomertrackerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalescustomertrackerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalescustomertrackerGroupByOutputType[P]>
            : GetScalarType<T[P], SalescustomertrackerGroupByOutputType[P]>
        }
      >
    >


  export type salescustomertrackerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    curr_balance?: boolean
    payment_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salescustomertracker"]>


  export type salescustomertrackerSelectScalar = {
    id?: boolean
    customerId?: boolean
    curr_balance?: boolean
    payment_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type salescustomertrackerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }

  export type $salescustomertrackerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "salescustomertracker"
    objects: {
      customer: Prisma.$customerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number
      curr_balance: number
      payment_type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salescustomertracker"]>
    composites: {}
  }

  type salescustomertrackerGetPayload<S extends boolean | null | undefined | salescustomertrackerDefaultArgs> = $Result.GetResult<Prisma.$salescustomertrackerPayload, S>

  type salescustomertrackerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<salescustomertrackerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalescustomertrackerCountAggregateInputType | true
    }

  export interface salescustomertrackerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['salescustomertracker'], meta: { name: 'salescustomertracker' } }
    /**
     * Find zero or one Salescustomertracker that matches the filter.
     * @param {salescustomertrackerFindUniqueArgs} args - Arguments to find a Salescustomertracker
     * @example
     * // Get one Salescustomertracker
     * const salescustomertracker = await prisma.salescustomertracker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends salescustomertrackerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, salescustomertrackerFindUniqueArgs<ExtArgs>>
    ): Prisma__salescustomertrackerClient<$Result.GetResult<Prisma.$salescustomertrackerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Salescustomertracker that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {salescustomertrackerFindUniqueOrThrowArgs} args - Arguments to find a Salescustomertracker
     * @example
     * // Get one Salescustomertracker
     * const salescustomertracker = await prisma.salescustomertracker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends salescustomertrackerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, salescustomertrackerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__salescustomertrackerClient<$Result.GetResult<Prisma.$salescustomertrackerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Salescustomertracker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salescustomertrackerFindFirstArgs} args - Arguments to find a Salescustomertracker
     * @example
     * // Get one Salescustomertracker
     * const salescustomertracker = await prisma.salescustomertracker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends salescustomertrackerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, salescustomertrackerFindFirstArgs<ExtArgs>>
    ): Prisma__salescustomertrackerClient<$Result.GetResult<Prisma.$salescustomertrackerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Salescustomertracker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salescustomertrackerFindFirstOrThrowArgs} args - Arguments to find a Salescustomertracker
     * @example
     * // Get one Salescustomertracker
     * const salescustomertracker = await prisma.salescustomertracker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends salescustomertrackerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, salescustomertrackerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__salescustomertrackerClient<$Result.GetResult<Prisma.$salescustomertrackerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Salescustomertrackers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salescustomertrackerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salescustomertrackers
     * const salescustomertrackers = await prisma.salescustomertracker.findMany()
     * 
     * // Get first 10 Salescustomertrackers
     * const salescustomertrackers = await prisma.salescustomertracker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salescustomertrackerWithIdOnly = await prisma.salescustomertracker.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends salescustomertrackerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salescustomertrackerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salescustomertrackerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Salescustomertracker.
     * @param {salescustomertrackerCreateArgs} args - Arguments to create a Salescustomertracker.
     * @example
     * // Create one Salescustomertracker
     * const Salescustomertracker = await prisma.salescustomertracker.create({
     *   data: {
     *     // ... data to create a Salescustomertracker
     *   }
     * })
     * 
    **/
    create<T extends salescustomertrackerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, salescustomertrackerCreateArgs<ExtArgs>>
    ): Prisma__salescustomertrackerClient<$Result.GetResult<Prisma.$salescustomertrackerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Salescustomertrackers.
     * @param {salescustomertrackerCreateManyArgs} args - Arguments to create many Salescustomertrackers.
     * @example
     * // Create many Salescustomertrackers
     * const salescustomertracker = await prisma.salescustomertracker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends salescustomertrackerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salescustomertrackerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Salescustomertracker.
     * @param {salescustomertrackerDeleteArgs} args - Arguments to delete one Salescustomertracker.
     * @example
     * // Delete one Salescustomertracker
     * const Salescustomertracker = await prisma.salescustomertracker.delete({
     *   where: {
     *     // ... filter to delete one Salescustomertracker
     *   }
     * })
     * 
    **/
    delete<T extends salescustomertrackerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, salescustomertrackerDeleteArgs<ExtArgs>>
    ): Prisma__salescustomertrackerClient<$Result.GetResult<Prisma.$salescustomertrackerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Salescustomertracker.
     * @param {salescustomertrackerUpdateArgs} args - Arguments to update one Salescustomertracker.
     * @example
     * // Update one Salescustomertracker
     * const salescustomertracker = await prisma.salescustomertracker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends salescustomertrackerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, salescustomertrackerUpdateArgs<ExtArgs>>
    ): Prisma__salescustomertrackerClient<$Result.GetResult<Prisma.$salescustomertrackerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Salescustomertrackers.
     * @param {salescustomertrackerDeleteManyArgs} args - Arguments to filter Salescustomertrackers to delete.
     * @example
     * // Delete a few Salescustomertrackers
     * const { count } = await prisma.salescustomertracker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends salescustomertrackerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salescustomertrackerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salescustomertrackers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salescustomertrackerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salescustomertrackers
     * const salescustomertracker = await prisma.salescustomertracker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends salescustomertrackerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, salescustomertrackerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Salescustomertracker.
     * @param {salescustomertrackerUpsertArgs} args - Arguments to update or create a Salescustomertracker.
     * @example
     * // Update or create a Salescustomertracker
     * const salescustomertracker = await prisma.salescustomertracker.upsert({
     *   create: {
     *     // ... data to create a Salescustomertracker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salescustomertracker we want to update
     *   }
     * })
    **/
    upsert<T extends salescustomertrackerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, salescustomertrackerUpsertArgs<ExtArgs>>
    ): Prisma__salescustomertrackerClient<$Result.GetResult<Prisma.$salescustomertrackerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Salescustomertrackers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salescustomertrackerCountArgs} args - Arguments to filter Salescustomertrackers to count.
     * @example
     * // Count the number of Salescustomertrackers
     * const count = await prisma.salescustomertracker.count({
     *   where: {
     *     // ... the filter for the Salescustomertrackers we want to count
     *   }
     * })
    **/
    count<T extends salescustomertrackerCountArgs>(
      args?: Subset<T, salescustomertrackerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalescustomertrackerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salescustomertracker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalescustomertrackerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalescustomertrackerAggregateArgs>(args: Subset<T, SalescustomertrackerAggregateArgs>): Prisma.PrismaPromise<GetSalescustomertrackerAggregateType<T>>

    /**
     * Group by Salescustomertracker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salescustomertrackerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends salescustomertrackerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: salescustomertrackerGroupByArgs['orderBy'] }
        : { orderBy?: salescustomertrackerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, salescustomertrackerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalescustomertrackerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the salescustomertracker model
   */
  readonly fields: salescustomertrackerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for salescustomertracker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__salescustomertrackerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the salescustomertracker model
   */ 
  interface salescustomertrackerFieldRefs {
    readonly id: FieldRef<"salescustomertracker", 'Int'>
    readonly customerId: FieldRef<"salescustomertracker", 'Int'>
    readonly curr_balance: FieldRef<"salescustomertracker", 'Float'>
    readonly payment_type: FieldRef<"salescustomertracker", 'String'>
    readonly createdAt: FieldRef<"salescustomertracker", 'DateTime'>
    readonly updatedAt: FieldRef<"salescustomertracker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * salescustomertracker findUnique
   */
  export type salescustomertrackerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salescustomertracker
     */
    select?: salescustomertrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salescustomertrackerInclude<ExtArgs> | null
    /**
     * Filter, which salescustomertracker to fetch.
     */
    where: salescustomertrackerWhereUniqueInput
  }

  /**
   * salescustomertracker findUniqueOrThrow
   */
  export type salescustomertrackerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salescustomertracker
     */
    select?: salescustomertrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salescustomertrackerInclude<ExtArgs> | null
    /**
     * Filter, which salescustomertracker to fetch.
     */
    where: salescustomertrackerWhereUniqueInput
  }

  /**
   * salescustomertracker findFirst
   */
  export type salescustomertrackerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salescustomertracker
     */
    select?: salescustomertrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salescustomertrackerInclude<ExtArgs> | null
    /**
     * Filter, which salescustomertracker to fetch.
     */
    where?: salescustomertrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salescustomertrackers to fetch.
     */
    orderBy?: salescustomertrackerOrderByWithRelationInput | salescustomertrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for salescustomertrackers.
     */
    cursor?: salescustomertrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salescustomertrackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salescustomertrackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of salescustomertrackers.
     */
    distinct?: SalescustomertrackerScalarFieldEnum | SalescustomertrackerScalarFieldEnum[]
  }

  /**
   * salescustomertracker findFirstOrThrow
   */
  export type salescustomertrackerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salescustomertracker
     */
    select?: salescustomertrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salescustomertrackerInclude<ExtArgs> | null
    /**
     * Filter, which salescustomertracker to fetch.
     */
    where?: salescustomertrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salescustomertrackers to fetch.
     */
    orderBy?: salescustomertrackerOrderByWithRelationInput | salescustomertrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for salescustomertrackers.
     */
    cursor?: salescustomertrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salescustomertrackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salescustomertrackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of salescustomertrackers.
     */
    distinct?: SalescustomertrackerScalarFieldEnum | SalescustomertrackerScalarFieldEnum[]
  }

  /**
   * salescustomertracker findMany
   */
  export type salescustomertrackerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salescustomertracker
     */
    select?: salescustomertrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salescustomertrackerInclude<ExtArgs> | null
    /**
     * Filter, which salescustomertrackers to fetch.
     */
    where?: salescustomertrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salescustomertrackers to fetch.
     */
    orderBy?: salescustomertrackerOrderByWithRelationInput | salescustomertrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing salescustomertrackers.
     */
    cursor?: salescustomertrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salescustomertrackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salescustomertrackers.
     */
    skip?: number
    distinct?: SalescustomertrackerScalarFieldEnum | SalescustomertrackerScalarFieldEnum[]
  }

  /**
   * salescustomertracker create
   */
  export type salescustomertrackerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salescustomertracker
     */
    select?: salescustomertrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salescustomertrackerInclude<ExtArgs> | null
    /**
     * The data needed to create a salescustomertracker.
     */
    data: XOR<salescustomertrackerCreateInput, salescustomertrackerUncheckedCreateInput>
  }

  /**
   * salescustomertracker createMany
   */
  export type salescustomertrackerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many salescustomertrackers.
     */
    data: salescustomertrackerCreateManyInput | salescustomertrackerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * salescustomertracker update
   */
  export type salescustomertrackerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salescustomertracker
     */
    select?: salescustomertrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salescustomertrackerInclude<ExtArgs> | null
    /**
     * The data needed to update a salescustomertracker.
     */
    data: XOR<salescustomertrackerUpdateInput, salescustomertrackerUncheckedUpdateInput>
    /**
     * Choose, which salescustomertracker to update.
     */
    where: salescustomertrackerWhereUniqueInput
  }

  /**
   * salescustomertracker updateMany
   */
  export type salescustomertrackerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update salescustomertrackers.
     */
    data: XOR<salescustomertrackerUpdateManyMutationInput, salescustomertrackerUncheckedUpdateManyInput>
    /**
     * Filter which salescustomertrackers to update
     */
    where?: salescustomertrackerWhereInput
  }

  /**
   * salescustomertracker upsert
   */
  export type salescustomertrackerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salescustomertracker
     */
    select?: salescustomertrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salescustomertrackerInclude<ExtArgs> | null
    /**
     * The filter to search for the salescustomertracker to update in case it exists.
     */
    where: salescustomertrackerWhereUniqueInput
    /**
     * In case the salescustomertracker found by the `where` argument doesn't exist, create a new salescustomertracker with this data.
     */
    create: XOR<salescustomertrackerCreateInput, salescustomertrackerUncheckedCreateInput>
    /**
     * In case the salescustomertracker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<salescustomertrackerUpdateInput, salescustomertrackerUncheckedUpdateInput>
  }

  /**
   * salescustomertracker delete
   */
  export type salescustomertrackerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salescustomertracker
     */
    select?: salescustomertrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salescustomertrackerInclude<ExtArgs> | null
    /**
     * Filter which salescustomertracker to delete.
     */
    where: salescustomertrackerWhereUniqueInput
  }

  /**
   * salescustomertracker deleteMany
   */
  export type salescustomertrackerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which salescustomertrackers to delete
     */
    where?: salescustomertrackerWhereInput
  }

  /**
   * salescustomertracker without action
   */
  export type salescustomertrackerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salescustomertracker
     */
    select?: salescustomertrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salescustomertrackerInclude<ExtArgs> | null
  }


  /**
   * Model customerpayment
   */

  export type AggregateCustomerpayment = {
    _count: CustomerpaymentCountAggregateOutputType | null
    _avg: CustomerpaymentAvgAggregateOutputType | null
    _sum: CustomerpaymentSumAggregateOutputType | null
    _min: CustomerpaymentMinAggregateOutputType | null
    _max: CustomerpaymentMaxAggregateOutputType | null
  }

  export type CustomerpaymentAvgAggregateOutputType = {
    id: number | null
    customertypeId: number | null
    customerId: number | null
    balance: number | null
    paid: number | null
    remission: number | null
    curr_balance: number | null
  }

  export type CustomerpaymentSumAggregateOutputType = {
    id: number | null
    customertypeId: number | null
    customerId: number | null
    balance: number | null
    paid: number | null
    remission: number | null
    curr_balance: number | null
  }

  export type CustomerpaymentMinAggregateOutputType = {
    id: number | null
    customertypeId: number | null
    customerId: number | null
    balance: number | null
    transaction_type: string | null
    collection_method: string | null
    paid: number | null
    remission: number | null
    curr_balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerpaymentMaxAggregateOutputType = {
    id: number | null
    customertypeId: number | null
    customerId: number | null
    balance: number | null
    transaction_type: string | null
    collection_method: string | null
    paid: number | null
    remission: number | null
    curr_balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerpaymentCountAggregateOutputType = {
    id: number
    customertypeId: number
    customerId: number
    balance: number
    transaction_type: number
    collection_method: number
    paid: number
    remission: number
    curr_balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerpaymentAvgAggregateInputType = {
    id?: true
    customertypeId?: true
    customerId?: true
    balance?: true
    paid?: true
    remission?: true
    curr_balance?: true
  }

  export type CustomerpaymentSumAggregateInputType = {
    id?: true
    customertypeId?: true
    customerId?: true
    balance?: true
    paid?: true
    remission?: true
    curr_balance?: true
  }

  export type CustomerpaymentMinAggregateInputType = {
    id?: true
    customertypeId?: true
    customerId?: true
    balance?: true
    transaction_type?: true
    collection_method?: true
    paid?: true
    remission?: true
    curr_balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerpaymentMaxAggregateInputType = {
    id?: true
    customertypeId?: true
    customerId?: true
    balance?: true
    transaction_type?: true
    collection_method?: true
    paid?: true
    remission?: true
    curr_balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerpaymentCountAggregateInputType = {
    id?: true
    customertypeId?: true
    customerId?: true
    balance?: true
    transaction_type?: true
    collection_method?: true
    paid?: true
    remission?: true
    curr_balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerpaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customerpayment to aggregate.
     */
    where?: customerpaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerpayments to fetch.
     */
    orderBy?: customerpaymentOrderByWithRelationInput | customerpaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerpaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerpayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerpayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customerpayments
    **/
    _count?: true | CustomerpaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerpaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerpaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerpaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerpaymentMaxAggregateInputType
  }

  export type GetCustomerpaymentAggregateType<T extends CustomerpaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerpayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerpayment[P]>
      : GetScalarType<T[P], AggregateCustomerpayment[P]>
  }




  export type customerpaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerpaymentWhereInput
    orderBy?: customerpaymentOrderByWithAggregationInput | customerpaymentOrderByWithAggregationInput[]
    by: CustomerpaymentScalarFieldEnum[] | CustomerpaymentScalarFieldEnum
    having?: customerpaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerpaymentCountAggregateInputType | true
    _avg?: CustomerpaymentAvgAggregateInputType
    _sum?: CustomerpaymentSumAggregateInputType
    _min?: CustomerpaymentMinAggregateInputType
    _max?: CustomerpaymentMaxAggregateInputType
  }

  export type CustomerpaymentGroupByOutputType = {
    id: number
    customertypeId: number
    customerId: number
    balance: number
    transaction_type: string
    collection_method: string
    paid: number
    remission: number
    curr_balance: number
    createdAt: Date
    updatedAt: Date
    _count: CustomerpaymentCountAggregateOutputType | null
    _avg: CustomerpaymentAvgAggregateOutputType | null
    _sum: CustomerpaymentSumAggregateOutputType | null
    _min: CustomerpaymentMinAggregateOutputType | null
    _max: CustomerpaymentMaxAggregateOutputType | null
  }

  type GetCustomerpaymentGroupByPayload<T extends customerpaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerpaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerpaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerpaymentGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerpaymentGroupByOutputType[P]>
        }
      >
    >


  export type customerpaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customertypeId?: boolean
    customerId?: boolean
    balance?: boolean
    transaction_type?: boolean
    collection_method?: boolean
    paid?: boolean
    remission?: boolean
    curr_balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customertype?: boolean | customertypeDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerpayment"]>


  export type customerpaymentSelectScalar = {
    id?: boolean
    customertypeId?: boolean
    customerId?: boolean
    balance?: boolean
    transaction_type?: boolean
    collection_method?: boolean
    paid?: boolean
    remission?: boolean
    curr_balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type customerpaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customertype?: boolean | customertypeDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }

  export type $customerpaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customerpayment"
    objects: {
      customertype: Prisma.$customertypePayload<ExtArgs>
      customer: Prisma.$customerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customertypeId: number
      customerId: number
      balance: number
      transaction_type: string
      collection_method: string
      paid: number
      remission: number
      curr_balance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerpayment"]>
    composites: {}
  }

  type customerpaymentGetPayload<S extends boolean | null | undefined | customerpaymentDefaultArgs> = $Result.GetResult<Prisma.$customerpaymentPayload, S>

  type customerpaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<customerpaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerpaymentCountAggregateInputType | true
    }

  export interface customerpaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customerpayment'], meta: { name: 'customerpayment' } }
    /**
     * Find zero or one Customerpayment that matches the filter.
     * @param {customerpaymentFindUniqueArgs} args - Arguments to find a Customerpayment
     * @example
     * // Get one Customerpayment
     * const customerpayment = await prisma.customerpayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends customerpaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, customerpaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__customerpaymentClient<$Result.GetResult<Prisma.$customerpaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Customerpayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {customerpaymentFindUniqueOrThrowArgs} args - Arguments to find a Customerpayment
     * @example
     * // Get one Customerpayment
     * const customerpayment = await prisma.customerpayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends customerpaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customerpaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__customerpaymentClient<$Result.GetResult<Prisma.$customerpaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Customerpayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerpaymentFindFirstArgs} args - Arguments to find a Customerpayment
     * @example
     * // Get one Customerpayment
     * const customerpayment = await prisma.customerpayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends customerpaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, customerpaymentFindFirstArgs<ExtArgs>>
    ): Prisma__customerpaymentClient<$Result.GetResult<Prisma.$customerpaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Customerpayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerpaymentFindFirstOrThrowArgs} args - Arguments to find a Customerpayment
     * @example
     * // Get one Customerpayment
     * const customerpayment = await prisma.customerpayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends customerpaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customerpaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__customerpaymentClient<$Result.GetResult<Prisma.$customerpaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Customerpayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerpaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customerpayments
     * const customerpayments = await prisma.customerpayment.findMany()
     * 
     * // Get first 10 Customerpayments
     * const customerpayments = await prisma.customerpayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerpaymentWithIdOnly = await prisma.customerpayment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends customerpaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerpaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerpaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Customerpayment.
     * @param {customerpaymentCreateArgs} args - Arguments to create a Customerpayment.
     * @example
     * // Create one Customerpayment
     * const Customerpayment = await prisma.customerpayment.create({
     *   data: {
     *     // ... data to create a Customerpayment
     *   }
     * })
     * 
    **/
    create<T extends customerpaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, customerpaymentCreateArgs<ExtArgs>>
    ): Prisma__customerpaymentClient<$Result.GetResult<Prisma.$customerpaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Customerpayments.
     * @param {customerpaymentCreateManyArgs} args - Arguments to create many Customerpayments.
     * @example
     * // Create many Customerpayments
     * const customerpayment = await prisma.customerpayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends customerpaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerpaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customerpayment.
     * @param {customerpaymentDeleteArgs} args - Arguments to delete one Customerpayment.
     * @example
     * // Delete one Customerpayment
     * const Customerpayment = await prisma.customerpayment.delete({
     *   where: {
     *     // ... filter to delete one Customerpayment
     *   }
     * })
     * 
    **/
    delete<T extends customerpaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, customerpaymentDeleteArgs<ExtArgs>>
    ): Prisma__customerpaymentClient<$Result.GetResult<Prisma.$customerpaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Customerpayment.
     * @param {customerpaymentUpdateArgs} args - Arguments to update one Customerpayment.
     * @example
     * // Update one Customerpayment
     * const customerpayment = await prisma.customerpayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends customerpaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, customerpaymentUpdateArgs<ExtArgs>>
    ): Prisma__customerpaymentClient<$Result.GetResult<Prisma.$customerpaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Customerpayments.
     * @param {customerpaymentDeleteManyArgs} args - Arguments to filter Customerpayments to delete.
     * @example
     * // Delete a few Customerpayments
     * const { count } = await prisma.customerpayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends customerpaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerpaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customerpayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerpaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customerpayments
     * const customerpayment = await prisma.customerpayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends customerpaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, customerpaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customerpayment.
     * @param {customerpaymentUpsertArgs} args - Arguments to update or create a Customerpayment.
     * @example
     * // Update or create a Customerpayment
     * const customerpayment = await prisma.customerpayment.upsert({
     *   create: {
     *     // ... data to create a Customerpayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customerpayment we want to update
     *   }
     * })
    **/
    upsert<T extends customerpaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, customerpaymentUpsertArgs<ExtArgs>>
    ): Prisma__customerpaymentClient<$Result.GetResult<Prisma.$customerpaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Customerpayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerpaymentCountArgs} args - Arguments to filter Customerpayments to count.
     * @example
     * // Count the number of Customerpayments
     * const count = await prisma.customerpayment.count({
     *   where: {
     *     // ... the filter for the Customerpayments we want to count
     *   }
     * })
    **/
    count<T extends customerpaymentCountArgs>(
      args?: Subset<T, customerpaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerpaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customerpayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerpaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerpaymentAggregateArgs>(args: Subset<T, CustomerpaymentAggregateArgs>): Prisma.PrismaPromise<GetCustomerpaymentAggregateType<T>>

    /**
     * Group by Customerpayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerpaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerpaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerpaymentGroupByArgs['orderBy'] }
        : { orderBy?: customerpaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerpaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerpaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customerpayment model
   */
  readonly fields: customerpaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customerpayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerpaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    customertype<T extends customertypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customertypeDefaultArgs<ExtArgs>>): Prisma__customertypeClient<$Result.GetResult<Prisma.$customertypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the customerpayment model
   */ 
  interface customerpaymentFieldRefs {
    readonly id: FieldRef<"customerpayment", 'Int'>
    readonly customertypeId: FieldRef<"customerpayment", 'Int'>
    readonly customerId: FieldRef<"customerpayment", 'Int'>
    readonly balance: FieldRef<"customerpayment", 'Float'>
    readonly transaction_type: FieldRef<"customerpayment", 'String'>
    readonly collection_method: FieldRef<"customerpayment", 'String'>
    readonly paid: FieldRef<"customerpayment", 'Float'>
    readonly remission: FieldRef<"customerpayment", 'Float'>
    readonly curr_balance: FieldRef<"customerpayment", 'Float'>
    readonly createdAt: FieldRef<"customerpayment", 'DateTime'>
    readonly updatedAt: FieldRef<"customerpayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customerpayment findUnique
   */
  export type customerpaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerpayment
     */
    select?: customerpaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerpaymentInclude<ExtArgs> | null
    /**
     * Filter, which customerpayment to fetch.
     */
    where: customerpaymentWhereUniqueInput
  }

  /**
   * customerpayment findUniqueOrThrow
   */
  export type customerpaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerpayment
     */
    select?: customerpaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerpaymentInclude<ExtArgs> | null
    /**
     * Filter, which customerpayment to fetch.
     */
    where: customerpaymentWhereUniqueInput
  }

  /**
   * customerpayment findFirst
   */
  export type customerpaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerpayment
     */
    select?: customerpaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerpaymentInclude<ExtArgs> | null
    /**
     * Filter, which customerpayment to fetch.
     */
    where?: customerpaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerpayments to fetch.
     */
    orderBy?: customerpaymentOrderByWithRelationInput | customerpaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customerpayments.
     */
    cursor?: customerpaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerpayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerpayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customerpayments.
     */
    distinct?: CustomerpaymentScalarFieldEnum | CustomerpaymentScalarFieldEnum[]
  }

  /**
   * customerpayment findFirstOrThrow
   */
  export type customerpaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerpayment
     */
    select?: customerpaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerpaymentInclude<ExtArgs> | null
    /**
     * Filter, which customerpayment to fetch.
     */
    where?: customerpaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerpayments to fetch.
     */
    orderBy?: customerpaymentOrderByWithRelationInput | customerpaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customerpayments.
     */
    cursor?: customerpaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerpayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerpayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customerpayments.
     */
    distinct?: CustomerpaymentScalarFieldEnum | CustomerpaymentScalarFieldEnum[]
  }

  /**
   * customerpayment findMany
   */
  export type customerpaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerpayment
     */
    select?: customerpaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerpaymentInclude<ExtArgs> | null
    /**
     * Filter, which customerpayments to fetch.
     */
    where?: customerpaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerpayments to fetch.
     */
    orderBy?: customerpaymentOrderByWithRelationInput | customerpaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customerpayments.
     */
    cursor?: customerpaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerpayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerpayments.
     */
    skip?: number
    distinct?: CustomerpaymentScalarFieldEnum | CustomerpaymentScalarFieldEnum[]
  }

  /**
   * customerpayment create
   */
  export type customerpaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerpayment
     */
    select?: customerpaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerpaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a customerpayment.
     */
    data: XOR<customerpaymentCreateInput, customerpaymentUncheckedCreateInput>
  }

  /**
   * customerpayment createMany
   */
  export type customerpaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customerpayments.
     */
    data: customerpaymentCreateManyInput | customerpaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customerpayment update
   */
  export type customerpaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerpayment
     */
    select?: customerpaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerpaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a customerpayment.
     */
    data: XOR<customerpaymentUpdateInput, customerpaymentUncheckedUpdateInput>
    /**
     * Choose, which customerpayment to update.
     */
    where: customerpaymentWhereUniqueInput
  }

  /**
   * customerpayment updateMany
   */
  export type customerpaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customerpayments.
     */
    data: XOR<customerpaymentUpdateManyMutationInput, customerpaymentUncheckedUpdateManyInput>
    /**
     * Filter which customerpayments to update
     */
    where?: customerpaymentWhereInput
  }

  /**
   * customerpayment upsert
   */
  export type customerpaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerpayment
     */
    select?: customerpaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerpaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the customerpayment to update in case it exists.
     */
    where: customerpaymentWhereUniqueInput
    /**
     * In case the customerpayment found by the `where` argument doesn't exist, create a new customerpayment with this data.
     */
    create: XOR<customerpaymentCreateInput, customerpaymentUncheckedCreateInput>
    /**
     * In case the customerpayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerpaymentUpdateInput, customerpaymentUncheckedUpdateInput>
  }

  /**
   * customerpayment delete
   */
  export type customerpaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerpayment
     */
    select?: customerpaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerpaymentInclude<ExtArgs> | null
    /**
     * Filter which customerpayment to delete.
     */
    where: customerpaymentWhereUniqueInput
  }

  /**
   * customerpayment deleteMany
   */
  export type customerpaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customerpayments to delete
     */
    where?: customerpaymentWhereInput
  }

  /**
   * customerpayment without action
   */
  export type customerpaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerpayment
     */
    select?: customerpaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerpaymentInclude<ExtArgs> | null
  }


  /**
   * Model customerledger
   */

  export type AggregateCustomerledger = {
    _count: CustomerledgerCountAggregateOutputType | null
    _avg: CustomerledgerAvgAggregateOutputType | null
    _sum: CustomerledgerSumAggregateOutputType | null
    _min: CustomerledgerMinAggregateOutputType | null
    _max: CustomerledgerMaxAggregateOutputType | null
  }

  export type CustomerledgerAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    credit: number | null
    debit: number | null
    balance: number | null
  }

  export type CustomerledgerSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    credit: number | null
    debit: number | null
    balance: number | null
  }

  export type CustomerledgerMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    payment_type: string | null
    credit: number | null
    debit: number | null
    balance: number | null
    voucher_no: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerledgerMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    payment_type: string | null
    credit: number | null
    debit: number | null
    balance: number | null
    voucher_no: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerledgerCountAggregateOutputType = {
    id: number
    customerId: number
    payment_type: number
    credit: number
    debit: number
    balance: number
    voucher_no: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerledgerAvgAggregateInputType = {
    id?: true
    customerId?: true
    credit?: true
    debit?: true
    balance?: true
  }

  export type CustomerledgerSumAggregateInputType = {
    id?: true
    customerId?: true
    credit?: true
    debit?: true
    balance?: true
  }

  export type CustomerledgerMinAggregateInputType = {
    id?: true
    customerId?: true
    payment_type?: true
    credit?: true
    debit?: true
    balance?: true
    voucher_no?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerledgerMaxAggregateInputType = {
    id?: true
    customerId?: true
    payment_type?: true
    credit?: true
    debit?: true
    balance?: true
    voucher_no?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerledgerCountAggregateInputType = {
    id?: true
    customerId?: true
    payment_type?: true
    credit?: true
    debit?: true
    balance?: true
    voucher_no?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerledgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customerledger to aggregate.
     */
    where?: customerledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerledgers to fetch.
     */
    orderBy?: customerledgerOrderByWithRelationInput | customerledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customerledgers
    **/
    _count?: true | CustomerledgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerledgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerledgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerledgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerledgerMaxAggregateInputType
  }

  export type GetCustomerledgerAggregateType<T extends CustomerledgerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerledger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerledger[P]>
      : GetScalarType<T[P], AggregateCustomerledger[P]>
  }




  export type customerledgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerledgerWhereInput
    orderBy?: customerledgerOrderByWithAggregationInput | customerledgerOrderByWithAggregationInput[]
    by: CustomerledgerScalarFieldEnum[] | CustomerledgerScalarFieldEnum
    having?: customerledgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerledgerCountAggregateInputType | true
    _avg?: CustomerledgerAvgAggregateInputType
    _sum?: CustomerledgerSumAggregateInputType
    _min?: CustomerledgerMinAggregateInputType
    _max?: CustomerledgerMaxAggregateInputType
  }

  export type CustomerledgerGroupByOutputType = {
    id: number
    customerId: number
    payment_type: string
    credit: number
    debit: number
    balance: number
    voucher_no: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerledgerCountAggregateOutputType | null
    _avg: CustomerledgerAvgAggregateOutputType | null
    _sum: CustomerledgerSumAggregateOutputType | null
    _min: CustomerledgerMinAggregateOutputType | null
    _max: CustomerledgerMaxAggregateOutputType | null
  }

  type GetCustomerledgerGroupByPayload<T extends customerledgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerledgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerledgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerledgerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerledgerGroupByOutputType[P]>
        }
      >
    >


  export type customerledgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    payment_type?: boolean
    credit?: boolean
    debit?: boolean
    balance?: boolean
    voucher_no?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerledger"]>


  export type customerledgerSelectScalar = {
    id?: boolean
    customerId?: boolean
    payment_type?: boolean
    credit?: boolean
    debit?: boolean
    balance?: boolean
    voucher_no?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type customerledgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }

  export type $customerledgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customerledger"
    objects: {
      customer: Prisma.$customerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number
      payment_type: string
      credit: number
      debit: number
      balance: number
      voucher_no: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerledger"]>
    composites: {}
  }

  type customerledgerGetPayload<S extends boolean | null | undefined | customerledgerDefaultArgs> = $Result.GetResult<Prisma.$customerledgerPayload, S>

  type customerledgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<customerledgerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerledgerCountAggregateInputType | true
    }

  export interface customerledgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customerledger'], meta: { name: 'customerledger' } }
    /**
     * Find zero or one Customerledger that matches the filter.
     * @param {customerledgerFindUniqueArgs} args - Arguments to find a Customerledger
     * @example
     * // Get one Customerledger
     * const customerledger = await prisma.customerledger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends customerledgerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, customerledgerFindUniqueArgs<ExtArgs>>
    ): Prisma__customerledgerClient<$Result.GetResult<Prisma.$customerledgerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Customerledger that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {customerledgerFindUniqueOrThrowArgs} args - Arguments to find a Customerledger
     * @example
     * // Get one Customerledger
     * const customerledger = await prisma.customerledger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends customerledgerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customerledgerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__customerledgerClient<$Result.GetResult<Prisma.$customerledgerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Customerledger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerledgerFindFirstArgs} args - Arguments to find a Customerledger
     * @example
     * // Get one Customerledger
     * const customerledger = await prisma.customerledger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends customerledgerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, customerledgerFindFirstArgs<ExtArgs>>
    ): Prisma__customerledgerClient<$Result.GetResult<Prisma.$customerledgerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Customerledger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerledgerFindFirstOrThrowArgs} args - Arguments to find a Customerledger
     * @example
     * // Get one Customerledger
     * const customerledger = await prisma.customerledger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends customerledgerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customerledgerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__customerledgerClient<$Result.GetResult<Prisma.$customerledgerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Customerledgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerledgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customerledgers
     * const customerledgers = await prisma.customerledger.findMany()
     * 
     * // Get first 10 Customerledgers
     * const customerledgers = await prisma.customerledger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerledgerWithIdOnly = await prisma.customerledger.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends customerledgerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerledgerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerledgerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Customerledger.
     * @param {customerledgerCreateArgs} args - Arguments to create a Customerledger.
     * @example
     * // Create one Customerledger
     * const Customerledger = await prisma.customerledger.create({
     *   data: {
     *     // ... data to create a Customerledger
     *   }
     * })
     * 
    **/
    create<T extends customerledgerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, customerledgerCreateArgs<ExtArgs>>
    ): Prisma__customerledgerClient<$Result.GetResult<Prisma.$customerledgerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Customerledgers.
     * @param {customerledgerCreateManyArgs} args - Arguments to create many Customerledgers.
     * @example
     * // Create many Customerledgers
     * const customerledger = await prisma.customerledger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends customerledgerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerledgerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customerledger.
     * @param {customerledgerDeleteArgs} args - Arguments to delete one Customerledger.
     * @example
     * // Delete one Customerledger
     * const Customerledger = await prisma.customerledger.delete({
     *   where: {
     *     // ... filter to delete one Customerledger
     *   }
     * })
     * 
    **/
    delete<T extends customerledgerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, customerledgerDeleteArgs<ExtArgs>>
    ): Prisma__customerledgerClient<$Result.GetResult<Prisma.$customerledgerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Customerledger.
     * @param {customerledgerUpdateArgs} args - Arguments to update one Customerledger.
     * @example
     * // Update one Customerledger
     * const customerledger = await prisma.customerledger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends customerledgerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, customerledgerUpdateArgs<ExtArgs>>
    ): Prisma__customerledgerClient<$Result.GetResult<Prisma.$customerledgerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Customerledgers.
     * @param {customerledgerDeleteManyArgs} args - Arguments to filter Customerledgers to delete.
     * @example
     * // Delete a few Customerledgers
     * const { count } = await prisma.customerledger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends customerledgerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerledgerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customerledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerledgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customerledgers
     * const customerledger = await prisma.customerledger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends customerledgerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, customerledgerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customerledger.
     * @param {customerledgerUpsertArgs} args - Arguments to update or create a Customerledger.
     * @example
     * // Update or create a Customerledger
     * const customerledger = await prisma.customerledger.upsert({
     *   create: {
     *     // ... data to create a Customerledger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customerledger we want to update
     *   }
     * })
    **/
    upsert<T extends customerledgerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, customerledgerUpsertArgs<ExtArgs>>
    ): Prisma__customerledgerClient<$Result.GetResult<Prisma.$customerledgerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Customerledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerledgerCountArgs} args - Arguments to filter Customerledgers to count.
     * @example
     * // Count the number of Customerledgers
     * const count = await prisma.customerledger.count({
     *   where: {
     *     // ... the filter for the Customerledgers we want to count
     *   }
     * })
    **/
    count<T extends customerledgerCountArgs>(
      args?: Subset<T, customerledgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerledgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customerledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerledgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerledgerAggregateArgs>(args: Subset<T, CustomerledgerAggregateArgs>): Prisma.PrismaPromise<GetCustomerledgerAggregateType<T>>

    /**
     * Group by Customerledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerledgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerledgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerledgerGroupByArgs['orderBy'] }
        : { orderBy?: customerledgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerledgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerledgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customerledger model
   */
  readonly fields: customerledgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customerledger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerledgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the customerledger model
   */ 
  interface customerledgerFieldRefs {
    readonly id: FieldRef<"customerledger", 'Int'>
    readonly customerId: FieldRef<"customerledger", 'Int'>
    readonly payment_type: FieldRef<"customerledger", 'String'>
    readonly credit: FieldRef<"customerledger", 'Float'>
    readonly debit: FieldRef<"customerledger", 'Float'>
    readonly balance: FieldRef<"customerledger", 'Float'>
    readonly voucher_no: FieldRef<"customerledger", 'String'>
    readonly createdAt: FieldRef<"customerledger", 'DateTime'>
    readonly updatedAt: FieldRef<"customerledger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customerledger findUnique
   */
  export type customerledgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerledger
     */
    select?: customerledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerledgerInclude<ExtArgs> | null
    /**
     * Filter, which customerledger to fetch.
     */
    where: customerledgerWhereUniqueInput
  }

  /**
   * customerledger findUniqueOrThrow
   */
  export type customerledgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerledger
     */
    select?: customerledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerledgerInclude<ExtArgs> | null
    /**
     * Filter, which customerledger to fetch.
     */
    where: customerledgerWhereUniqueInput
  }

  /**
   * customerledger findFirst
   */
  export type customerledgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerledger
     */
    select?: customerledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerledgerInclude<ExtArgs> | null
    /**
     * Filter, which customerledger to fetch.
     */
    where?: customerledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerledgers to fetch.
     */
    orderBy?: customerledgerOrderByWithRelationInput | customerledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customerledgers.
     */
    cursor?: customerledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customerledgers.
     */
    distinct?: CustomerledgerScalarFieldEnum | CustomerledgerScalarFieldEnum[]
  }

  /**
   * customerledger findFirstOrThrow
   */
  export type customerledgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerledger
     */
    select?: customerledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerledgerInclude<ExtArgs> | null
    /**
     * Filter, which customerledger to fetch.
     */
    where?: customerledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerledgers to fetch.
     */
    orderBy?: customerledgerOrderByWithRelationInput | customerledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customerledgers.
     */
    cursor?: customerledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customerledgers.
     */
    distinct?: CustomerledgerScalarFieldEnum | CustomerledgerScalarFieldEnum[]
  }

  /**
   * customerledger findMany
   */
  export type customerledgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerledger
     */
    select?: customerledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerledgerInclude<ExtArgs> | null
    /**
     * Filter, which customerledgers to fetch.
     */
    where?: customerledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerledgers to fetch.
     */
    orderBy?: customerledgerOrderByWithRelationInput | customerledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customerledgers.
     */
    cursor?: customerledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerledgers.
     */
    skip?: number
    distinct?: CustomerledgerScalarFieldEnum | CustomerledgerScalarFieldEnum[]
  }

  /**
   * customerledger create
   */
  export type customerledgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerledger
     */
    select?: customerledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerledgerInclude<ExtArgs> | null
    /**
     * The data needed to create a customerledger.
     */
    data: XOR<customerledgerCreateInput, customerledgerUncheckedCreateInput>
  }

  /**
   * customerledger createMany
   */
  export type customerledgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customerledgers.
     */
    data: customerledgerCreateManyInput | customerledgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customerledger update
   */
  export type customerledgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerledger
     */
    select?: customerledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerledgerInclude<ExtArgs> | null
    /**
     * The data needed to update a customerledger.
     */
    data: XOR<customerledgerUpdateInput, customerledgerUncheckedUpdateInput>
    /**
     * Choose, which customerledger to update.
     */
    where: customerledgerWhereUniqueInput
  }

  /**
   * customerledger updateMany
   */
  export type customerledgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customerledgers.
     */
    data: XOR<customerledgerUpdateManyMutationInput, customerledgerUncheckedUpdateManyInput>
    /**
     * Filter which customerledgers to update
     */
    where?: customerledgerWhereInput
  }

  /**
   * customerledger upsert
   */
  export type customerledgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerledger
     */
    select?: customerledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerledgerInclude<ExtArgs> | null
    /**
     * The filter to search for the customerledger to update in case it exists.
     */
    where: customerledgerWhereUniqueInput
    /**
     * In case the customerledger found by the `where` argument doesn't exist, create a new customerledger with this data.
     */
    create: XOR<customerledgerCreateInput, customerledgerUncheckedCreateInput>
    /**
     * In case the customerledger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerledgerUpdateInput, customerledgerUncheckedUpdateInput>
  }

  /**
   * customerledger delete
   */
  export type customerledgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerledger
     */
    select?: customerledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerledgerInclude<ExtArgs> | null
    /**
     * Filter which customerledger to delete.
     */
    where: customerledgerWhereUniqueInput
  }

  /**
   * customerledger deleteMany
   */
  export type customerledgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customerledgers to delete
     */
    where?: customerledgerWhereInput
  }

  /**
   * customerledger without action
   */
  export type customerledgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerledger
     */
    select?: customerledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerledgerInclude<ExtArgs> | null
  }


  /**
   * Model purchasesuppliertrack
   */

  export type AggregatePurchasesuppliertrack = {
    _count: PurchasesuppliertrackCountAggregateOutputType | null
    _avg: PurchasesuppliertrackAvgAggregateOutputType | null
    _sum: PurchasesuppliertrackSumAggregateOutputType | null
    _min: PurchasesuppliertrackMinAggregateOutputType | null
    _max: PurchasesuppliertrackMaxAggregateOutputType | null
  }

  export type PurchasesuppliertrackAvgAggregateOutputType = {
    id: number | null
    supplierId: number | null
    curr_balance: number | null
  }

  export type PurchasesuppliertrackSumAggregateOutputType = {
    id: number | null
    supplierId: number | null
    curr_balance: number | null
  }

  export type PurchasesuppliertrackMinAggregateOutputType = {
    id: number | null
    supplierId: number | null
    curr_balance: number | null
    payment_type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchasesuppliertrackMaxAggregateOutputType = {
    id: number | null
    supplierId: number | null
    curr_balance: number | null
    payment_type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchasesuppliertrackCountAggregateOutputType = {
    id: number
    supplierId: number
    curr_balance: number
    payment_type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchasesuppliertrackAvgAggregateInputType = {
    id?: true
    supplierId?: true
    curr_balance?: true
  }

  export type PurchasesuppliertrackSumAggregateInputType = {
    id?: true
    supplierId?: true
    curr_balance?: true
  }

  export type PurchasesuppliertrackMinAggregateInputType = {
    id?: true
    supplierId?: true
    curr_balance?: true
    payment_type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchasesuppliertrackMaxAggregateInputType = {
    id?: true
    supplierId?: true
    curr_balance?: true
    payment_type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchasesuppliertrackCountAggregateInputType = {
    id?: true
    supplierId?: true
    curr_balance?: true
    payment_type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchasesuppliertrackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchasesuppliertrack to aggregate.
     */
    where?: purchasesuppliertrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchasesuppliertracks to fetch.
     */
    orderBy?: purchasesuppliertrackOrderByWithRelationInput | purchasesuppliertrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: purchasesuppliertrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchasesuppliertracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchasesuppliertracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned purchasesuppliertracks
    **/
    _count?: true | PurchasesuppliertrackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasesuppliertrackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasesuppliertrackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasesuppliertrackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasesuppliertrackMaxAggregateInputType
  }

  export type GetPurchasesuppliertrackAggregateType<T extends PurchasesuppliertrackAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasesuppliertrack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasesuppliertrack[P]>
      : GetScalarType<T[P], AggregatePurchasesuppliertrack[P]>
  }




  export type purchasesuppliertrackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: purchasesuppliertrackWhereInput
    orderBy?: purchasesuppliertrackOrderByWithAggregationInput | purchasesuppliertrackOrderByWithAggregationInput[]
    by: PurchasesuppliertrackScalarFieldEnum[] | PurchasesuppliertrackScalarFieldEnum
    having?: purchasesuppliertrackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasesuppliertrackCountAggregateInputType | true
    _avg?: PurchasesuppliertrackAvgAggregateInputType
    _sum?: PurchasesuppliertrackSumAggregateInputType
    _min?: PurchasesuppliertrackMinAggregateInputType
    _max?: PurchasesuppliertrackMaxAggregateInputType
  }

  export type PurchasesuppliertrackGroupByOutputType = {
    id: number
    supplierId: number
    curr_balance: number
    payment_type: string
    createdAt: Date
    updatedAt: Date
    _count: PurchasesuppliertrackCountAggregateOutputType | null
    _avg: PurchasesuppliertrackAvgAggregateOutputType | null
    _sum: PurchasesuppliertrackSumAggregateOutputType | null
    _min: PurchasesuppliertrackMinAggregateOutputType | null
    _max: PurchasesuppliertrackMaxAggregateOutputType | null
  }

  type GetPurchasesuppliertrackGroupByPayload<T extends purchasesuppliertrackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasesuppliertrackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasesuppliertrackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasesuppliertrackGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasesuppliertrackGroupByOutputType[P]>
        }
      >
    >


  export type purchasesuppliertrackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    curr_balance?: boolean
    payment_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasesuppliertrack"]>


  export type purchasesuppliertrackSelectScalar = {
    id?: boolean
    supplierId?: boolean
    curr_balance?: boolean
    payment_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type purchasesuppliertrackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }

  export type $purchasesuppliertrackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "purchasesuppliertrack"
    objects: {
      supplier: Prisma.$supplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplierId: number
      curr_balance: number
      payment_type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchasesuppliertrack"]>
    composites: {}
  }

  type purchasesuppliertrackGetPayload<S extends boolean | null | undefined | purchasesuppliertrackDefaultArgs> = $Result.GetResult<Prisma.$purchasesuppliertrackPayload, S>

  type purchasesuppliertrackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<purchasesuppliertrackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchasesuppliertrackCountAggregateInputType | true
    }

  export interface purchasesuppliertrackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['purchasesuppliertrack'], meta: { name: 'purchasesuppliertrack' } }
    /**
     * Find zero or one Purchasesuppliertrack that matches the filter.
     * @param {purchasesuppliertrackFindUniqueArgs} args - Arguments to find a Purchasesuppliertrack
     * @example
     * // Get one Purchasesuppliertrack
     * const purchasesuppliertrack = await prisma.purchasesuppliertrack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends purchasesuppliertrackFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, purchasesuppliertrackFindUniqueArgs<ExtArgs>>
    ): Prisma__purchasesuppliertrackClient<$Result.GetResult<Prisma.$purchasesuppliertrackPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Purchasesuppliertrack that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {purchasesuppliertrackFindUniqueOrThrowArgs} args - Arguments to find a Purchasesuppliertrack
     * @example
     * // Get one Purchasesuppliertrack
     * const purchasesuppliertrack = await prisma.purchasesuppliertrack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends purchasesuppliertrackFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, purchasesuppliertrackFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__purchasesuppliertrackClient<$Result.GetResult<Prisma.$purchasesuppliertrackPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Purchasesuppliertrack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchasesuppliertrackFindFirstArgs} args - Arguments to find a Purchasesuppliertrack
     * @example
     * // Get one Purchasesuppliertrack
     * const purchasesuppliertrack = await prisma.purchasesuppliertrack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends purchasesuppliertrackFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, purchasesuppliertrackFindFirstArgs<ExtArgs>>
    ): Prisma__purchasesuppliertrackClient<$Result.GetResult<Prisma.$purchasesuppliertrackPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Purchasesuppliertrack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchasesuppliertrackFindFirstOrThrowArgs} args - Arguments to find a Purchasesuppliertrack
     * @example
     * // Get one Purchasesuppliertrack
     * const purchasesuppliertrack = await prisma.purchasesuppliertrack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends purchasesuppliertrackFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, purchasesuppliertrackFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__purchasesuppliertrackClient<$Result.GetResult<Prisma.$purchasesuppliertrackPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Purchasesuppliertracks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchasesuppliertrackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchasesuppliertracks
     * const purchasesuppliertracks = await prisma.purchasesuppliertrack.findMany()
     * 
     * // Get first 10 Purchasesuppliertracks
     * const purchasesuppliertracks = await prisma.purchasesuppliertrack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasesuppliertrackWithIdOnly = await prisma.purchasesuppliertrack.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends purchasesuppliertrackFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchasesuppliertrackFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchasesuppliertrackPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Purchasesuppliertrack.
     * @param {purchasesuppliertrackCreateArgs} args - Arguments to create a Purchasesuppliertrack.
     * @example
     * // Create one Purchasesuppliertrack
     * const Purchasesuppliertrack = await prisma.purchasesuppliertrack.create({
     *   data: {
     *     // ... data to create a Purchasesuppliertrack
     *   }
     * })
     * 
    **/
    create<T extends purchasesuppliertrackCreateArgs<ExtArgs>>(
      args: SelectSubset<T, purchasesuppliertrackCreateArgs<ExtArgs>>
    ): Prisma__purchasesuppliertrackClient<$Result.GetResult<Prisma.$purchasesuppliertrackPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Purchasesuppliertracks.
     * @param {purchasesuppliertrackCreateManyArgs} args - Arguments to create many Purchasesuppliertracks.
     * @example
     * // Create many Purchasesuppliertracks
     * const purchasesuppliertrack = await prisma.purchasesuppliertrack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends purchasesuppliertrackCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchasesuppliertrackCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Purchasesuppliertrack.
     * @param {purchasesuppliertrackDeleteArgs} args - Arguments to delete one Purchasesuppliertrack.
     * @example
     * // Delete one Purchasesuppliertrack
     * const Purchasesuppliertrack = await prisma.purchasesuppliertrack.delete({
     *   where: {
     *     // ... filter to delete one Purchasesuppliertrack
     *   }
     * })
     * 
    **/
    delete<T extends purchasesuppliertrackDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, purchasesuppliertrackDeleteArgs<ExtArgs>>
    ): Prisma__purchasesuppliertrackClient<$Result.GetResult<Prisma.$purchasesuppliertrackPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Purchasesuppliertrack.
     * @param {purchasesuppliertrackUpdateArgs} args - Arguments to update one Purchasesuppliertrack.
     * @example
     * // Update one Purchasesuppliertrack
     * const purchasesuppliertrack = await prisma.purchasesuppliertrack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends purchasesuppliertrackUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, purchasesuppliertrackUpdateArgs<ExtArgs>>
    ): Prisma__purchasesuppliertrackClient<$Result.GetResult<Prisma.$purchasesuppliertrackPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Purchasesuppliertracks.
     * @param {purchasesuppliertrackDeleteManyArgs} args - Arguments to filter Purchasesuppliertracks to delete.
     * @example
     * // Delete a few Purchasesuppliertracks
     * const { count } = await prisma.purchasesuppliertrack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends purchasesuppliertrackDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchasesuppliertrackDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchasesuppliertracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchasesuppliertrackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchasesuppliertracks
     * const purchasesuppliertrack = await prisma.purchasesuppliertrack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends purchasesuppliertrackUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, purchasesuppliertrackUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchasesuppliertrack.
     * @param {purchasesuppliertrackUpsertArgs} args - Arguments to update or create a Purchasesuppliertrack.
     * @example
     * // Update or create a Purchasesuppliertrack
     * const purchasesuppliertrack = await prisma.purchasesuppliertrack.upsert({
     *   create: {
     *     // ... data to create a Purchasesuppliertrack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchasesuppliertrack we want to update
     *   }
     * })
    **/
    upsert<T extends purchasesuppliertrackUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, purchasesuppliertrackUpsertArgs<ExtArgs>>
    ): Prisma__purchasesuppliertrackClient<$Result.GetResult<Prisma.$purchasesuppliertrackPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Purchasesuppliertracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchasesuppliertrackCountArgs} args - Arguments to filter Purchasesuppliertracks to count.
     * @example
     * // Count the number of Purchasesuppliertracks
     * const count = await prisma.purchasesuppliertrack.count({
     *   where: {
     *     // ... the filter for the Purchasesuppliertracks we want to count
     *   }
     * })
    **/
    count<T extends purchasesuppliertrackCountArgs>(
      args?: Subset<T, purchasesuppliertrackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasesuppliertrackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchasesuppliertrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesuppliertrackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasesuppliertrackAggregateArgs>(args: Subset<T, PurchasesuppliertrackAggregateArgs>): Prisma.PrismaPromise<GetPurchasesuppliertrackAggregateType<T>>

    /**
     * Group by Purchasesuppliertrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchasesuppliertrackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends purchasesuppliertrackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: purchasesuppliertrackGroupByArgs['orderBy'] }
        : { orderBy?: purchasesuppliertrackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, purchasesuppliertrackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasesuppliertrackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the purchasesuppliertrack model
   */
  readonly fields: purchasesuppliertrackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for purchasesuppliertrack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__purchasesuppliertrackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    supplier<T extends supplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, supplierDefaultArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the purchasesuppliertrack model
   */ 
  interface purchasesuppliertrackFieldRefs {
    readonly id: FieldRef<"purchasesuppliertrack", 'Int'>
    readonly supplierId: FieldRef<"purchasesuppliertrack", 'Int'>
    readonly curr_balance: FieldRef<"purchasesuppliertrack", 'Float'>
    readonly payment_type: FieldRef<"purchasesuppliertrack", 'String'>
    readonly createdAt: FieldRef<"purchasesuppliertrack", 'DateTime'>
    readonly updatedAt: FieldRef<"purchasesuppliertrack", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * purchasesuppliertrack findUnique
   */
  export type purchasesuppliertrackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchasesuppliertrack
     */
    select?: purchasesuppliertrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchasesuppliertrackInclude<ExtArgs> | null
    /**
     * Filter, which purchasesuppliertrack to fetch.
     */
    where: purchasesuppliertrackWhereUniqueInput
  }

  /**
   * purchasesuppliertrack findUniqueOrThrow
   */
  export type purchasesuppliertrackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchasesuppliertrack
     */
    select?: purchasesuppliertrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchasesuppliertrackInclude<ExtArgs> | null
    /**
     * Filter, which purchasesuppliertrack to fetch.
     */
    where: purchasesuppliertrackWhereUniqueInput
  }

  /**
   * purchasesuppliertrack findFirst
   */
  export type purchasesuppliertrackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchasesuppliertrack
     */
    select?: purchasesuppliertrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchasesuppliertrackInclude<ExtArgs> | null
    /**
     * Filter, which purchasesuppliertrack to fetch.
     */
    where?: purchasesuppliertrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchasesuppliertracks to fetch.
     */
    orderBy?: purchasesuppliertrackOrderByWithRelationInput | purchasesuppliertrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchasesuppliertracks.
     */
    cursor?: purchasesuppliertrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchasesuppliertracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchasesuppliertracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchasesuppliertracks.
     */
    distinct?: PurchasesuppliertrackScalarFieldEnum | PurchasesuppliertrackScalarFieldEnum[]
  }

  /**
   * purchasesuppliertrack findFirstOrThrow
   */
  export type purchasesuppliertrackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchasesuppliertrack
     */
    select?: purchasesuppliertrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchasesuppliertrackInclude<ExtArgs> | null
    /**
     * Filter, which purchasesuppliertrack to fetch.
     */
    where?: purchasesuppliertrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchasesuppliertracks to fetch.
     */
    orderBy?: purchasesuppliertrackOrderByWithRelationInput | purchasesuppliertrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchasesuppliertracks.
     */
    cursor?: purchasesuppliertrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchasesuppliertracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchasesuppliertracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchasesuppliertracks.
     */
    distinct?: PurchasesuppliertrackScalarFieldEnum | PurchasesuppliertrackScalarFieldEnum[]
  }

  /**
   * purchasesuppliertrack findMany
   */
  export type purchasesuppliertrackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchasesuppliertrack
     */
    select?: purchasesuppliertrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchasesuppliertrackInclude<ExtArgs> | null
    /**
     * Filter, which purchasesuppliertracks to fetch.
     */
    where?: purchasesuppliertrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchasesuppliertracks to fetch.
     */
    orderBy?: purchasesuppliertrackOrderByWithRelationInput | purchasesuppliertrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing purchasesuppliertracks.
     */
    cursor?: purchasesuppliertrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchasesuppliertracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchasesuppliertracks.
     */
    skip?: number
    distinct?: PurchasesuppliertrackScalarFieldEnum | PurchasesuppliertrackScalarFieldEnum[]
  }

  /**
   * purchasesuppliertrack create
   */
  export type purchasesuppliertrackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchasesuppliertrack
     */
    select?: purchasesuppliertrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchasesuppliertrackInclude<ExtArgs> | null
    /**
     * The data needed to create a purchasesuppliertrack.
     */
    data: XOR<purchasesuppliertrackCreateInput, purchasesuppliertrackUncheckedCreateInput>
  }

  /**
   * purchasesuppliertrack createMany
   */
  export type purchasesuppliertrackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many purchasesuppliertracks.
     */
    data: purchasesuppliertrackCreateManyInput | purchasesuppliertrackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * purchasesuppliertrack update
   */
  export type purchasesuppliertrackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchasesuppliertrack
     */
    select?: purchasesuppliertrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchasesuppliertrackInclude<ExtArgs> | null
    /**
     * The data needed to update a purchasesuppliertrack.
     */
    data: XOR<purchasesuppliertrackUpdateInput, purchasesuppliertrackUncheckedUpdateInput>
    /**
     * Choose, which purchasesuppliertrack to update.
     */
    where: purchasesuppliertrackWhereUniqueInput
  }

  /**
   * purchasesuppliertrack updateMany
   */
  export type purchasesuppliertrackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update purchasesuppliertracks.
     */
    data: XOR<purchasesuppliertrackUpdateManyMutationInput, purchasesuppliertrackUncheckedUpdateManyInput>
    /**
     * Filter which purchasesuppliertracks to update
     */
    where?: purchasesuppliertrackWhereInput
  }

  /**
   * purchasesuppliertrack upsert
   */
  export type purchasesuppliertrackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchasesuppliertrack
     */
    select?: purchasesuppliertrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchasesuppliertrackInclude<ExtArgs> | null
    /**
     * The filter to search for the purchasesuppliertrack to update in case it exists.
     */
    where: purchasesuppliertrackWhereUniqueInput
    /**
     * In case the purchasesuppliertrack found by the `where` argument doesn't exist, create a new purchasesuppliertrack with this data.
     */
    create: XOR<purchasesuppliertrackCreateInput, purchasesuppliertrackUncheckedCreateInput>
    /**
     * In case the purchasesuppliertrack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<purchasesuppliertrackUpdateInput, purchasesuppliertrackUncheckedUpdateInput>
  }

  /**
   * purchasesuppliertrack delete
   */
  export type purchasesuppliertrackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchasesuppliertrack
     */
    select?: purchasesuppliertrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchasesuppliertrackInclude<ExtArgs> | null
    /**
     * Filter which purchasesuppliertrack to delete.
     */
    where: purchasesuppliertrackWhereUniqueInput
  }

  /**
   * purchasesuppliertrack deleteMany
   */
  export type purchasesuppliertrackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchasesuppliertracks to delete
     */
    where?: purchasesuppliertrackWhereInput
  }

  /**
   * purchasesuppliertrack without action
   */
  export type purchasesuppliertrackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchasesuppliertrack
     */
    select?: purchasesuppliertrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchasesuppliertrackInclude<ExtArgs> | null
  }


  /**
   * Model transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    supplierId: number | null
    balance: number | null
    payment: number | null
    curr_balance: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    supplierId: number | null
    balance: number | null
    payment: number | null
    curr_balance: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    supplierId: number | null
    balance: number | null
    transaction_type: string | null
    transaction_method: string | null
    payment: number | null
    curr_balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    supplierId: number | null
    balance: number | null
    transaction_type: string | null
    transaction_method: string | null
    payment: number | null
    curr_balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    supplierId: number
    balance: number
    transaction_type: number
    transaction_method: number
    payment: number
    curr_balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    supplierId?: true
    balance?: true
    payment?: true
    curr_balance?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    supplierId?: true
    balance?: true
    payment?: true
    curr_balance?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    supplierId?: true
    balance?: true
    transaction_type?: true
    transaction_method?: true
    payment?: true
    curr_balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    supplierId?: true
    balance?: true
    transaction_type?: true
    transaction_method?: true
    payment?: true
    curr_balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    supplierId?: true
    balance?: true
    transaction_type?: true
    transaction_method?: true
    payment?: true
    curr_balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction to aggregate.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type transactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithAggregationInput | transactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    supplierId: number
    balance: number
    transaction_type: string
    transaction_method: string
    payment: number
    curr_balance: number
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type transactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    balance?: boolean
    transaction_type?: boolean
    transaction_method?: boolean
    payment?: boolean
    curr_balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>


  export type transactionSelectScalar = {
    id?: boolean
    supplierId?: boolean
    balance?: boolean
    transaction_type?: boolean
    transaction_method?: boolean
    payment?: boolean
    curr_balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type transactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }

  export type $transactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaction"
    objects: {
      supplier: Prisma.$supplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplierId: number
      balance: number
      transaction_type: string
      transaction_method: string
      payment: number
      curr_balance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type transactionGetPayload<S extends boolean | null | undefined | transactionDefaultArgs> = $Result.GetResult<Prisma.$transactionPayload, S>

  type transactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<transactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface transactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaction'], meta: { name: 'transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {transactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends transactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, transactionFindUniqueArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {transactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends transactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends transactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionFindFirstArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends transactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends transactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Transaction.
     * @param {transactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
    **/
    create<T extends transactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, transactionCreateArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {transactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends transactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {transactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
    **/
    delete<T extends transactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, transactionDeleteArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {transactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends transactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, transactionUpdateArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {transactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends transactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends transactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, transactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {transactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends transactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, transactionUpsertArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionCountArgs>(
      args?: Subset<T, transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionGroupByArgs['orderBy'] }
        : { orderBy?: transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaction model
   */
  readonly fields: transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    supplier<T extends supplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, supplierDefaultArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the transaction model
   */ 
  interface transactionFieldRefs {
    readonly id: FieldRef<"transaction", 'Int'>
    readonly supplierId: FieldRef<"transaction", 'Int'>
    readonly balance: FieldRef<"transaction", 'Float'>
    readonly transaction_type: FieldRef<"transaction", 'String'>
    readonly transaction_method: FieldRef<"transaction", 'String'>
    readonly payment: FieldRef<"transaction", 'Float'>
    readonly curr_balance: FieldRef<"transaction", 'Float'>
    readonly createdAt: FieldRef<"transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transaction findUnique
   */
  export type transactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction findUniqueOrThrow
   */
  export type transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction findFirst
   */
  export type transactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction findFirstOrThrow
   */
  export type transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction findMany
   */
  export type transactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction create
   */
  export type transactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The data needed to create a transaction.
     */
    data: XOR<transactionCreateInput, transactionUncheckedCreateInput>
  }

  /**
   * transaction createMany
   */
  export type transactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionCreateManyInput | transactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaction update
   */
  export type transactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The data needed to update a transaction.
     */
    data: XOR<transactionUpdateInput, transactionUncheckedUpdateInput>
    /**
     * Choose, which transaction to update.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction updateMany
   */
  export type transactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionWhereInput
  }

  /**
   * transaction upsert
   */
  export type transactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The filter to search for the transaction to update in case it exists.
     */
    where: transactionWhereUniqueInput
    /**
     * In case the transaction found by the `where` argument doesn't exist, create a new transaction with this data.
     */
    create: XOR<transactionCreateInput, transactionUncheckedCreateInput>
    /**
     * In case the transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionUpdateInput, transactionUncheckedUpdateInput>
  }

  /**
   * transaction delete
   */
  export type transactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter which transaction to delete.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction deleteMany
   */
  export type transactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionWhereInput
  }

  /**
   * transaction without action
   */
  export type transactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
  }


  /**
   * Model supplierledger
   */

  export type AggregateSupplierledger = {
    _count: SupplierledgerCountAggregateOutputType | null
    _avg: SupplierledgerAvgAggregateOutputType | null
    _sum: SupplierledgerSumAggregateOutputType | null
    _min: SupplierledgerMinAggregateOutputType | null
    _max: SupplierledgerMaxAggregateOutputType | null
  }

  export type SupplierledgerAvgAggregateOutputType = {
    id: number | null
    supplierId: number | null
    credit: number | null
    debit: number | null
    balance: number | null
  }

  export type SupplierledgerSumAggregateOutputType = {
    id: number | null
    supplierId: number | null
    credit: number | null
    debit: number | null
    balance: number | null
  }

  export type SupplierledgerMinAggregateOutputType = {
    id: number | null
    supplierId: number | null
    payment_type: string | null
    voucher_no: string | null
    credit: number | null
    debit: number | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierledgerMaxAggregateOutputType = {
    id: number | null
    supplierId: number | null
    payment_type: string | null
    voucher_no: string | null
    credit: number | null
    debit: number | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierledgerCountAggregateOutputType = {
    id: number
    supplierId: number
    payment_type: number
    voucher_no: number
    credit: number
    debit: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierledgerAvgAggregateInputType = {
    id?: true
    supplierId?: true
    credit?: true
    debit?: true
    balance?: true
  }

  export type SupplierledgerSumAggregateInputType = {
    id?: true
    supplierId?: true
    credit?: true
    debit?: true
    balance?: true
  }

  export type SupplierledgerMinAggregateInputType = {
    id?: true
    supplierId?: true
    payment_type?: true
    voucher_no?: true
    credit?: true
    debit?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierledgerMaxAggregateInputType = {
    id?: true
    supplierId?: true
    payment_type?: true
    voucher_no?: true
    credit?: true
    debit?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierledgerCountAggregateInputType = {
    id?: true
    supplierId?: true
    payment_type?: true
    voucher_no?: true
    credit?: true
    debit?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierledgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supplierledger to aggregate.
     */
    where?: supplierledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supplierledgers to fetch.
     */
    orderBy?: supplierledgerOrderByWithRelationInput | supplierledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: supplierledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supplierledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supplierledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned supplierledgers
    **/
    _count?: true | SupplierledgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierledgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierledgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierledgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierledgerMaxAggregateInputType
  }

  export type GetSupplierledgerAggregateType<T extends SupplierledgerAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierledger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierledger[P]>
      : GetScalarType<T[P], AggregateSupplierledger[P]>
  }




  export type supplierledgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: supplierledgerWhereInput
    orderBy?: supplierledgerOrderByWithAggregationInput | supplierledgerOrderByWithAggregationInput[]
    by: SupplierledgerScalarFieldEnum[] | SupplierledgerScalarFieldEnum
    having?: supplierledgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierledgerCountAggregateInputType | true
    _avg?: SupplierledgerAvgAggregateInputType
    _sum?: SupplierledgerSumAggregateInputType
    _min?: SupplierledgerMinAggregateInputType
    _max?: SupplierledgerMaxAggregateInputType
  }

  export type SupplierledgerGroupByOutputType = {
    id: number
    supplierId: number
    payment_type: string
    voucher_no: string
    credit: number
    debit: number
    balance: number
    createdAt: Date
    updatedAt: Date
    _count: SupplierledgerCountAggregateOutputType | null
    _avg: SupplierledgerAvgAggregateOutputType | null
    _sum: SupplierledgerSumAggregateOutputType | null
    _min: SupplierledgerMinAggregateOutputType | null
    _max: SupplierledgerMaxAggregateOutputType | null
  }

  type GetSupplierledgerGroupByPayload<T extends supplierledgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierledgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierledgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierledgerGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierledgerGroupByOutputType[P]>
        }
      >
    >


  export type supplierledgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    payment_type?: boolean
    voucher_no?: boolean
    credit?: boolean
    debit?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierledger"]>


  export type supplierledgerSelectScalar = {
    id?: boolean
    supplierId?: boolean
    payment_type?: boolean
    voucher_no?: boolean
    credit?: boolean
    debit?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type supplierledgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }

  export type $supplierledgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "supplierledger"
    objects: {
      supplier: Prisma.$supplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplierId: number
      payment_type: string
      voucher_no: string
      credit: number
      debit: number
      balance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplierledger"]>
    composites: {}
  }

  type supplierledgerGetPayload<S extends boolean | null | undefined | supplierledgerDefaultArgs> = $Result.GetResult<Prisma.$supplierledgerPayload, S>

  type supplierledgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<supplierledgerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierledgerCountAggregateInputType | true
    }

  export interface supplierledgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['supplierledger'], meta: { name: 'supplierledger' } }
    /**
     * Find zero or one Supplierledger that matches the filter.
     * @param {supplierledgerFindUniqueArgs} args - Arguments to find a Supplierledger
     * @example
     * // Get one Supplierledger
     * const supplierledger = await prisma.supplierledger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends supplierledgerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, supplierledgerFindUniqueArgs<ExtArgs>>
    ): Prisma__supplierledgerClient<$Result.GetResult<Prisma.$supplierledgerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Supplierledger that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {supplierledgerFindUniqueOrThrowArgs} args - Arguments to find a Supplierledger
     * @example
     * // Get one Supplierledger
     * const supplierledger = await prisma.supplierledger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends supplierledgerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierledgerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__supplierledgerClient<$Result.GetResult<Prisma.$supplierledgerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Supplierledger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierledgerFindFirstArgs} args - Arguments to find a Supplierledger
     * @example
     * // Get one Supplierledger
     * const supplierledger = await prisma.supplierledger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends supplierledgerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierledgerFindFirstArgs<ExtArgs>>
    ): Prisma__supplierledgerClient<$Result.GetResult<Prisma.$supplierledgerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Supplierledger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierledgerFindFirstOrThrowArgs} args - Arguments to find a Supplierledger
     * @example
     * // Get one Supplierledger
     * const supplierledger = await prisma.supplierledger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends supplierledgerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierledgerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__supplierledgerClient<$Result.GetResult<Prisma.$supplierledgerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Supplierledgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierledgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Supplierledgers
     * const supplierledgers = await prisma.supplierledger.findMany()
     * 
     * // Get first 10 Supplierledgers
     * const supplierledgers = await prisma.supplierledger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierledgerWithIdOnly = await prisma.supplierledger.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends supplierledgerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierledgerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supplierledgerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Supplierledger.
     * @param {supplierledgerCreateArgs} args - Arguments to create a Supplierledger.
     * @example
     * // Create one Supplierledger
     * const Supplierledger = await prisma.supplierledger.create({
     *   data: {
     *     // ... data to create a Supplierledger
     *   }
     * })
     * 
    **/
    create<T extends supplierledgerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, supplierledgerCreateArgs<ExtArgs>>
    ): Prisma__supplierledgerClient<$Result.GetResult<Prisma.$supplierledgerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Supplierledgers.
     * @param {supplierledgerCreateManyArgs} args - Arguments to create many Supplierledgers.
     * @example
     * // Create many Supplierledgers
     * const supplierledger = await prisma.supplierledger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends supplierledgerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierledgerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplierledger.
     * @param {supplierledgerDeleteArgs} args - Arguments to delete one Supplierledger.
     * @example
     * // Delete one Supplierledger
     * const Supplierledger = await prisma.supplierledger.delete({
     *   where: {
     *     // ... filter to delete one Supplierledger
     *   }
     * })
     * 
    **/
    delete<T extends supplierledgerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, supplierledgerDeleteArgs<ExtArgs>>
    ): Prisma__supplierledgerClient<$Result.GetResult<Prisma.$supplierledgerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Supplierledger.
     * @param {supplierledgerUpdateArgs} args - Arguments to update one Supplierledger.
     * @example
     * // Update one Supplierledger
     * const supplierledger = await prisma.supplierledger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends supplierledgerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, supplierledgerUpdateArgs<ExtArgs>>
    ): Prisma__supplierledgerClient<$Result.GetResult<Prisma.$supplierledgerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Supplierledgers.
     * @param {supplierledgerDeleteManyArgs} args - Arguments to filter Supplierledgers to delete.
     * @example
     * // Delete a few Supplierledgers
     * const { count } = await prisma.supplierledger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends supplierledgerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierledgerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supplierledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierledgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Supplierledgers
     * const supplierledger = await prisma.supplierledger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends supplierledgerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, supplierledgerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplierledger.
     * @param {supplierledgerUpsertArgs} args - Arguments to update or create a Supplierledger.
     * @example
     * // Update or create a Supplierledger
     * const supplierledger = await prisma.supplierledger.upsert({
     *   create: {
     *     // ... data to create a Supplierledger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplierledger we want to update
     *   }
     * })
    **/
    upsert<T extends supplierledgerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, supplierledgerUpsertArgs<ExtArgs>>
    ): Prisma__supplierledgerClient<$Result.GetResult<Prisma.$supplierledgerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Supplierledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierledgerCountArgs} args - Arguments to filter Supplierledgers to count.
     * @example
     * // Count the number of Supplierledgers
     * const count = await prisma.supplierledger.count({
     *   where: {
     *     // ... the filter for the Supplierledgers we want to count
     *   }
     * })
    **/
    count<T extends supplierledgerCountArgs>(
      args?: Subset<T, supplierledgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierledgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplierledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierledgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierledgerAggregateArgs>(args: Subset<T, SupplierledgerAggregateArgs>): Prisma.PrismaPromise<GetSupplierledgerAggregateType<T>>

    /**
     * Group by Supplierledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierledgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends supplierledgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: supplierledgerGroupByArgs['orderBy'] }
        : { orderBy?: supplierledgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, supplierledgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierledgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the supplierledger model
   */
  readonly fields: supplierledgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for supplierledger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__supplierledgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    supplier<T extends supplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, supplierDefaultArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the supplierledger model
   */ 
  interface supplierledgerFieldRefs {
    readonly id: FieldRef<"supplierledger", 'Int'>
    readonly supplierId: FieldRef<"supplierledger", 'Int'>
    readonly payment_type: FieldRef<"supplierledger", 'String'>
    readonly voucher_no: FieldRef<"supplierledger", 'String'>
    readonly credit: FieldRef<"supplierledger", 'Float'>
    readonly debit: FieldRef<"supplierledger", 'Float'>
    readonly balance: FieldRef<"supplierledger", 'Float'>
    readonly createdAt: FieldRef<"supplierledger", 'DateTime'>
    readonly updatedAt: FieldRef<"supplierledger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * supplierledger findUnique
   */
  export type supplierledgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplierledger
     */
    select?: supplierledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierledgerInclude<ExtArgs> | null
    /**
     * Filter, which supplierledger to fetch.
     */
    where: supplierledgerWhereUniqueInput
  }

  /**
   * supplierledger findUniqueOrThrow
   */
  export type supplierledgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplierledger
     */
    select?: supplierledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierledgerInclude<ExtArgs> | null
    /**
     * Filter, which supplierledger to fetch.
     */
    where: supplierledgerWhereUniqueInput
  }

  /**
   * supplierledger findFirst
   */
  export type supplierledgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplierledger
     */
    select?: supplierledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierledgerInclude<ExtArgs> | null
    /**
     * Filter, which supplierledger to fetch.
     */
    where?: supplierledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supplierledgers to fetch.
     */
    orderBy?: supplierledgerOrderByWithRelationInput | supplierledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supplierledgers.
     */
    cursor?: supplierledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supplierledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supplierledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supplierledgers.
     */
    distinct?: SupplierledgerScalarFieldEnum | SupplierledgerScalarFieldEnum[]
  }

  /**
   * supplierledger findFirstOrThrow
   */
  export type supplierledgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplierledger
     */
    select?: supplierledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierledgerInclude<ExtArgs> | null
    /**
     * Filter, which supplierledger to fetch.
     */
    where?: supplierledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supplierledgers to fetch.
     */
    orderBy?: supplierledgerOrderByWithRelationInput | supplierledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supplierledgers.
     */
    cursor?: supplierledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supplierledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supplierledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supplierledgers.
     */
    distinct?: SupplierledgerScalarFieldEnum | SupplierledgerScalarFieldEnum[]
  }

  /**
   * supplierledger findMany
   */
  export type supplierledgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplierledger
     */
    select?: supplierledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierledgerInclude<ExtArgs> | null
    /**
     * Filter, which supplierledgers to fetch.
     */
    where?: supplierledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supplierledgers to fetch.
     */
    orderBy?: supplierledgerOrderByWithRelationInput | supplierledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing supplierledgers.
     */
    cursor?: supplierledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supplierledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supplierledgers.
     */
    skip?: number
    distinct?: SupplierledgerScalarFieldEnum | SupplierledgerScalarFieldEnum[]
  }

  /**
   * supplierledger create
   */
  export type supplierledgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplierledger
     */
    select?: supplierledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierledgerInclude<ExtArgs> | null
    /**
     * The data needed to create a supplierledger.
     */
    data: XOR<supplierledgerCreateInput, supplierledgerUncheckedCreateInput>
  }

  /**
   * supplierledger createMany
   */
  export type supplierledgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many supplierledgers.
     */
    data: supplierledgerCreateManyInput | supplierledgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * supplierledger update
   */
  export type supplierledgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplierledger
     */
    select?: supplierledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierledgerInclude<ExtArgs> | null
    /**
     * The data needed to update a supplierledger.
     */
    data: XOR<supplierledgerUpdateInput, supplierledgerUncheckedUpdateInput>
    /**
     * Choose, which supplierledger to update.
     */
    where: supplierledgerWhereUniqueInput
  }

  /**
   * supplierledger updateMany
   */
  export type supplierledgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update supplierledgers.
     */
    data: XOR<supplierledgerUpdateManyMutationInput, supplierledgerUncheckedUpdateManyInput>
    /**
     * Filter which supplierledgers to update
     */
    where?: supplierledgerWhereInput
  }

  /**
   * supplierledger upsert
   */
  export type supplierledgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplierledger
     */
    select?: supplierledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierledgerInclude<ExtArgs> | null
    /**
     * The filter to search for the supplierledger to update in case it exists.
     */
    where: supplierledgerWhereUniqueInput
    /**
     * In case the supplierledger found by the `where` argument doesn't exist, create a new supplierledger with this data.
     */
    create: XOR<supplierledgerCreateInput, supplierledgerUncheckedCreateInput>
    /**
     * In case the supplierledger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<supplierledgerUpdateInput, supplierledgerUncheckedUpdateInput>
  }

  /**
   * supplierledger delete
   */
  export type supplierledgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplierledger
     */
    select?: supplierledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierledgerInclude<ExtArgs> | null
    /**
     * Filter which supplierledger to delete.
     */
    where: supplierledgerWhereUniqueInput
  }

  /**
   * supplierledger deleteMany
   */
  export type supplierledgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supplierledgers to delete
     */
    where?: supplierledgerWhereInput
  }

  /**
   * supplierledger without action
   */
  export type supplierledgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplierledger
     */
    select?: supplierledgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierledgerInclude<ExtArgs> | null
  }


  /**
   * Model customerdetails
   */

  export type AggregateCustomerdetails = {
    _count: CustomerdetailsCountAggregateOutputType | null
    _avg: CustomerdetailsAvgAggregateOutputType | null
    _sum: CustomerdetailsSumAggregateOutputType | null
    _min: CustomerdetailsMinAggregateOutputType | null
    _max: CustomerdetailsMaxAggregateOutputType | null
  }

  export type CustomerdetailsAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type CustomerdetailsSumAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type CustomerdetailsMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    customer_name: string | null
    mob_no: string | null
    address: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerdetailsMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    customer_name: string | null
    mob_no: string | null
    address: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerdetailsCountAggregateOutputType = {
    id: number
    customerId: number
    customer_name: number
    mob_no: number
    address: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerdetailsAvgAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type CustomerdetailsSumAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type CustomerdetailsMinAggregateInputType = {
    id?: true
    customerId?: true
    customer_name?: true
    mob_no?: true
    address?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerdetailsMaxAggregateInputType = {
    id?: true
    customerId?: true
    customer_name?: true
    mob_no?: true
    address?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerdetailsCountAggregateInputType = {
    id?: true
    customerId?: true
    customer_name?: true
    mob_no?: true
    address?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerdetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customerdetails to aggregate.
     */
    where?: customerdetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerdetails to fetch.
     */
    orderBy?: customerdetailsOrderByWithRelationInput | customerdetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerdetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerdetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerdetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customerdetails
    **/
    _count?: true | CustomerdetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerdetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerdetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerdetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerdetailsMaxAggregateInputType
  }

  export type GetCustomerdetailsAggregateType<T extends CustomerdetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerdetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerdetails[P]>
      : GetScalarType<T[P], AggregateCustomerdetails[P]>
  }




  export type customerdetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerdetailsWhereInput
    orderBy?: customerdetailsOrderByWithAggregationInput | customerdetailsOrderByWithAggregationInput[]
    by: CustomerdetailsScalarFieldEnum[] | CustomerdetailsScalarFieldEnum
    having?: customerdetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerdetailsCountAggregateInputType | true
    _avg?: CustomerdetailsAvgAggregateInputType
    _sum?: CustomerdetailsSumAggregateInputType
    _min?: CustomerdetailsMinAggregateInputType
    _max?: CustomerdetailsMaxAggregateInputType
  }

  export type CustomerdetailsGroupByOutputType = {
    id: number
    customerId: number
    customer_name: string
    mob_no: string
    address: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerdetailsCountAggregateOutputType | null
    _avg: CustomerdetailsAvgAggregateOutputType | null
    _sum: CustomerdetailsSumAggregateOutputType | null
    _min: CustomerdetailsMinAggregateOutputType | null
    _max: CustomerdetailsMaxAggregateOutputType | null
  }

  type GetCustomerdetailsGroupByPayload<T extends customerdetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerdetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerdetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerdetailsGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerdetailsGroupByOutputType[P]>
        }
      >
    >


  export type customerdetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    customer_name?: boolean
    mob_no?: boolean
    address?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerdetails"]>


  export type customerdetailsSelectScalar = {
    id?: boolean
    customerId?: boolean
    customer_name?: boolean
    mob_no?: boolean
    address?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type customerdetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }

  export type $customerdetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customerdetails"
    objects: {
      customer: Prisma.$customerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number
      customer_name: string
      mob_no: string
      address: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerdetails"]>
    composites: {}
  }

  type customerdetailsGetPayload<S extends boolean | null | undefined | customerdetailsDefaultArgs> = $Result.GetResult<Prisma.$customerdetailsPayload, S>

  type customerdetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<customerdetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerdetailsCountAggregateInputType | true
    }

  export interface customerdetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customerdetails'], meta: { name: 'customerdetails' } }
    /**
     * Find zero or one Customerdetails that matches the filter.
     * @param {customerdetailsFindUniqueArgs} args - Arguments to find a Customerdetails
     * @example
     * // Get one Customerdetails
     * const customerdetails = await prisma.customerdetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends customerdetailsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, customerdetailsFindUniqueArgs<ExtArgs>>
    ): Prisma__customerdetailsClient<$Result.GetResult<Prisma.$customerdetailsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Customerdetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {customerdetailsFindUniqueOrThrowArgs} args - Arguments to find a Customerdetails
     * @example
     * // Get one Customerdetails
     * const customerdetails = await prisma.customerdetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends customerdetailsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customerdetailsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__customerdetailsClient<$Result.GetResult<Prisma.$customerdetailsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Customerdetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerdetailsFindFirstArgs} args - Arguments to find a Customerdetails
     * @example
     * // Get one Customerdetails
     * const customerdetails = await prisma.customerdetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends customerdetailsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, customerdetailsFindFirstArgs<ExtArgs>>
    ): Prisma__customerdetailsClient<$Result.GetResult<Prisma.$customerdetailsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Customerdetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerdetailsFindFirstOrThrowArgs} args - Arguments to find a Customerdetails
     * @example
     * // Get one Customerdetails
     * const customerdetails = await prisma.customerdetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends customerdetailsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customerdetailsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__customerdetailsClient<$Result.GetResult<Prisma.$customerdetailsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Customerdetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerdetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customerdetails
     * const customerdetails = await prisma.customerdetails.findMany()
     * 
     * // Get first 10 Customerdetails
     * const customerdetails = await prisma.customerdetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerdetailsWithIdOnly = await prisma.customerdetails.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends customerdetailsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerdetailsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerdetailsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Customerdetails.
     * @param {customerdetailsCreateArgs} args - Arguments to create a Customerdetails.
     * @example
     * // Create one Customerdetails
     * const Customerdetails = await prisma.customerdetails.create({
     *   data: {
     *     // ... data to create a Customerdetails
     *   }
     * })
     * 
    **/
    create<T extends customerdetailsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, customerdetailsCreateArgs<ExtArgs>>
    ): Prisma__customerdetailsClient<$Result.GetResult<Prisma.$customerdetailsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Customerdetails.
     * @param {customerdetailsCreateManyArgs} args - Arguments to create many Customerdetails.
     * @example
     * // Create many Customerdetails
     * const customerdetails = await prisma.customerdetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends customerdetailsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerdetailsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customerdetails.
     * @param {customerdetailsDeleteArgs} args - Arguments to delete one Customerdetails.
     * @example
     * // Delete one Customerdetails
     * const Customerdetails = await prisma.customerdetails.delete({
     *   where: {
     *     // ... filter to delete one Customerdetails
     *   }
     * })
     * 
    **/
    delete<T extends customerdetailsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, customerdetailsDeleteArgs<ExtArgs>>
    ): Prisma__customerdetailsClient<$Result.GetResult<Prisma.$customerdetailsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Customerdetails.
     * @param {customerdetailsUpdateArgs} args - Arguments to update one Customerdetails.
     * @example
     * // Update one Customerdetails
     * const customerdetails = await prisma.customerdetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends customerdetailsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, customerdetailsUpdateArgs<ExtArgs>>
    ): Prisma__customerdetailsClient<$Result.GetResult<Prisma.$customerdetailsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Customerdetails.
     * @param {customerdetailsDeleteManyArgs} args - Arguments to filter Customerdetails to delete.
     * @example
     * // Delete a few Customerdetails
     * const { count } = await prisma.customerdetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends customerdetailsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerdetailsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customerdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerdetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customerdetails
     * const customerdetails = await prisma.customerdetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends customerdetailsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, customerdetailsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customerdetails.
     * @param {customerdetailsUpsertArgs} args - Arguments to update or create a Customerdetails.
     * @example
     * // Update or create a Customerdetails
     * const customerdetails = await prisma.customerdetails.upsert({
     *   create: {
     *     // ... data to create a Customerdetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customerdetails we want to update
     *   }
     * })
    **/
    upsert<T extends customerdetailsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, customerdetailsUpsertArgs<ExtArgs>>
    ): Prisma__customerdetailsClient<$Result.GetResult<Prisma.$customerdetailsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Customerdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerdetailsCountArgs} args - Arguments to filter Customerdetails to count.
     * @example
     * // Count the number of Customerdetails
     * const count = await prisma.customerdetails.count({
     *   where: {
     *     // ... the filter for the Customerdetails we want to count
     *   }
     * })
    **/
    count<T extends customerdetailsCountArgs>(
      args?: Subset<T, customerdetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerdetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customerdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerdetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerdetailsAggregateArgs>(args: Subset<T, CustomerdetailsAggregateArgs>): Prisma.PrismaPromise<GetCustomerdetailsAggregateType<T>>

    /**
     * Group by Customerdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerdetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerdetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerdetailsGroupByArgs['orderBy'] }
        : { orderBy?: customerdetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerdetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerdetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customerdetails model
   */
  readonly fields: customerdetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customerdetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerdetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the customerdetails model
   */ 
  interface customerdetailsFieldRefs {
    readonly id: FieldRef<"customerdetails", 'Int'>
    readonly customerId: FieldRef<"customerdetails", 'Int'>
    readonly customer_name: FieldRef<"customerdetails", 'String'>
    readonly mob_no: FieldRef<"customerdetails", 'String'>
    readonly address: FieldRef<"customerdetails", 'String'>
    readonly description: FieldRef<"customerdetails", 'String'>
    readonly createdAt: FieldRef<"customerdetails", 'DateTime'>
    readonly updatedAt: FieldRef<"customerdetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customerdetails findUnique
   */
  export type customerdetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerdetails
     */
    select?: customerdetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerdetailsInclude<ExtArgs> | null
    /**
     * Filter, which customerdetails to fetch.
     */
    where: customerdetailsWhereUniqueInput
  }

  /**
   * customerdetails findUniqueOrThrow
   */
  export type customerdetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerdetails
     */
    select?: customerdetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerdetailsInclude<ExtArgs> | null
    /**
     * Filter, which customerdetails to fetch.
     */
    where: customerdetailsWhereUniqueInput
  }

  /**
   * customerdetails findFirst
   */
  export type customerdetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerdetails
     */
    select?: customerdetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerdetailsInclude<ExtArgs> | null
    /**
     * Filter, which customerdetails to fetch.
     */
    where?: customerdetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerdetails to fetch.
     */
    orderBy?: customerdetailsOrderByWithRelationInput | customerdetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customerdetails.
     */
    cursor?: customerdetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerdetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerdetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customerdetails.
     */
    distinct?: CustomerdetailsScalarFieldEnum | CustomerdetailsScalarFieldEnum[]
  }

  /**
   * customerdetails findFirstOrThrow
   */
  export type customerdetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerdetails
     */
    select?: customerdetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerdetailsInclude<ExtArgs> | null
    /**
     * Filter, which customerdetails to fetch.
     */
    where?: customerdetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerdetails to fetch.
     */
    orderBy?: customerdetailsOrderByWithRelationInput | customerdetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customerdetails.
     */
    cursor?: customerdetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerdetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerdetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customerdetails.
     */
    distinct?: CustomerdetailsScalarFieldEnum | CustomerdetailsScalarFieldEnum[]
  }

  /**
   * customerdetails findMany
   */
  export type customerdetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerdetails
     */
    select?: customerdetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerdetailsInclude<ExtArgs> | null
    /**
     * Filter, which customerdetails to fetch.
     */
    where?: customerdetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerdetails to fetch.
     */
    orderBy?: customerdetailsOrderByWithRelationInput | customerdetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customerdetails.
     */
    cursor?: customerdetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerdetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerdetails.
     */
    skip?: number
    distinct?: CustomerdetailsScalarFieldEnum | CustomerdetailsScalarFieldEnum[]
  }

  /**
   * customerdetails create
   */
  export type customerdetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerdetails
     */
    select?: customerdetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerdetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a customerdetails.
     */
    data: XOR<customerdetailsCreateInput, customerdetailsUncheckedCreateInput>
  }

  /**
   * customerdetails createMany
   */
  export type customerdetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customerdetails.
     */
    data: customerdetailsCreateManyInput | customerdetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customerdetails update
   */
  export type customerdetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerdetails
     */
    select?: customerdetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerdetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a customerdetails.
     */
    data: XOR<customerdetailsUpdateInput, customerdetailsUncheckedUpdateInput>
    /**
     * Choose, which customerdetails to update.
     */
    where: customerdetailsWhereUniqueInput
  }

  /**
   * customerdetails updateMany
   */
  export type customerdetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customerdetails.
     */
    data: XOR<customerdetailsUpdateManyMutationInput, customerdetailsUncheckedUpdateManyInput>
    /**
     * Filter which customerdetails to update
     */
    where?: customerdetailsWhereInput
  }

  /**
   * customerdetails upsert
   */
  export type customerdetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerdetails
     */
    select?: customerdetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerdetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the customerdetails to update in case it exists.
     */
    where: customerdetailsWhereUniqueInput
    /**
     * In case the customerdetails found by the `where` argument doesn't exist, create a new customerdetails with this data.
     */
    create: XOR<customerdetailsCreateInput, customerdetailsUncheckedCreateInput>
    /**
     * In case the customerdetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerdetailsUpdateInput, customerdetailsUncheckedUpdateInput>
  }

  /**
   * customerdetails delete
   */
  export type customerdetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerdetails
     */
    select?: customerdetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerdetailsInclude<ExtArgs> | null
    /**
     * Filter which customerdetails to delete.
     */
    where: customerdetailsWhereUniqueInput
  }

  /**
   * customerdetails deleteMany
   */
  export type customerdetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customerdetails to delete
     */
    where?: customerdetailsWhereInput
  }

  /**
   * customerdetails without action
   */
  export type customerdetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerdetails
     */
    select?: customerdetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerdetailsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    category_name: 'category_name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const UnitsScalarFieldEnum: {
    id: 'id',
    units_name: 'units_name',
    units_label: 'units_label',
    relation: 'relation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitsScalarFieldEnum = (typeof UnitsScalarFieldEnum)[keyof typeof UnitsScalarFieldEnum]


  export const BrandsScalarFieldEnum: {
    id: 'id',
    brands_name: 'brands_name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandsScalarFieldEnum = (typeof BrandsScalarFieldEnum)[keyof typeof BrandsScalarFieldEnum]


  export const ItemsScalarFieldEnum: {
    id: 'id',
    items_name: 'items_name',
    categoryId: 'categoryId',
    description: 'description',
    brandsId: 'brandsId',
    unitsId: 'unitsId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemsScalarFieldEnum = (typeof ItemsScalarFieldEnum)[keyof typeof ItemsScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    supplier_name: 'supplier_name',
    contact_person: 'contact_person',
    mobile_number: 'mobile_number',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const PurchaseitemsScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    supplierId: 'supplierId',
    purchase_qty: 'purchase_qty',
    price_per_unit: 'price_per_unit',
    price_avg: 'price_avg',
    purchase_total: 'purchase_total',
    subtotal_amount: 'subtotal_amount',
    purchase_update_qty: 'purchase_update_qty',
    tax_Id: 'tax_Id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseitemsScalarFieldEnum = (typeof PurchaseitemsScalarFieldEnum)[keyof typeof PurchaseitemsScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    supplierId: 'supplierId',
    purchase_qty: 'purchase_qty',
    price_per_unit: 'price_per_unit',
    purchase_total: 'purchase_total',
    subtotal_amount: 'subtotal_amount',
    tax_Id: 'tax_Id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const SalesScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    customerId: 'customerId',
    sale_qty: 'sale_qty',
    sales_price: 'sales_price',
    discount: 'discount',
    transport_cost: 'transport_cost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesScalarFieldEnum = (typeof SalesScalarFieldEnum)[keyof typeof SalesScalarFieldEnum]


  export const CustomertypeScalarFieldEnum: {
    id: 'id',
    type_name: 'type_name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomertypeScalarFieldEnum = (typeof CustomertypeScalarFieldEnum)[keyof typeof CustomertypeScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    customer_name: 'customer_name',
    customertypeId: 'customertypeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SalescustomertrackerScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    curr_balance: 'curr_balance',
    payment_type: 'payment_type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalescustomertrackerScalarFieldEnum = (typeof SalescustomertrackerScalarFieldEnum)[keyof typeof SalescustomertrackerScalarFieldEnum]


  export const CustomerpaymentScalarFieldEnum: {
    id: 'id',
    customertypeId: 'customertypeId',
    customerId: 'customerId',
    balance: 'balance',
    transaction_type: 'transaction_type',
    collection_method: 'collection_method',
    paid: 'paid',
    remission: 'remission',
    curr_balance: 'curr_balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerpaymentScalarFieldEnum = (typeof CustomerpaymentScalarFieldEnum)[keyof typeof CustomerpaymentScalarFieldEnum]


  export const CustomerledgerScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    payment_type: 'payment_type',
    credit: 'credit',
    debit: 'debit',
    balance: 'balance',
    voucher_no: 'voucher_no',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerledgerScalarFieldEnum = (typeof CustomerledgerScalarFieldEnum)[keyof typeof CustomerledgerScalarFieldEnum]


  export const PurchasesuppliertrackScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    curr_balance: 'curr_balance',
    payment_type: 'payment_type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchasesuppliertrackScalarFieldEnum = (typeof PurchasesuppliertrackScalarFieldEnum)[keyof typeof PurchasesuppliertrackScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    balance: 'balance',
    transaction_type: 'transaction_type',
    transaction_method: 'transaction_method',
    payment: 'payment',
    curr_balance: 'curr_balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const SupplierledgerScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    payment_type: 'payment_type',
    voucher_no: 'voucher_no',
    credit: 'credit',
    debit: 'debit',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierledgerScalarFieldEnum = (typeof SupplierledgerScalarFieldEnum)[keyof typeof SupplierledgerScalarFieldEnum]


  export const CustomerdetailsScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    customer_name: 'customer_name',
    mob_no: 'mob_no',
    address: 'address',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerdetailsScalarFieldEnum = (typeof CustomerdetailsScalarFieldEnum)[keyof typeof CustomerdetailsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    email?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    role?: StringFilter<"user"> | string
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    password?: StringFilter<"user"> | string
    role?: StringFilter<"user"> | string
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    email?: StringWithAggregatesFilter<"user"> | string
    password?: StringWithAggregatesFilter<"user"> | string
    role?: StringWithAggregatesFilter<"user"> | string
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type categoryWhereInput = {
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    id?: IntFilter<"category"> | number
    category_name?: StringFilter<"category"> | string
    createdAt?: DateTimeFilter<"category"> | Date | string
    updatedAt?: DateTimeFilter<"category"> | Date | string
    items?: ItemsListRelationFilter
  }

  export type categoryOrderByWithRelationInput = {
    id?: SortOrder
    category_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: itemsOrderByRelationAggregateInput
  }

  export type categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    category_name?: StringFilter<"category"> | string
    createdAt?: DateTimeFilter<"category"> | Date | string
    updatedAt?: DateTimeFilter<"category"> | Date | string
    items?: ItemsListRelationFilter
  }, "id">

  export type categoryOrderByWithAggregationInput = {
    id?: SortOrder
    category_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: categoryCountOrderByAggregateInput
    _avg?: categoryAvgOrderByAggregateInput
    _max?: categoryMaxOrderByAggregateInput
    _min?: categoryMinOrderByAggregateInput
    _sum?: categorySumOrderByAggregateInput
  }

  export type categoryScalarWhereWithAggregatesInput = {
    AND?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    OR?: categoryScalarWhereWithAggregatesInput[]
    NOT?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"category"> | number
    category_name?: StringWithAggregatesFilter<"category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"category"> | Date | string
  }

  export type unitsWhereInput = {
    AND?: unitsWhereInput | unitsWhereInput[]
    OR?: unitsWhereInput[]
    NOT?: unitsWhereInput | unitsWhereInput[]
    id?: IntFilter<"units"> | number
    units_name?: StringFilter<"units"> | string
    units_label?: StringFilter<"units"> | string
    relation?: FloatFilter<"units"> | number
    createdAt?: DateTimeFilter<"units"> | Date | string
    updatedAt?: DateTimeFilter<"units"> | Date | string
    items?: ItemsListRelationFilter
  }

  export type unitsOrderByWithRelationInput = {
    id?: SortOrder
    units_name?: SortOrder
    units_label?: SortOrder
    relation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: itemsOrderByRelationAggregateInput
  }

  export type unitsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: unitsWhereInput | unitsWhereInput[]
    OR?: unitsWhereInput[]
    NOT?: unitsWhereInput | unitsWhereInput[]
    units_name?: StringFilter<"units"> | string
    units_label?: StringFilter<"units"> | string
    relation?: FloatFilter<"units"> | number
    createdAt?: DateTimeFilter<"units"> | Date | string
    updatedAt?: DateTimeFilter<"units"> | Date | string
    items?: ItemsListRelationFilter
  }, "id">

  export type unitsOrderByWithAggregationInput = {
    id?: SortOrder
    units_name?: SortOrder
    units_label?: SortOrder
    relation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: unitsCountOrderByAggregateInput
    _avg?: unitsAvgOrderByAggregateInput
    _max?: unitsMaxOrderByAggregateInput
    _min?: unitsMinOrderByAggregateInput
    _sum?: unitsSumOrderByAggregateInput
  }

  export type unitsScalarWhereWithAggregatesInput = {
    AND?: unitsScalarWhereWithAggregatesInput | unitsScalarWhereWithAggregatesInput[]
    OR?: unitsScalarWhereWithAggregatesInput[]
    NOT?: unitsScalarWhereWithAggregatesInput | unitsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"units"> | number
    units_name?: StringWithAggregatesFilter<"units"> | string
    units_label?: StringWithAggregatesFilter<"units"> | string
    relation?: FloatWithAggregatesFilter<"units"> | number
    createdAt?: DateTimeWithAggregatesFilter<"units"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"units"> | Date | string
  }

  export type brandsWhereInput = {
    AND?: brandsWhereInput | brandsWhereInput[]
    OR?: brandsWhereInput[]
    NOT?: brandsWhereInput | brandsWhereInput[]
    id?: IntFilter<"brands"> | number
    brands_name?: StringFilter<"brands"> | string
    createdAt?: DateTimeFilter<"brands"> | Date | string
    updatedAt?: DateTimeFilter<"brands"> | Date | string
    items?: ItemsListRelationFilter
  }

  export type brandsOrderByWithRelationInput = {
    id?: SortOrder
    brands_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: itemsOrderByRelationAggregateInput
  }

  export type brandsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: brandsWhereInput | brandsWhereInput[]
    OR?: brandsWhereInput[]
    NOT?: brandsWhereInput | brandsWhereInput[]
    brands_name?: StringFilter<"brands"> | string
    createdAt?: DateTimeFilter<"brands"> | Date | string
    updatedAt?: DateTimeFilter<"brands"> | Date | string
    items?: ItemsListRelationFilter
  }, "id">

  export type brandsOrderByWithAggregationInput = {
    id?: SortOrder
    brands_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: brandsCountOrderByAggregateInput
    _avg?: brandsAvgOrderByAggregateInput
    _max?: brandsMaxOrderByAggregateInput
    _min?: brandsMinOrderByAggregateInput
    _sum?: brandsSumOrderByAggregateInput
  }

  export type brandsScalarWhereWithAggregatesInput = {
    AND?: brandsScalarWhereWithAggregatesInput | brandsScalarWhereWithAggregatesInput[]
    OR?: brandsScalarWhereWithAggregatesInput[]
    NOT?: brandsScalarWhereWithAggregatesInput | brandsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"brands"> | number
    brands_name?: StringWithAggregatesFilter<"brands"> | string
    createdAt?: DateTimeWithAggregatesFilter<"brands"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"brands"> | Date | string
  }

  export type itemsWhereInput = {
    AND?: itemsWhereInput | itemsWhereInput[]
    OR?: itemsWhereInput[]
    NOT?: itemsWhereInput | itemsWhereInput[]
    id?: IntFilter<"items"> | number
    items_name?: StringFilter<"items"> | string
    categoryId?: IntFilter<"items"> | number
    description?: StringFilter<"items"> | string
    brandsId?: IntFilter<"items"> | number
    unitsId?: IntFilter<"items"> | number
    createdAt?: DateTimeFilter<"items"> | Date | string
    updatedAt?: DateTimeFilter<"items"> | Date | string
    purchaseitems?: PurchaseitemsListRelationFilter
    Purchase?: PurchaseListRelationFilter
    sales?: SalesListRelationFilter
    items_category?: XOR<CategoryRelationFilter, categoryWhereInput>
    items_brands?: XOR<BrandsRelationFilter, brandsWhereInput>
    items_units?: XOR<UnitsRelationFilter, unitsWhereInput>
  }

  export type itemsOrderByWithRelationInput = {
    id?: SortOrder
    items_name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    brandsId?: SortOrder
    unitsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseitems?: purchaseitemsOrderByRelationAggregateInput
    Purchase?: purchaseOrderByRelationAggregateInput
    sales?: salesOrderByRelationAggregateInput
    items_category?: categoryOrderByWithRelationInput
    items_brands?: brandsOrderByWithRelationInput
    items_units?: unitsOrderByWithRelationInput
  }

  export type itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: itemsWhereInput | itemsWhereInput[]
    OR?: itemsWhereInput[]
    NOT?: itemsWhereInput | itemsWhereInput[]
    items_name?: StringFilter<"items"> | string
    categoryId?: IntFilter<"items"> | number
    description?: StringFilter<"items"> | string
    brandsId?: IntFilter<"items"> | number
    unitsId?: IntFilter<"items"> | number
    createdAt?: DateTimeFilter<"items"> | Date | string
    updatedAt?: DateTimeFilter<"items"> | Date | string
    purchaseitems?: PurchaseitemsListRelationFilter
    Purchase?: PurchaseListRelationFilter
    sales?: SalesListRelationFilter
    items_category?: XOR<CategoryRelationFilter, categoryWhereInput>
    items_brands?: XOR<BrandsRelationFilter, brandsWhereInput>
    items_units?: XOR<UnitsRelationFilter, unitsWhereInput>
  }, "id">

  export type itemsOrderByWithAggregationInput = {
    id?: SortOrder
    items_name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    brandsId?: SortOrder
    unitsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: itemsCountOrderByAggregateInput
    _avg?: itemsAvgOrderByAggregateInput
    _max?: itemsMaxOrderByAggregateInput
    _min?: itemsMinOrderByAggregateInput
    _sum?: itemsSumOrderByAggregateInput
  }

  export type itemsScalarWhereWithAggregatesInput = {
    AND?: itemsScalarWhereWithAggregatesInput | itemsScalarWhereWithAggregatesInput[]
    OR?: itemsScalarWhereWithAggregatesInput[]
    NOT?: itemsScalarWhereWithAggregatesInput | itemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"items"> | number
    items_name?: StringWithAggregatesFilter<"items"> | string
    categoryId?: IntWithAggregatesFilter<"items"> | number
    description?: StringWithAggregatesFilter<"items"> | string
    brandsId?: IntWithAggregatesFilter<"items"> | number
    unitsId?: IntWithAggregatesFilter<"items"> | number
    createdAt?: DateTimeWithAggregatesFilter<"items"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"items"> | Date | string
  }

  export type supplierWhereInput = {
    AND?: supplierWhereInput | supplierWhereInput[]
    OR?: supplierWhereInput[]
    NOT?: supplierWhereInput | supplierWhereInput[]
    id?: IntFilter<"supplier"> | number
    supplier_name?: StringFilter<"supplier"> | string
    contact_person?: StringFilter<"supplier"> | string
    mobile_number?: StringFilter<"supplier"> | string
    address?: StringFilter<"supplier"> | string
    createdAt?: DateTimeFilter<"supplier"> | Date | string
    updatedAt?: DateTimeFilter<"supplier"> | Date | string
    purchaseitems?: PurchaseitemsListRelationFilter
    Purchase?: PurchaseListRelationFilter
    purchasesuppliertrack?: PurchasesuppliertrackListRelationFilter
    transaction?: TransactionListRelationFilter
    supplierledger?: SupplierledgerListRelationFilter
  }

  export type supplierOrderByWithRelationInput = {
    id?: SortOrder
    supplier_name?: SortOrder
    contact_person?: SortOrder
    mobile_number?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseitems?: purchaseitemsOrderByRelationAggregateInput
    Purchase?: purchaseOrderByRelationAggregateInput
    purchasesuppliertrack?: purchasesuppliertrackOrderByRelationAggregateInput
    transaction?: transactionOrderByRelationAggregateInput
    supplierledger?: supplierledgerOrderByRelationAggregateInput
  }

  export type supplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: supplierWhereInput | supplierWhereInput[]
    OR?: supplierWhereInput[]
    NOT?: supplierWhereInput | supplierWhereInput[]
    supplier_name?: StringFilter<"supplier"> | string
    contact_person?: StringFilter<"supplier"> | string
    mobile_number?: StringFilter<"supplier"> | string
    address?: StringFilter<"supplier"> | string
    createdAt?: DateTimeFilter<"supplier"> | Date | string
    updatedAt?: DateTimeFilter<"supplier"> | Date | string
    purchaseitems?: PurchaseitemsListRelationFilter
    Purchase?: PurchaseListRelationFilter
    purchasesuppliertrack?: PurchasesuppliertrackListRelationFilter
    transaction?: TransactionListRelationFilter
    supplierledger?: SupplierledgerListRelationFilter
  }, "id">

  export type supplierOrderByWithAggregationInput = {
    id?: SortOrder
    supplier_name?: SortOrder
    contact_person?: SortOrder
    mobile_number?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: supplierCountOrderByAggregateInput
    _avg?: supplierAvgOrderByAggregateInput
    _max?: supplierMaxOrderByAggregateInput
    _min?: supplierMinOrderByAggregateInput
    _sum?: supplierSumOrderByAggregateInput
  }

  export type supplierScalarWhereWithAggregatesInput = {
    AND?: supplierScalarWhereWithAggregatesInput | supplierScalarWhereWithAggregatesInput[]
    OR?: supplierScalarWhereWithAggregatesInput[]
    NOT?: supplierScalarWhereWithAggregatesInput | supplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"supplier"> | number
    supplier_name?: StringWithAggregatesFilter<"supplier"> | string
    contact_person?: StringWithAggregatesFilter<"supplier"> | string
    mobile_number?: StringWithAggregatesFilter<"supplier"> | string
    address?: StringWithAggregatesFilter<"supplier"> | string
    createdAt?: DateTimeWithAggregatesFilter<"supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"supplier"> | Date | string
  }

  export type purchaseitemsWhereInput = {
    AND?: purchaseitemsWhereInput | purchaseitemsWhereInput[]
    OR?: purchaseitemsWhereInput[]
    NOT?: purchaseitemsWhereInput | purchaseitemsWhereInput[]
    id?: IntFilter<"purchaseitems"> | number
    itemId?: IntFilter<"purchaseitems"> | number
    supplierId?: IntFilter<"purchaseitems"> | number
    purchase_qty?: FloatFilter<"purchaseitems"> | number
    price_per_unit?: FloatFilter<"purchaseitems"> | number
    price_avg?: FloatFilter<"purchaseitems"> | number
    purchase_total?: FloatFilter<"purchaseitems"> | number
    subtotal_amount?: FloatFilter<"purchaseitems"> | number
    purchase_update_qty?: FloatFilter<"purchaseitems"> | number
    tax_Id?: IntFilter<"purchaseitems"> | number
    createdAt?: DateTimeFilter<"purchaseitems"> | Date | string
    updatedAt?: DateTimeFilter<"purchaseitems"> | Date | string
    purchaseitems_items?: XOR<ItemsRelationFilter, itemsWhereInput>
    purchaseitemsId?: XOR<SupplierRelationFilter, supplierWhereInput>
  }

  export type purchaseitemsOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    price_avg?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    purchase_update_qty?: SortOrder
    tax_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseitems_items?: itemsOrderByWithRelationInput
    purchaseitemsId?: supplierOrderByWithRelationInput
  }

  export type purchaseitemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: purchaseitemsWhereInput | purchaseitemsWhereInput[]
    OR?: purchaseitemsWhereInput[]
    NOT?: purchaseitemsWhereInput | purchaseitemsWhereInput[]
    itemId?: IntFilter<"purchaseitems"> | number
    supplierId?: IntFilter<"purchaseitems"> | number
    purchase_qty?: FloatFilter<"purchaseitems"> | number
    price_per_unit?: FloatFilter<"purchaseitems"> | number
    price_avg?: FloatFilter<"purchaseitems"> | number
    purchase_total?: FloatFilter<"purchaseitems"> | number
    subtotal_amount?: FloatFilter<"purchaseitems"> | number
    purchase_update_qty?: FloatFilter<"purchaseitems"> | number
    tax_Id?: IntFilter<"purchaseitems"> | number
    createdAt?: DateTimeFilter<"purchaseitems"> | Date | string
    updatedAt?: DateTimeFilter<"purchaseitems"> | Date | string
    purchaseitems_items?: XOR<ItemsRelationFilter, itemsWhereInput>
    purchaseitemsId?: XOR<SupplierRelationFilter, supplierWhereInput>
  }, "id">

  export type purchaseitemsOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    price_avg?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    purchase_update_qty?: SortOrder
    tax_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: purchaseitemsCountOrderByAggregateInput
    _avg?: purchaseitemsAvgOrderByAggregateInput
    _max?: purchaseitemsMaxOrderByAggregateInput
    _min?: purchaseitemsMinOrderByAggregateInput
    _sum?: purchaseitemsSumOrderByAggregateInput
  }

  export type purchaseitemsScalarWhereWithAggregatesInput = {
    AND?: purchaseitemsScalarWhereWithAggregatesInput | purchaseitemsScalarWhereWithAggregatesInput[]
    OR?: purchaseitemsScalarWhereWithAggregatesInput[]
    NOT?: purchaseitemsScalarWhereWithAggregatesInput | purchaseitemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"purchaseitems"> | number
    itemId?: IntWithAggregatesFilter<"purchaseitems"> | number
    supplierId?: IntWithAggregatesFilter<"purchaseitems"> | number
    purchase_qty?: FloatWithAggregatesFilter<"purchaseitems"> | number
    price_per_unit?: FloatWithAggregatesFilter<"purchaseitems"> | number
    price_avg?: FloatWithAggregatesFilter<"purchaseitems"> | number
    purchase_total?: FloatWithAggregatesFilter<"purchaseitems"> | number
    subtotal_amount?: FloatWithAggregatesFilter<"purchaseitems"> | number
    purchase_update_qty?: FloatWithAggregatesFilter<"purchaseitems"> | number
    tax_Id?: IntWithAggregatesFilter<"purchaseitems"> | number
    createdAt?: DateTimeWithAggregatesFilter<"purchaseitems"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"purchaseitems"> | Date | string
  }

  export type purchaseWhereInput = {
    AND?: purchaseWhereInput | purchaseWhereInput[]
    OR?: purchaseWhereInput[]
    NOT?: purchaseWhereInput | purchaseWhereInput[]
    id?: IntFilter<"purchase"> | number
    itemId?: IntFilter<"purchase"> | number
    supplierId?: IntFilter<"purchase"> | number
    purchase_qty?: FloatFilter<"purchase"> | number
    price_per_unit?: FloatFilter<"purchase"> | number
    purchase_total?: FloatFilter<"purchase"> | number
    subtotal_amount?: FloatFilter<"purchase"> | number
    tax_Id?: IntFilter<"purchase"> | number
    createdAt?: DateTimeFilter<"purchase"> | Date | string
    updatedAt?: DateTimeFilter<"purchase"> | Date | string
    purchase_items?: XOR<ItemsRelationFilter, itemsWhereInput>
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
  }

  export type purchaseOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    tax_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchase_items?: itemsOrderByWithRelationInput
    supplier?: supplierOrderByWithRelationInput
  }

  export type purchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: purchaseWhereInput | purchaseWhereInput[]
    OR?: purchaseWhereInput[]
    NOT?: purchaseWhereInput | purchaseWhereInput[]
    itemId?: IntFilter<"purchase"> | number
    supplierId?: IntFilter<"purchase"> | number
    purchase_qty?: FloatFilter<"purchase"> | number
    price_per_unit?: FloatFilter<"purchase"> | number
    purchase_total?: FloatFilter<"purchase"> | number
    subtotal_amount?: FloatFilter<"purchase"> | number
    tax_Id?: IntFilter<"purchase"> | number
    createdAt?: DateTimeFilter<"purchase"> | Date | string
    updatedAt?: DateTimeFilter<"purchase"> | Date | string
    purchase_items?: XOR<ItemsRelationFilter, itemsWhereInput>
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
  }, "id">

  export type purchaseOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    tax_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: purchaseCountOrderByAggregateInput
    _avg?: purchaseAvgOrderByAggregateInput
    _max?: purchaseMaxOrderByAggregateInput
    _min?: purchaseMinOrderByAggregateInput
    _sum?: purchaseSumOrderByAggregateInput
  }

  export type purchaseScalarWhereWithAggregatesInput = {
    AND?: purchaseScalarWhereWithAggregatesInput | purchaseScalarWhereWithAggregatesInput[]
    OR?: purchaseScalarWhereWithAggregatesInput[]
    NOT?: purchaseScalarWhereWithAggregatesInput | purchaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"purchase"> | number
    itemId?: IntWithAggregatesFilter<"purchase"> | number
    supplierId?: IntWithAggregatesFilter<"purchase"> | number
    purchase_qty?: FloatWithAggregatesFilter<"purchase"> | number
    price_per_unit?: FloatWithAggregatesFilter<"purchase"> | number
    purchase_total?: FloatWithAggregatesFilter<"purchase"> | number
    subtotal_amount?: FloatWithAggregatesFilter<"purchase"> | number
    tax_Id?: IntWithAggregatesFilter<"purchase"> | number
    createdAt?: DateTimeWithAggregatesFilter<"purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"purchase"> | Date | string
  }

  export type salesWhereInput = {
    AND?: salesWhereInput | salesWhereInput[]
    OR?: salesWhereInput[]
    NOT?: salesWhereInput | salesWhereInput[]
    id?: IntFilter<"sales"> | number
    itemId?: IntFilter<"sales"> | number
    customerId?: IntFilter<"sales"> | number
    sale_qty?: FloatFilter<"sales"> | number
    sales_price?: FloatFilter<"sales"> | number
    discount?: FloatFilter<"sales"> | number
    transport_cost?: FloatFilter<"sales"> | number
    createdAt?: DateTimeFilter<"sales"> | Date | string
    updatedAt?: DateTimeFilter<"sales"> | Date | string
    items?: XOR<ItemsRelationFilter, itemsWhereInput>
    customer?: XOR<CustomerRelationFilter, customerWhereInput>
  }

  export type salesOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    customerId?: SortOrder
    sale_qty?: SortOrder
    sales_price?: SortOrder
    discount?: SortOrder
    transport_cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: itemsOrderByWithRelationInput
    customer?: customerOrderByWithRelationInput
  }

  export type salesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: salesWhereInput | salesWhereInput[]
    OR?: salesWhereInput[]
    NOT?: salesWhereInput | salesWhereInput[]
    itemId?: IntFilter<"sales"> | number
    customerId?: IntFilter<"sales"> | number
    sale_qty?: FloatFilter<"sales"> | number
    sales_price?: FloatFilter<"sales"> | number
    discount?: FloatFilter<"sales"> | number
    transport_cost?: FloatFilter<"sales"> | number
    createdAt?: DateTimeFilter<"sales"> | Date | string
    updatedAt?: DateTimeFilter<"sales"> | Date | string
    items?: XOR<ItemsRelationFilter, itemsWhereInput>
    customer?: XOR<CustomerRelationFilter, customerWhereInput>
  }, "id">

  export type salesOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    customerId?: SortOrder
    sale_qty?: SortOrder
    sales_price?: SortOrder
    discount?: SortOrder
    transport_cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: salesCountOrderByAggregateInput
    _avg?: salesAvgOrderByAggregateInput
    _max?: salesMaxOrderByAggregateInput
    _min?: salesMinOrderByAggregateInput
    _sum?: salesSumOrderByAggregateInput
  }

  export type salesScalarWhereWithAggregatesInput = {
    AND?: salesScalarWhereWithAggregatesInput | salesScalarWhereWithAggregatesInput[]
    OR?: salesScalarWhereWithAggregatesInput[]
    NOT?: salesScalarWhereWithAggregatesInput | salesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sales"> | number
    itemId?: IntWithAggregatesFilter<"sales"> | number
    customerId?: IntWithAggregatesFilter<"sales"> | number
    sale_qty?: FloatWithAggregatesFilter<"sales"> | number
    sales_price?: FloatWithAggregatesFilter<"sales"> | number
    discount?: FloatWithAggregatesFilter<"sales"> | number
    transport_cost?: FloatWithAggregatesFilter<"sales"> | number
    createdAt?: DateTimeWithAggregatesFilter<"sales"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"sales"> | Date | string
  }

  export type customertypeWhereInput = {
    AND?: customertypeWhereInput | customertypeWhereInput[]
    OR?: customertypeWhereInput[]
    NOT?: customertypeWhereInput | customertypeWhereInput[]
    id?: IntFilter<"customertype"> | number
    type_name?: StringFilter<"customertype"> | string
    createdAt?: DateTimeFilter<"customertype"> | Date | string
    updatedAt?: DateTimeFilter<"customertype"> | Date | string
    customer?: CustomerListRelationFilter
    customerpayment?: CustomerpaymentListRelationFilter
  }

  export type customertypeOrderByWithRelationInput = {
    id?: SortOrder
    type_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: customerOrderByRelationAggregateInput
    customerpayment?: customerpaymentOrderByRelationAggregateInput
  }

  export type customertypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: customertypeWhereInput | customertypeWhereInput[]
    OR?: customertypeWhereInput[]
    NOT?: customertypeWhereInput | customertypeWhereInput[]
    type_name?: StringFilter<"customertype"> | string
    createdAt?: DateTimeFilter<"customertype"> | Date | string
    updatedAt?: DateTimeFilter<"customertype"> | Date | string
    customer?: CustomerListRelationFilter
    customerpayment?: CustomerpaymentListRelationFilter
  }, "id">

  export type customertypeOrderByWithAggregationInput = {
    id?: SortOrder
    type_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: customertypeCountOrderByAggregateInput
    _avg?: customertypeAvgOrderByAggregateInput
    _max?: customertypeMaxOrderByAggregateInput
    _min?: customertypeMinOrderByAggregateInput
    _sum?: customertypeSumOrderByAggregateInput
  }

  export type customertypeScalarWhereWithAggregatesInput = {
    AND?: customertypeScalarWhereWithAggregatesInput | customertypeScalarWhereWithAggregatesInput[]
    OR?: customertypeScalarWhereWithAggregatesInput[]
    NOT?: customertypeScalarWhereWithAggregatesInput | customertypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customertype"> | number
    type_name?: StringWithAggregatesFilter<"customertype"> | string
    createdAt?: DateTimeWithAggregatesFilter<"customertype"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"customertype"> | Date | string
  }

  export type customerWhereInput = {
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    id?: IntFilter<"customer"> | number
    customer_name?: StringFilter<"customer"> | string
    customertypeId?: IntFilter<"customer"> | number
    createdAt?: DateTimeFilter<"customer"> | Date | string
    updatedAt?: DateTimeFilter<"customer"> | Date | string
    customerId?: XOR<CustomertypeRelationFilter, customertypeWhereInput>
    customerdetails?: CustomerdetailsListRelationFilter
    sales?: SalesListRelationFilter
    salescustomertracker?: SalescustomertrackerListRelationFilter
    customerledger?: CustomerledgerListRelationFilter
    customerpayment?: CustomerpaymentListRelationFilter
  }

  export type customerOrderByWithRelationInput = {
    id?: SortOrder
    customer_name?: SortOrder
    customertypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: customertypeOrderByWithRelationInput
    customerdetails?: customerdetailsOrderByRelationAggregateInput
    sales?: salesOrderByRelationAggregateInput
    salescustomertracker?: salescustomertrackerOrderByRelationAggregateInput
    customerledger?: customerledgerOrderByRelationAggregateInput
    customerpayment?: customerpaymentOrderByRelationAggregateInput
  }

  export type customerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    customer_name?: StringFilter<"customer"> | string
    customertypeId?: IntFilter<"customer"> | number
    createdAt?: DateTimeFilter<"customer"> | Date | string
    updatedAt?: DateTimeFilter<"customer"> | Date | string
    customerId?: XOR<CustomertypeRelationFilter, customertypeWhereInput>
    customerdetails?: CustomerdetailsListRelationFilter
    sales?: SalesListRelationFilter
    salescustomertracker?: SalescustomertrackerListRelationFilter
    customerledger?: CustomerledgerListRelationFilter
    customerpayment?: CustomerpaymentListRelationFilter
  }, "id">

  export type customerOrderByWithAggregationInput = {
    id?: SortOrder
    customer_name?: SortOrder
    customertypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: customerCountOrderByAggregateInput
    _avg?: customerAvgOrderByAggregateInput
    _max?: customerMaxOrderByAggregateInput
    _min?: customerMinOrderByAggregateInput
    _sum?: customerSumOrderByAggregateInput
  }

  export type customerScalarWhereWithAggregatesInput = {
    AND?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    OR?: customerScalarWhereWithAggregatesInput[]
    NOT?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customer"> | number
    customer_name?: StringWithAggregatesFilter<"customer"> | string
    customertypeId?: IntWithAggregatesFilter<"customer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"customer"> | Date | string
  }

  export type salescustomertrackerWhereInput = {
    AND?: salescustomertrackerWhereInput | salescustomertrackerWhereInput[]
    OR?: salescustomertrackerWhereInput[]
    NOT?: salescustomertrackerWhereInput | salescustomertrackerWhereInput[]
    id?: IntFilter<"salescustomertracker"> | number
    customerId?: IntFilter<"salescustomertracker"> | number
    curr_balance?: FloatFilter<"salescustomertracker"> | number
    payment_type?: StringFilter<"salescustomertracker"> | string
    createdAt?: DateTimeFilter<"salescustomertracker"> | Date | string
    updatedAt?: DateTimeFilter<"salescustomertracker"> | Date | string
    customer?: XOR<CustomerRelationFilter, customerWhereInput>
  }

  export type salescustomertrackerOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    curr_balance?: SortOrder
    payment_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: customerOrderByWithRelationInput
  }

  export type salescustomertrackerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: salescustomertrackerWhereInput | salescustomertrackerWhereInput[]
    OR?: salescustomertrackerWhereInput[]
    NOT?: salescustomertrackerWhereInput | salescustomertrackerWhereInput[]
    customerId?: IntFilter<"salescustomertracker"> | number
    curr_balance?: FloatFilter<"salescustomertracker"> | number
    payment_type?: StringFilter<"salescustomertracker"> | string
    createdAt?: DateTimeFilter<"salescustomertracker"> | Date | string
    updatedAt?: DateTimeFilter<"salescustomertracker"> | Date | string
    customer?: XOR<CustomerRelationFilter, customerWhereInput>
  }, "id">

  export type salescustomertrackerOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    curr_balance?: SortOrder
    payment_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: salescustomertrackerCountOrderByAggregateInput
    _avg?: salescustomertrackerAvgOrderByAggregateInput
    _max?: salescustomertrackerMaxOrderByAggregateInput
    _min?: salescustomertrackerMinOrderByAggregateInput
    _sum?: salescustomertrackerSumOrderByAggregateInput
  }

  export type salescustomertrackerScalarWhereWithAggregatesInput = {
    AND?: salescustomertrackerScalarWhereWithAggregatesInput | salescustomertrackerScalarWhereWithAggregatesInput[]
    OR?: salescustomertrackerScalarWhereWithAggregatesInput[]
    NOT?: salescustomertrackerScalarWhereWithAggregatesInput | salescustomertrackerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"salescustomertracker"> | number
    customerId?: IntWithAggregatesFilter<"salescustomertracker"> | number
    curr_balance?: FloatWithAggregatesFilter<"salescustomertracker"> | number
    payment_type?: StringWithAggregatesFilter<"salescustomertracker"> | string
    createdAt?: DateTimeWithAggregatesFilter<"salescustomertracker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"salescustomertracker"> | Date | string
  }

  export type customerpaymentWhereInput = {
    AND?: customerpaymentWhereInput | customerpaymentWhereInput[]
    OR?: customerpaymentWhereInput[]
    NOT?: customerpaymentWhereInput | customerpaymentWhereInput[]
    id?: IntFilter<"customerpayment"> | number
    customertypeId?: IntFilter<"customerpayment"> | number
    customerId?: IntFilter<"customerpayment"> | number
    balance?: FloatFilter<"customerpayment"> | number
    transaction_type?: StringFilter<"customerpayment"> | string
    collection_method?: StringFilter<"customerpayment"> | string
    paid?: FloatFilter<"customerpayment"> | number
    remission?: FloatFilter<"customerpayment"> | number
    curr_balance?: FloatFilter<"customerpayment"> | number
    createdAt?: DateTimeFilter<"customerpayment"> | Date | string
    updatedAt?: DateTimeFilter<"customerpayment"> | Date | string
    customertype?: XOR<CustomertypeRelationFilter, customertypeWhereInput>
    customer?: XOR<CustomerRelationFilter, customerWhereInput>
  }

  export type customerpaymentOrderByWithRelationInput = {
    id?: SortOrder
    customertypeId?: SortOrder
    customerId?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    collection_method?: SortOrder
    paid?: SortOrder
    remission?: SortOrder
    curr_balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customertype?: customertypeOrderByWithRelationInput
    customer?: customerOrderByWithRelationInput
  }

  export type customerpaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: customerpaymentWhereInput | customerpaymentWhereInput[]
    OR?: customerpaymentWhereInput[]
    NOT?: customerpaymentWhereInput | customerpaymentWhereInput[]
    customertypeId?: IntFilter<"customerpayment"> | number
    customerId?: IntFilter<"customerpayment"> | number
    balance?: FloatFilter<"customerpayment"> | number
    transaction_type?: StringFilter<"customerpayment"> | string
    collection_method?: StringFilter<"customerpayment"> | string
    paid?: FloatFilter<"customerpayment"> | number
    remission?: FloatFilter<"customerpayment"> | number
    curr_balance?: FloatFilter<"customerpayment"> | number
    createdAt?: DateTimeFilter<"customerpayment"> | Date | string
    updatedAt?: DateTimeFilter<"customerpayment"> | Date | string
    customertype?: XOR<CustomertypeRelationFilter, customertypeWhereInput>
    customer?: XOR<CustomerRelationFilter, customerWhereInput>
  }, "id">

  export type customerpaymentOrderByWithAggregationInput = {
    id?: SortOrder
    customertypeId?: SortOrder
    customerId?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    collection_method?: SortOrder
    paid?: SortOrder
    remission?: SortOrder
    curr_balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: customerpaymentCountOrderByAggregateInput
    _avg?: customerpaymentAvgOrderByAggregateInput
    _max?: customerpaymentMaxOrderByAggregateInput
    _min?: customerpaymentMinOrderByAggregateInput
    _sum?: customerpaymentSumOrderByAggregateInput
  }

  export type customerpaymentScalarWhereWithAggregatesInput = {
    AND?: customerpaymentScalarWhereWithAggregatesInput | customerpaymentScalarWhereWithAggregatesInput[]
    OR?: customerpaymentScalarWhereWithAggregatesInput[]
    NOT?: customerpaymentScalarWhereWithAggregatesInput | customerpaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customerpayment"> | number
    customertypeId?: IntWithAggregatesFilter<"customerpayment"> | number
    customerId?: IntWithAggregatesFilter<"customerpayment"> | number
    balance?: FloatWithAggregatesFilter<"customerpayment"> | number
    transaction_type?: StringWithAggregatesFilter<"customerpayment"> | string
    collection_method?: StringWithAggregatesFilter<"customerpayment"> | string
    paid?: FloatWithAggregatesFilter<"customerpayment"> | number
    remission?: FloatWithAggregatesFilter<"customerpayment"> | number
    curr_balance?: FloatWithAggregatesFilter<"customerpayment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"customerpayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"customerpayment"> | Date | string
  }

  export type customerledgerWhereInput = {
    AND?: customerledgerWhereInput | customerledgerWhereInput[]
    OR?: customerledgerWhereInput[]
    NOT?: customerledgerWhereInput | customerledgerWhereInput[]
    id?: IntFilter<"customerledger"> | number
    customerId?: IntFilter<"customerledger"> | number
    payment_type?: StringFilter<"customerledger"> | string
    credit?: FloatFilter<"customerledger"> | number
    debit?: FloatFilter<"customerledger"> | number
    balance?: FloatFilter<"customerledger"> | number
    voucher_no?: StringFilter<"customerledger"> | string
    createdAt?: DateTimeFilter<"customerledger"> | Date | string
    updatedAt?: DateTimeFilter<"customerledger"> | Date | string
    customer?: XOR<CustomerRelationFilter, customerWhereInput>
  }

  export type customerledgerOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    payment_type?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
    voucher_no?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: customerOrderByWithRelationInput
  }

  export type customerledgerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: customerledgerWhereInput | customerledgerWhereInput[]
    OR?: customerledgerWhereInput[]
    NOT?: customerledgerWhereInput | customerledgerWhereInput[]
    customerId?: IntFilter<"customerledger"> | number
    payment_type?: StringFilter<"customerledger"> | string
    credit?: FloatFilter<"customerledger"> | number
    debit?: FloatFilter<"customerledger"> | number
    balance?: FloatFilter<"customerledger"> | number
    voucher_no?: StringFilter<"customerledger"> | string
    createdAt?: DateTimeFilter<"customerledger"> | Date | string
    updatedAt?: DateTimeFilter<"customerledger"> | Date | string
    customer?: XOR<CustomerRelationFilter, customerWhereInput>
  }, "id">

  export type customerledgerOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    payment_type?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
    voucher_no?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: customerledgerCountOrderByAggregateInput
    _avg?: customerledgerAvgOrderByAggregateInput
    _max?: customerledgerMaxOrderByAggregateInput
    _min?: customerledgerMinOrderByAggregateInput
    _sum?: customerledgerSumOrderByAggregateInput
  }

  export type customerledgerScalarWhereWithAggregatesInput = {
    AND?: customerledgerScalarWhereWithAggregatesInput | customerledgerScalarWhereWithAggregatesInput[]
    OR?: customerledgerScalarWhereWithAggregatesInput[]
    NOT?: customerledgerScalarWhereWithAggregatesInput | customerledgerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customerledger"> | number
    customerId?: IntWithAggregatesFilter<"customerledger"> | number
    payment_type?: StringWithAggregatesFilter<"customerledger"> | string
    credit?: FloatWithAggregatesFilter<"customerledger"> | number
    debit?: FloatWithAggregatesFilter<"customerledger"> | number
    balance?: FloatWithAggregatesFilter<"customerledger"> | number
    voucher_no?: StringWithAggregatesFilter<"customerledger"> | string
    createdAt?: DateTimeWithAggregatesFilter<"customerledger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"customerledger"> | Date | string
  }

  export type purchasesuppliertrackWhereInput = {
    AND?: purchasesuppliertrackWhereInput | purchasesuppliertrackWhereInput[]
    OR?: purchasesuppliertrackWhereInput[]
    NOT?: purchasesuppliertrackWhereInput | purchasesuppliertrackWhereInput[]
    id?: IntFilter<"purchasesuppliertrack"> | number
    supplierId?: IntFilter<"purchasesuppliertrack"> | number
    curr_balance?: FloatFilter<"purchasesuppliertrack"> | number
    payment_type?: StringFilter<"purchasesuppliertrack"> | string
    createdAt?: DateTimeFilter<"purchasesuppliertrack"> | Date | string
    updatedAt?: DateTimeFilter<"purchasesuppliertrack"> | Date | string
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
  }

  export type purchasesuppliertrackOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    curr_balance?: SortOrder
    payment_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: supplierOrderByWithRelationInput
  }

  export type purchasesuppliertrackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: purchasesuppliertrackWhereInput | purchasesuppliertrackWhereInput[]
    OR?: purchasesuppliertrackWhereInput[]
    NOT?: purchasesuppliertrackWhereInput | purchasesuppliertrackWhereInput[]
    supplierId?: IntFilter<"purchasesuppliertrack"> | number
    curr_balance?: FloatFilter<"purchasesuppliertrack"> | number
    payment_type?: StringFilter<"purchasesuppliertrack"> | string
    createdAt?: DateTimeFilter<"purchasesuppliertrack"> | Date | string
    updatedAt?: DateTimeFilter<"purchasesuppliertrack"> | Date | string
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
  }, "id">

  export type purchasesuppliertrackOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    curr_balance?: SortOrder
    payment_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: purchasesuppliertrackCountOrderByAggregateInput
    _avg?: purchasesuppliertrackAvgOrderByAggregateInput
    _max?: purchasesuppliertrackMaxOrderByAggregateInput
    _min?: purchasesuppliertrackMinOrderByAggregateInput
    _sum?: purchasesuppliertrackSumOrderByAggregateInput
  }

  export type purchasesuppliertrackScalarWhereWithAggregatesInput = {
    AND?: purchasesuppliertrackScalarWhereWithAggregatesInput | purchasesuppliertrackScalarWhereWithAggregatesInput[]
    OR?: purchasesuppliertrackScalarWhereWithAggregatesInput[]
    NOT?: purchasesuppliertrackScalarWhereWithAggregatesInput | purchasesuppliertrackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"purchasesuppliertrack"> | number
    supplierId?: IntWithAggregatesFilter<"purchasesuppliertrack"> | number
    curr_balance?: FloatWithAggregatesFilter<"purchasesuppliertrack"> | number
    payment_type?: StringWithAggregatesFilter<"purchasesuppliertrack"> | string
    createdAt?: DateTimeWithAggregatesFilter<"purchasesuppliertrack"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"purchasesuppliertrack"> | Date | string
  }

  export type transactionWhereInput = {
    AND?: transactionWhereInput | transactionWhereInput[]
    OR?: transactionWhereInput[]
    NOT?: transactionWhereInput | transactionWhereInput[]
    id?: IntFilter<"transaction"> | number
    supplierId?: IntFilter<"transaction"> | number
    balance?: FloatFilter<"transaction"> | number
    transaction_type?: StringFilter<"transaction"> | string
    transaction_method?: StringFilter<"transaction"> | string
    payment?: FloatFilter<"transaction"> | number
    curr_balance?: FloatFilter<"transaction"> | number
    createdAt?: DateTimeFilter<"transaction"> | Date | string
    updatedAt?: DateTimeFilter<"transaction"> | Date | string
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
  }

  export type transactionOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    transaction_method?: SortOrder
    payment?: SortOrder
    curr_balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: supplierOrderByWithRelationInput
  }

  export type transactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: transactionWhereInput | transactionWhereInput[]
    OR?: transactionWhereInput[]
    NOT?: transactionWhereInput | transactionWhereInput[]
    supplierId?: IntFilter<"transaction"> | number
    balance?: FloatFilter<"transaction"> | number
    transaction_type?: StringFilter<"transaction"> | string
    transaction_method?: StringFilter<"transaction"> | string
    payment?: FloatFilter<"transaction"> | number
    curr_balance?: FloatFilter<"transaction"> | number
    createdAt?: DateTimeFilter<"transaction"> | Date | string
    updatedAt?: DateTimeFilter<"transaction"> | Date | string
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
  }, "id">

  export type transactionOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    transaction_method?: SortOrder
    payment?: SortOrder
    curr_balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: transactionCountOrderByAggregateInput
    _avg?: transactionAvgOrderByAggregateInput
    _max?: transactionMaxOrderByAggregateInput
    _min?: transactionMinOrderByAggregateInput
    _sum?: transactionSumOrderByAggregateInput
  }

  export type transactionScalarWhereWithAggregatesInput = {
    AND?: transactionScalarWhereWithAggregatesInput | transactionScalarWhereWithAggregatesInput[]
    OR?: transactionScalarWhereWithAggregatesInput[]
    NOT?: transactionScalarWhereWithAggregatesInput | transactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"transaction"> | number
    supplierId?: IntWithAggregatesFilter<"transaction"> | number
    balance?: FloatWithAggregatesFilter<"transaction"> | number
    transaction_type?: StringWithAggregatesFilter<"transaction"> | string
    transaction_method?: StringWithAggregatesFilter<"transaction"> | string
    payment?: FloatWithAggregatesFilter<"transaction"> | number
    curr_balance?: FloatWithAggregatesFilter<"transaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"transaction"> | Date | string
  }

  export type supplierledgerWhereInput = {
    AND?: supplierledgerWhereInput | supplierledgerWhereInput[]
    OR?: supplierledgerWhereInput[]
    NOT?: supplierledgerWhereInput | supplierledgerWhereInput[]
    id?: IntFilter<"supplierledger"> | number
    supplierId?: IntFilter<"supplierledger"> | number
    payment_type?: StringFilter<"supplierledger"> | string
    voucher_no?: StringFilter<"supplierledger"> | string
    credit?: FloatFilter<"supplierledger"> | number
    debit?: FloatFilter<"supplierledger"> | number
    balance?: FloatFilter<"supplierledger"> | number
    createdAt?: DateTimeFilter<"supplierledger"> | Date | string
    updatedAt?: DateTimeFilter<"supplierledger"> | Date | string
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
  }

  export type supplierledgerOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    payment_type?: SortOrder
    voucher_no?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: supplierOrderByWithRelationInput
  }

  export type supplierledgerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: supplierledgerWhereInput | supplierledgerWhereInput[]
    OR?: supplierledgerWhereInput[]
    NOT?: supplierledgerWhereInput | supplierledgerWhereInput[]
    supplierId?: IntFilter<"supplierledger"> | number
    payment_type?: StringFilter<"supplierledger"> | string
    voucher_no?: StringFilter<"supplierledger"> | string
    credit?: FloatFilter<"supplierledger"> | number
    debit?: FloatFilter<"supplierledger"> | number
    balance?: FloatFilter<"supplierledger"> | number
    createdAt?: DateTimeFilter<"supplierledger"> | Date | string
    updatedAt?: DateTimeFilter<"supplierledger"> | Date | string
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
  }, "id">

  export type supplierledgerOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    payment_type?: SortOrder
    voucher_no?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: supplierledgerCountOrderByAggregateInput
    _avg?: supplierledgerAvgOrderByAggregateInput
    _max?: supplierledgerMaxOrderByAggregateInput
    _min?: supplierledgerMinOrderByAggregateInput
    _sum?: supplierledgerSumOrderByAggregateInput
  }

  export type supplierledgerScalarWhereWithAggregatesInput = {
    AND?: supplierledgerScalarWhereWithAggregatesInput | supplierledgerScalarWhereWithAggregatesInput[]
    OR?: supplierledgerScalarWhereWithAggregatesInput[]
    NOT?: supplierledgerScalarWhereWithAggregatesInput | supplierledgerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"supplierledger"> | number
    supplierId?: IntWithAggregatesFilter<"supplierledger"> | number
    payment_type?: StringWithAggregatesFilter<"supplierledger"> | string
    voucher_no?: StringWithAggregatesFilter<"supplierledger"> | string
    credit?: FloatWithAggregatesFilter<"supplierledger"> | number
    debit?: FloatWithAggregatesFilter<"supplierledger"> | number
    balance?: FloatWithAggregatesFilter<"supplierledger"> | number
    createdAt?: DateTimeWithAggregatesFilter<"supplierledger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"supplierledger"> | Date | string
  }

  export type customerdetailsWhereInput = {
    AND?: customerdetailsWhereInput | customerdetailsWhereInput[]
    OR?: customerdetailsWhereInput[]
    NOT?: customerdetailsWhereInput | customerdetailsWhereInput[]
    id?: IntFilter<"customerdetails"> | number
    customerId?: IntFilter<"customerdetails"> | number
    customer_name?: StringFilter<"customerdetails"> | string
    mob_no?: StringFilter<"customerdetails"> | string
    address?: StringFilter<"customerdetails"> | string
    description?: StringFilter<"customerdetails"> | string
    createdAt?: DateTimeFilter<"customerdetails"> | Date | string
    updatedAt?: DateTimeFilter<"customerdetails"> | Date | string
    customer?: XOR<CustomerRelationFilter, customerWhereInput>
  }

  export type customerdetailsOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    customer_name?: SortOrder
    mob_no?: SortOrder
    address?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: customerOrderByWithRelationInput
  }

  export type customerdetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: customerdetailsWhereInput | customerdetailsWhereInput[]
    OR?: customerdetailsWhereInput[]
    NOT?: customerdetailsWhereInput | customerdetailsWhereInput[]
    customerId?: IntFilter<"customerdetails"> | number
    customer_name?: StringFilter<"customerdetails"> | string
    mob_no?: StringFilter<"customerdetails"> | string
    address?: StringFilter<"customerdetails"> | string
    description?: StringFilter<"customerdetails"> | string
    createdAt?: DateTimeFilter<"customerdetails"> | Date | string
    updatedAt?: DateTimeFilter<"customerdetails"> | Date | string
    customer?: XOR<CustomerRelationFilter, customerWhereInput>
  }, "id">

  export type customerdetailsOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    customer_name?: SortOrder
    mob_no?: SortOrder
    address?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: customerdetailsCountOrderByAggregateInput
    _avg?: customerdetailsAvgOrderByAggregateInput
    _max?: customerdetailsMaxOrderByAggregateInput
    _min?: customerdetailsMinOrderByAggregateInput
    _sum?: customerdetailsSumOrderByAggregateInput
  }

  export type customerdetailsScalarWhereWithAggregatesInput = {
    AND?: customerdetailsScalarWhereWithAggregatesInput | customerdetailsScalarWhereWithAggregatesInput[]
    OR?: customerdetailsScalarWhereWithAggregatesInput[]
    NOT?: customerdetailsScalarWhereWithAggregatesInput | customerdetailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customerdetails"> | number
    customerId?: IntWithAggregatesFilter<"customerdetails"> | number
    customer_name?: StringWithAggregatesFilter<"customerdetails"> | string
    mob_no?: StringWithAggregatesFilter<"customerdetails"> | string
    address?: StringWithAggregatesFilter<"customerdetails"> | string
    description?: StringWithAggregatesFilter<"customerdetails"> | string
    createdAt?: DateTimeWithAggregatesFilter<"customerdetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"customerdetails"> | Date | string
  }

  export type userCreateInput = {
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateManyInput = {
    id?: number
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoryCreateInput = {
    category_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: itemsCreateNestedManyWithoutItems_categoryInput
  }

  export type categoryUncheckedCreateInput = {
    id?: number
    category_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: itemsUncheckedCreateNestedManyWithoutItems_categoryInput
  }

  export type categoryUpdateInput = {
    category_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: itemsUpdateManyWithoutItems_categoryNestedInput
  }

  export type categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: itemsUncheckedUpdateManyWithoutItems_categoryNestedInput
  }

  export type categoryCreateManyInput = {
    id?: number
    category_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type categoryUpdateManyMutationInput = {
    category_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unitsCreateInput = {
    units_name: string
    units_label: string
    relation: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: itemsCreateNestedManyWithoutItems_unitsInput
  }

  export type unitsUncheckedCreateInput = {
    id?: number
    units_name: string
    units_label: string
    relation: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: itemsUncheckedCreateNestedManyWithoutItems_unitsInput
  }

  export type unitsUpdateInput = {
    units_name?: StringFieldUpdateOperationsInput | string
    units_label?: StringFieldUpdateOperationsInput | string
    relation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: itemsUpdateManyWithoutItems_unitsNestedInput
  }

  export type unitsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    units_name?: StringFieldUpdateOperationsInput | string
    units_label?: StringFieldUpdateOperationsInput | string
    relation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: itemsUncheckedUpdateManyWithoutItems_unitsNestedInput
  }

  export type unitsCreateManyInput = {
    id?: number
    units_name: string
    units_label: string
    relation: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type unitsUpdateManyMutationInput = {
    units_name?: StringFieldUpdateOperationsInput | string
    units_label?: StringFieldUpdateOperationsInput | string
    relation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unitsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    units_name?: StringFieldUpdateOperationsInput | string
    units_label?: StringFieldUpdateOperationsInput | string
    relation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandsCreateInput = {
    brands_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: itemsCreateNestedManyWithoutItems_brandsInput
  }

  export type brandsUncheckedCreateInput = {
    id?: number
    brands_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: itemsUncheckedCreateNestedManyWithoutItems_brandsInput
  }

  export type brandsUpdateInput = {
    brands_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: itemsUpdateManyWithoutItems_brandsNestedInput
  }

  export type brandsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brands_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: itemsUncheckedUpdateManyWithoutItems_brandsNestedInput
  }

  export type brandsCreateManyInput = {
    id?: number
    brands_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type brandsUpdateManyMutationInput = {
    brands_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brands_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemsCreateInput = {
    items_name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsCreateNestedManyWithoutPurchaseitems_itemsInput
    Purchase?: purchaseCreateNestedManyWithoutPurchase_itemsInput
    sales?: salesCreateNestedManyWithoutItemsInput
    items_category: categoryCreateNestedOneWithoutItemsInput
    items_brands: brandsCreateNestedOneWithoutItemsInput
    items_units: unitsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateInput = {
    id?: number
    items_name: string
    categoryId: number
    description: string
    brandsId: number
    unitsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitems_itemsInput
    Purchase?: purchaseUncheckedCreateNestedManyWithoutPurchase_itemsInput
    sales?: salesUncheckedCreateNestedManyWithoutItemsInput
  }

  export type itemsUpdateInput = {
    items_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUpdateManyWithoutPurchaseitems_itemsNestedInput
    Purchase?: purchaseUpdateManyWithoutPurchase_itemsNestedInput
    sales?: salesUpdateManyWithoutItemsNestedInput
    items_category?: categoryUpdateOneRequiredWithoutItemsNestedInput
    items_brands?: brandsUpdateOneRequiredWithoutItemsNestedInput
    items_units?: unitsUpdateOneRequiredWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    items_name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    brandsId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUncheckedUpdateManyWithoutPurchaseitems_itemsNestedInput
    Purchase?: purchaseUncheckedUpdateManyWithoutPurchase_itemsNestedInput
    sales?: salesUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type itemsCreateManyInput = {
    id?: number
    items_name: string
    categoryId: number
    description: string
    brandsId: number
    unitsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemsUpdateManyMutationInput = {
    items_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    items_name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    brandsId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplierCreateInput = {
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsCreateNestedManyWithoutPurchaseitemsIdInput
    Purchase?: purchaseCreateNestedManyWithoutSupplierInput
    purchasesuppliertrack?: purchasesuppliertrackCreateNestedManyWithoutSupplierInput
    transaction?: transactionCreateNestedManyWithoutSupplierInput
    supplierledger?: supplierledgerCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateInput = {
    id?: number
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitemsIdInput
    Purchase?: purchaseUncheckedCreateNestedManyWithoutSupplierInput
    purchasesuppliertrack?: purchasesuppliertrackUncheckedCreateNestedManyWithoutSupplierInput
    transaction?: transactionUncheckedCreateNestedManyWithoutSupplierInput
    supplierledger?: supplierledgerUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierUpdateInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUpdateManyWithoutPurchaseitemsIdNestedInput
    Purchase?: purchaseUpdateManyWithoutSupplierNestedInput
    purchasesuppliertrack?: purchasesuppliertrackUpdateManyWithoutSupplierNestedInput
    transaction?: transactionUpdateManyWithoutSupplierNestedInput
    supplierledger?: supplierledgerUpdateManyWithoutSupplierNestedInput
  }

  export type supplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUncheckedUpdateManyWithoutPurchaseitemsIdNestedInput
    Purchase?: purchaseUncheckedUpdateManyWithoutSupplierNestedInput
    purchasesuppliertrack?: purchasesuppliertrackUncheckedUpdateManyWithoutSupplierNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutSupplierNestedInput
    supplierledger?: supplierledgerUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type supplierCreateManyInput = {
    id?: number
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type supplierUpdateManyMutationInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseitemsCreateInput = {
    purchase_qty: number
    price_per_unit: number
    price_avg: number
    purchase_total: number
    subtotal_amount: number
    purchase_update_qty: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems_items: itemsCreateNestedOneWithoutPurchaseitemsInput
    purchaseitemsId: supplierCreateNestedOneWithoutPurchaseitemsInput
  }

  export type purchaseitemsUncheckedCreateInput = {
    id?: number
    itemId: number
    supplierId: number
    purchase_qty: number
    price_per_unit: number
    price_avg: number
    purchase_total: number
    subtotal_amount: number
    purchase_update_qty: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseitemsUpdateInput = {
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    price_avg?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    purchase_update_qty?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems_items?: itemsUpdateOneRequiredWithoutPurchaseitemsNestedInput
    purchaseitemsId?: supplierUpdateOneRequiredWithoutPurchaseitemsNestedInput
  }

  export type purchaseitemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    price_avg?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    purchase_update_qty?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseitemsCreateManyInput = {
    id?: number
    itemId: number
    supplierId: number
    purchase_qty: number
    price_per_unit: number
    price_avg: number
    purchase_total: number
    subtotal_amount: number
    purchase_update_qty: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseitemsUpdateManyMutationInput = {
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    price_avg?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    purchase_update_qty?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseitemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    price_avg?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    purchase_update_qty?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseCreateInput = {
    purchase_qty: number
    price_per_unit: number
    purchase_total: number
    subtotal_amount: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase_items: itemsCreateNestedOneWithoutPurchaseInput
    supplier: supplierCreateNestedOneWithoutPurchaseInput
  }

  export type purchaseUncheckedCreateInput = {
    id?: number
    itemId: number
    supplierId: number
    purchase_qty: number
    price_per_unit: number
    purchase_total: number
    subtotal_amount: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseUpdateInput = {
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_items?: itemsUpdateOneRequiredWithoutPurchaseNestedInput
    supplier?: supplierUpdateOneRequiredWithoutPurchaseNestedInput
  }

  export type purchaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseCreateManyInput = {
    id?: number
    itemId: number
    supplierId: number
    purchase_qty: number
    price_per_unit: number
    purchase_total: number
    subtotal_amount: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseUpdateManyMutationInput = {
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesCreateInput = {
    sale_qty: number
    sales_price: number
    discount: number
    transport_cost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items: itemsCreateNestedOneWithoutSalesInput
    customer: customerCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateInput = {
    id?: number
    itemId: number
    customerId: number
    sale_qty: number
    sales_price: number
    discount: number
    transport_cost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesUpdateInput = {
    sale_qty?: FloatFieldUpdateOperationsInput | number
    sales_price?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    transport_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: itemsUpdateOneRequiredWithoutSalesNestedInput
    customer?: customerUpdateOneRequiredWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    sale_qty?: FloatFieldUpdateOperationsInput | number
    sales_price?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    transport_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesCreateManyInput = {
    id?: number
    itemId: number
    customerId: number
    sale_qty: number
    sales_price: number
    discount: number
    transport_cost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesUpdateManyMutationInput = {
    sale_qty?: FloatFieldUpdateOperationsInput | number
    sales_price?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    transport_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    sale_qty?: FloatFieldUpdateOperationsInput | number
    sales_price?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    transport_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customertypeCreateInput = {
    type_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: customerCreateNestedManyWithoutCustomerIdInput
    customerpayment?: customerpaymentCreateNestedManyWithoutCustomertypeInput
  }

  export type customertypeUncheckedCreateInput = {
    id?: number
    type_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: customerUncheckedCreateNestedManyWithoutCustomerIdInput
    customerpayment?: customerpaymentUncheckedCreateNestedManyWithoutCustomertypeInput
  }

  export type customertypeUpdateInput = {
    type_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: customerUpdateManyWithoutCustomerIdNestedInput
    customerpayment?: customerpaymentUpdateManyWithoutCustomertypeNestedInput
  }

  export type customertypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: customerUncheckedUpdateManyWithoutCustomerIdNestedInput
    customerpayment?: customerpaymentUncheckedUpdateManyWithoutCustomertypeNestedInput
  }

  export type customertypeCreateManyInput = {
    id?: number
    type_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customertypeUpdateManyMutationInput = {
    type_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customertypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerCreateInput = {
    customer_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: customertypeCreateNestedOneWithoutCustomerInput
    customerdetails?: customerdetailsCreateNestedManyWithoutCustomerInput
    sales?: salesCreateNestedManyWithoutCustomerInput
    salescustomertracker?: salescustomertrackerCreateNestedManyWithoutCustomerInput
    customerledger?: customerledgerCreateNestedManyWithoutCustomerInput
    customerpayment?: customerpaymentCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateInput = {
    id?: number
    customer_name: string
    customertypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customerdetails?: customerdetailsUncheckedCreateNestedManyWithoutCustomerInput
    sales?: salesUncheckedCreateNestedManyWithoutCustomerInput
    salescustomertracker?: salescustomertrackerUncheckedCreateNestedManyWithoutCustomerInput
    customerledger?: customerledgerUncheckedCreateNestedManyWithoutCustomerInput
    customerpayment?: customerpaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerUpdateInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: customertypeUpdateOneRequiredWithoutCustomerNestedInput
    customerdetails?: customerdetailsUpdateManyWithoutCustomerNestedInput
    sales?: salesUpdateManyWithoutCustomerNestedInput
    salescustomertracker?: salescustomertrackerUpdateManyWithoutCustomerNestedInput
    customerledger?: customerledgerUpdateManyWithoutCustomerNestedInput
    customerpayment?: customerpaymentUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    customertypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerdetails?: customerdetailsUncheckedUpdateManyWithoutCustomerNestedInput
    sales?: salesUncheckedUpdateManyWithoutCustomerNestedInput
    salescustomertracker?: salescustomertrackerUncheckedUpdateManyWithoutCustomerNestedInput
    customerledger?: customerledgerUncheckedUpdateManyWithoutCustomerNestedInput
    customerpayment?: customerpaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerCreateManyInput = {
    id?: number
    customer_name: string
    customertypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerUpdateManyMutationInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    customertypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salescustomertrackerCreateInput = {
    curr_balance: number
    payment_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: customerCreateNestedOneWithoutSalescustomertrackerInput
  }

  export type salescustomertrackerUncheckedCreateInput = {
    id?: number
    customerId: number
    curr_balance: number
    payment_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salescustomertrackerUpdateInput = {
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: customerUpdateOneRequiredWithoutSalescustomertrackerNestedInput
  }

  export type salescustomertrackerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salescustomertrackerCreateManyInput = {
    id?: number
    customerId: number
    curr_balance: number
    payment_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salescustomertrackerUpdateManyMutationInput = {
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salescustomertrackerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerpaymentCreateInput = {
    balance: number
    transaction_type: string
    collection_method: string
    paid: number
    remission: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customertype: customertypeCreateNestedOneWithoutCustomerpaymentInput
    customer: customerCreateNestedOneWithoutCustomerpaymentInput
  }

  export type customerpaymentUncheckedCreateInput = {
    id?: number
    customertypeId: number
    customerId: number
    balance: number
    transaction_type: string
    collection_method: string
    paid: number
    remission: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerpaymentUpdateInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    collection_method?: StringFieldUpdateOperationsInput | string
    paid?: FloatFieldUpdateOperationsInput | number
    remission?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customertype?: customertypeUpdateOneRequiredWithoutCustomerpaymentNestedInput
    customer?: customerUpdateOneRequiredWithoutCustomerpaymentNestedInput
  }

  export type customerpaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customertypeId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    collection_method?: StringFieldUpdateOperationsInput | string
    paid?: FloatFieldUpdateOperationsInput | number
    remission?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerpaymentCreateManyInput = {
    id?: number
    customertypeId: number
    customerId: number
    balance: number
    transaction_type: string
    collection_method: string
    paid: number
    remission: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerpaymentUpdateManyMutationInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    collection_method?: StringFieldUpdateOperationsInput | string
    paid?: FloatFieldUpdateOperationsInput | number
    remission?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerpaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customertypeId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    collection_method?: StringFieldUpdateOperationsInput | string
    paid?: FloatFieldUpdateOperationsInput | number
    remission?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerledgerCreateInput = {
    payment_type: string
    credit: number
    debit: number
    balance: number
    voucher_no: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: customerCreateNestedOneWithoutCustomerledgerInput
  }

  export type customerledgerUncheckedCreateInput = {
    id?: number
    customerId: number
    payment_type: string
    credit: number
    debit: number
    balance: number
    voucher_no: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerledgerUpdateInput = {
    payment_type?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    voucher_no?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: customerUpdateOneRequiredWithoutCustomerledgerNestedInput
  }

  export type customerledgerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    voucher_no?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerledgerCreateManyInput = {
    id?: number
    customerId: number
    payment_type: string
    credit: number
    debit: number
    balance: number
    voucher_no: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerledgerUpdateManyMutationInput = {
    payment_type?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    voucher_no?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerledgerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    voucher_no?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchasesuppliertrackCreateInput = {
    curr_balance: number
    payment_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: supplierCreateNestedOneWithoutPurchasesuppliertrackInput
  }

  export type purchasesuppliertrackUncheckedCreateInput = {
    id?: number
    supplierId: number
    curr_balance: number
    payment_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchasesuppliertrackUpdateInput = {
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: supplierUpdateOneRequiredWithoutPurchasesuppliertrackNestedInput
  }

  export type purchasesuppliertrackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchasesuppliertrackCreateManyInput = {
    id?: number
    supplierId: number
    curr_balance: number
    payment_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchasesuppliertrackUpdateManyMutationInput = {
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchasesuppliertrackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionCreateInput = {
    balance: number
    transaction_type: string
    transaction_method: string
    payment: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: supplierCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateInput = {
    id?: number
    supplierId: number
    balance: number
    transaction_type: string
    transaction_method: string
    payment: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionUpdateInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    transaction_method?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: supplierUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type transactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    transaction_method?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionCreateManyInput = {
    id?: number
    supplierId: number
    balance: number
    transaction_type: string
    transaction_method: string
    payment: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionUpdateManyMutationInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    transaction_method?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    transaction_method?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplierledgerCreateInput = {
    payment_type: string
    voucher_no: string
    credit: number
    debit: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: supplierCreateNestedOneWithoutSupplierledgerInput
  }

  export type supplierledgerUncheckedCreateInput = {
    id?: number
    supplierId: number
    payment_type: string
    voucher_no: string
    credit: number
    debit: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type supplierledgerUpdateInput = {
    payment_type?: StringFieldUpdateOperationsInput | string
    voucher_no?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: supplierUpdateOneRequiredWithoutSupplierledgerNestedInput
  }

  export type supplierledgerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    voucher_no?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplierledgerCreateManyInput = {
    id?: number
    supplierId: number
    payment_type: string
    voucher_no: string
    credit: number
    debit: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type supplierledgerUpdateManyMutationInput = {
    payment_type?: StringFieldUpdateOperationsInput | string
    voucher_no?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplierledgerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    voucher_no?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerdetailsCreateInput = {
    customer_name: string
    mob_no: string
    address: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: customerCreateNestedOneWithoutCustomerdetailsInput
  }

  export type customerdetailsUncheckedCreateInput = {
    id?: number
    customerId: number
    customer_name: string
    mob_no: string
    address: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerdetailsUpdateInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    mob_no?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: customerUpdateOneRequiredWithoutCustomerdetailsNestedInput
  }

  export type customerdetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    mob_no?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerdetailsCreateManyInput = {
    id?: number
    customerId: number
    customer_name: string
    mob_no: string
    address: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerdetailsUpdateManyMutationInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    mob_no?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerdetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    mob_no?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ItemsListRelationFilter = {
    every?: itemsWhereInput
    some?: itemsWhereInput
    none?: itemsWhereInput
  }

  export type itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoryCountOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type categoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type categoryMinOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type categorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type unitsCountOrderByAggregateInput = {
    id?: SortOrder
    units_name?: SortOrder
    units_label?: SortOrder
    relation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type unitsAvgOrderByAggregateInput = {
    id?: SortOrder
    relation?: SortOrder
  }

  export type unitsMaxOrderByAggregateInput = {
    id?: SortOrder
    units_name?: SortOrder
    units_label?: SortOrder
    relation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type unitsMinOrderByAggregateInput = {
    id?: SortOrder
    units_name?: SortOrder
    units_label?: SortOrder
    relation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type unitsSumOrderByAggregateInput = {
    id?: SortOrder
    relation?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type brandsCountOrderByAggregateInput = {
    id?: SortOrder
    brands_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type brandsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type brandsMaxOrderByAggregateInput = {
    id?: SortOrder
    brands_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type brandsMinOrderByAggregateInput = {
    id?: SortOrder
    brands_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type brandsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PurchaseitemsListRelationFilter = {
    every?: purchaseitemsWhereInput
    some?: purchaseitemsWhereInput
    none?: purchaseitemsWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: purchaseWhereInput
    some?: purchaseWhereInput
    none?: purchaseWhereInput
  }

  export type SalesListRelationFilter = {
    every?: salesWhereInput
    some?: salesWhereInput
    none?: salesWhereInput
  }

  export type CategoryRelationFilter = {
    is?: categoryWhereInput
    isNot?: categoryWhereInput
  }

  export type BrandsRelationFilter = {
    is?: brandsWhereInput
    isNot?: brandsWhereInput
  }

  export type UnitsRelationFilter = {
    is?: unitsWhereInput
    isNot?: unitsWhereInput
  }

  export type purchaseitemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type purchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type salesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type itemsCountOrderByAggregateInput = {
    id?: SortOrder
    items_name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    brandsId?: SortOrder
    unitsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type itemsAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    brandsId?: SortOrder
    unitsId?: SortOrder
  }

  export type itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    items_name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    brandsId?: SortOrder
    unitsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type itemsMinOrderByAggregateInput = {
    id?: SortOrder
    items_name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    brandsId?: SortOrder
    unitsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type itemsSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    brandsId?: SortOrder
    unitsId?: SortOrder
  }

  export type PurchasesuppliertrackListRelationFilter = {
    every?: purchasesuppliertrackWhereInput
    some?: purchasesuppliertrackWhereInput
    none?: purchasesuppliertrackWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: transactionWhereInput
    some?: transactionWhereInput
    none?: transactionWhereInput
  }

  export type SupplierledgerListRelationFilter = {
    every?: supplierledgerWhereInput
    some?: supplierledgerWhereInput
    none?: supplierledgerWhereInput
  }

  export type purchasesuppliertrackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type supplierledgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type supplierCountOrderByAggregateInput = {
    id?: SortOrder
    supplier_name?: SortOrder
    contact_person?: SortOrder
    mobile_number?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type supplierAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type supplierMaxOrderByAggregateInput = {
    id?: SortOrder
    supplier_name?: SortOrder
    contact_person?: SortOrder
    mobile_number?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type supplierMinOrderByAggregateInput = {
    id?: SortOrder
    supplier_name?: SortOrder
    contact_person?: SortOrder
    mobile_number?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type supplierSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ItemsRelationFilter = {
    is?: itemsWhereInput
    isNot?: itemsWhereInput
  }

  export type SupplierRelationFilter = {
    is?: supplierWhereInput
    isNot?: supplierWhereInput
  }

  export type purchaseitemsCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    price_avg?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    purchase_update_qty?: SortOrder
    tax_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchaseitemsAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    price_avg?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    purchase_update_qty?: SortOrder
    tax_Id?: SortOrder
  }

  export type purchaseitemsMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    price_avg?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    purchase_update_qty?: SortOrder
    tax_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchaseitemsMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    price_avg?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    purchase_update_qty?: SortOrder
    tax_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchaseitemsSumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    price_avg?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    purchase_update_qty?: SortOrder
    tax_Id?: SortOrder
  }

  export type purchaseCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    tax_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchaseAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    tax_Id?: SortOrder
  }

  export type purchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    tax_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchaseMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    tax_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchaseSumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    supplierId?: SortOrder
    purchase_qty?: SortOrder
    price_per_unit?: SortOrder
    purchase_total?: SortOrder
    subtotal_amount?: SortOrder
    tax_Id?: SortOrder
  }

  export type CustomerRelationFilter = {
    is?: customerWhereInput
    isNot?: customerWhereInput
  }

  export type salesCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    customerId?: SortOrder
    sale_qty?: SortOrder
    sales_price?: SortOrder
    discount?: SortOrder
    transport_cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type salesAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    customerId?: SortOrder
    sale_qty?: SortOrder
    sales_price?: SortOrder
    discount?: SortOrder
    transport_cost?: SortOrder
  }

  export type salesMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    customerId?: SortOrder
    sale_qty?: SortOrder
    sales_price?: SortOrder
    discount?: SortOrder
    transport_cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type salesMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    customerId?: SortOrder
    sale_qty?: SortOrder
    sales_price?: SortOrder
    discount?: SortOrder
    transport_cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type salesSumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    customerId?: SortOrder
    sale_qty?: SortOrder
    sales_price?: SortOrder
    discount?: SortOrder
    transport_cost?: SortOrder
  }

  export type CustomerListRelationFilter = {
    every?: customerWhereInput
    some?: customerWhereInput
    none?: customerWhereInput
  }

  export type CustomerpaymentListRelationFilter = {
    every?: customerpaymentWhereInput
    some?: customerpaymentWhereInput
    none?: customerpaymentWhereInput
  }

  export type customerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customerpaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customertypeCountOrderByAggregateInput = {
    id?: SortOrder
    type_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customertypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type customertypeMaxOrderByAggregateInput = {
    id?: SortOrder
    type_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customertypeMinOrderByAggregateInput = {
    id?: SortOrder
    type_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customertypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomertypeRelationFilter = {
    is?: customertypeWhereInput
    isNot?: customertypeWhereInput
  }

  export type CustomerdetailsListRelationFilter = {
    every?: customerdetailsWhereInput
    some?: customerdetailsWhereInput
    none?: customerdetailsWhereInput
  }

  export type SalescustomertrackerListRelationFilter = {
    every?: salescustomertrackerWhereInput
    some?: salescustomertrackerWhereInput
    none?: salescustomertrackerWhereInput
  }

  export type CustomerledgerListRelationFilter = {
    every?: customerledgerWhereInput
    some?: customerledgerWhereInput
    none?: customerledgerWhereInput
  }

  export type customerdetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type salescustomertrackerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customerledgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customerCountOrderByAggregateInput = {
    id?: SortOrder
    customer_name?: SortOrder
    customertypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerAvgOrderByAggregateInput = {
    id?: SortOrder
    customertypeId?: SortOrder
  }

  export type customerMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_name?: SortOrder
    customertypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerMinOrderByAggregateInput = {
    id?: SortOrder
    customer_name?: SortOrder
    customertypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerSumOrderByAggregateInput = {
    id?: SortOrder
    customertypeId?: SortOrder
  }

  export type salescustomertrackerCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    curr_balance?: SortOrder
    payment_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type salescustomertrackerAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    curr_balance?: SortOrder
  }

  export type salescustomertrackerMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    curr_balance?: SortOrder
    payment_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type salescustomertrackerMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    curr_balance?: SortOrder
    payment_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type salescustomertrackerSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    curr_balance?: SortOrder
  }

  export type customerpaymentCountOrderByAggregateInput = {
    id?: SortOrder
    customertypeId?: SortOrder
    customerId?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    collection_method?: SortOrder
    paid?: SortOrder
    remission?: SortOrder
    curr_balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerpaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    customertypeId?: SortOrder
    customerId?: SortOrder
    balance?: SortOrder
    paid?: SortOrder
    remission?: SortOrder
    curr_balance?: SortOrder
  }

  export type customerpaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    customertypeId?: SortOrder
    customerId?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    collection_method?: SortOrder
    paid?: SortOrder
    remission?: SortOrder
    curr_balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerpaymentMinOrderByAggregateInput = {
    id?: SortOrder
    customertypeId?: SortOrder
    customerId?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    collection_method?: SortOrder
    paid?: SortOrder
    remission?: SortOrder
    curr_balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerpaymentSumOrderByAggregateInput = {
    id?: SortOrder
    customertypeId?: SortOrder
    customerId?: SortOrder
    balance?: SortOrder
    paid?: SortOrder
    remission?: SortOrder
    curr_balance?: SortOrder
  }

  export type customerledgerCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    payment_type?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
    voucher_no?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerledgerAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
  }

  export type customerledgerMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    payment_type?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
    voucher_no?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerledgerMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    payment_type?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
    voucher_no?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerledgerSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
  }

  export type purchasesuppliertrackCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    curr_balance?: SortOrder
    payment_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchasesuppliertrackAvgOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    curr_balance?: SortOrder
  }

  export type purchasesuppliertrackMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    curr_balance?: SortOrder
    payment_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchasesuppliertrackMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    curr_balance?: SortOrder
    payment_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchasesuppliertrackSumOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    curr_balance?: SortOrder
  }

  export type transactionCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    transaction_method?: SortOrder
    payment?: SortOrder
    curr_balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionAvgOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    balance?: SortOrder
    payment?: SortOrder
    curr_balance?: SortOrder
  }

  export type transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    transaction_method?: SortOrder
    payment?: SortOrder
    curr_balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    transaction_method?: SortOrder
    payment?: SortOrder
    curr_balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionSumOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    balance?: SortOrder
    payment?: SortOrder
    curr_balance?: SortOrder
  }

  export type supplierledgerCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    payment_type?: SortOrder
    voucher_no?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type supplierledgerAvgOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
  }

  export type supplierledgerMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    payment_type?: SortOrder
    voucher_no?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type supplierledgerMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    payment_type?: SortOrder
    voucher_no?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type supplierledgerSumOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    credit?: SortOrder
    debit?: SortOrder
    balance?: SortOrder
  }

  export type customerdetailsCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customer_name?: SortOrder
    mob_no?: SortOrder
    address?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerdetailsAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type customerdetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customer_name?: SortOrder
    mob_no?: SortOrder
    address?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerdetailsMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customer_name?: SortOrder
    mob_no?: SortOrder
    address?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerdetailsSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type itemsCreateNestedManyWithoutItems_categoryInput = {
    create?: XOR<itemsCreateWithoutItems_categoryInput, itemsUncheckedCreateWithoutItems_categoryInput> | itemsCreateWithoutItems_categoryInput[] | itemsUncheckedCreateWithoutItems_categoryInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutItems_categoryInput | itemsCreateOrConnectWithoutItems_categoryInput[]
    createMany?: itemsCreateManyItems_categoryInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type itemsUncheckedCreateNestedManyWithoutItems_categoryInput = {
    create?: XOR<itemsCreateWithoutItems_categoryInput, itemsUncheckedCreateWithoutItems_categoryInput> | itemsCreateWithoutItems_categoryInput[] | itemsUncheckedCreateWithoutItems_categoryInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutItems_categoryInput | itemsCreateOrConnectWithoutItems_categoryInput[]
    createMany?: itemsCreateManyItems_categoryInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type itemsUpdateManyWithoutItems_categoryNestedInput = {
    create?: XOR<itemsCreateWithoutItems_categoryInput, itemsUncheckedCreateWithoutItems_categoryInput> | itemsCreateWithoutItems_categoryInput[] | itemsUncheckedCreateWithoutItems_categoryInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutItems_categoryInput | itemsCreateOrConnectWithoutItems_categoryInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutItems_categoryInput | itemsUpsertWithWhereUniqueWithoutItems_categoryInput[]
    createMany?: itemsCreateManyItems_categoryInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutItems_categoryInput | itemsUpdateWithWhereUniqueWithoutItems_categoryInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutItems_categoryInput | itemsUpdateManyWithWhereWithoutItems_categoryInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type itemsUncheckedUpdateManyWithoutItems_categoryNestedInput = {
    create?: XOR<itemsCreateWithoutItems_categoryInput, itemsUncheckedCreateWithoutItems_categoryInput> | itemsCreateWithoutItems_categoryInput[] | itemsUncheckedCreateWithoutItems_categoryInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutItems_categoryInput | itemsCreateOrConnectWithoutItems_categoryInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutItems_categoryInput | itemsUpsertWithWhereUniqueWithoutItems_categoryInput[]
    createMany?: itemsCreateManyItems_categoryInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutItems_categoryInput | itemsUpdateWithWhereUniqueWithoutItems_categoryInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutItems_categoryInput | itemsUpdateManyWithWhereWithoutItems_categoryInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type itemsCreateNestedManyWithoutItems_unitsInput = {
    create?: XOR<itemsCreateWithoutItems_unitsInput, itemsUncheckedCreateWithoutItems_unitsInput> | itemsCreateWithoutItems_unitsInput[] | itemsUncheckedCreateWithoutItems_unitsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutItems_unitsInput | itemsCreateOrConnectWithoutItems_unitsInput[]
    createMany?: itemsCreateManyItems_unitsInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type itemsUncheckedCreateNestedManyWithoutItems_unitsInput = {
    create?: XOR<itemsCreateWithoutItems_unitsInput, itemsUncheckedCreateWithoutItems_unitsInput> | itemsCreateWithoutItems_unitsInput[] | itemsUncheckedCreateWithoutItems_unitsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutItems_unitsInput | itemsCreateOrConnectWithoutItems_unitsInput[]
    createMany?: itemsCreateManyItems_unitsInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type itemsUpdateManyWithoutItems_unitsNestedInput = {
    create?: XOR<itemsCreateWithoutItems_unitsInput, itemsUncheckedCreateWithoutItems_unitsInput> | itemsCreateWithoutItems_unitsInput[] | itemsUncheckedCreateWithoutItems_unitsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutItems_unitsInput | itemsCreateOrConnectWithoutItems_unitsInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutItems_unitsInput | itemsUpsertWithWhereUniqueWithoutItems_unitsInput[]
    createMany?: itemsCreateManyItems_unitsInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutItems_unitsInput | itemsUpdateWithWhereUniqueWithoutItems_unitsInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutItems_unitsInput | itemsUpdateManyWithWhereWithoutItems_unitsInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type itemsUncheckedUpdateManyWithoutItems_unitsNestedInput = {
    create?: XOR<itemsCreateWithoutItems_unitsInput, itemsUncheckedCreateWithoutItems_unitsInput> | itemsCreateWithoutItems_unitsInput[] | itemsUncheckedCreateWithoutItems_unitsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutItems_unitsInput | itemsCreateOrConnectWithoutItems_unitsInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutItems_unitsInput | itemsUpsertWithWhereUniqueWithoutItems_unitsInput[]
    createMany?: itemsCreateManyItems_unitsInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutItems_unitsInput | itemsUpdateWithWhereUniqueWithoutItems_unitsInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutItems_unitsInput | itemsUpdateManyWithWhereWithoutItems_unitsInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type itemsCreateNestedManyWithoutItems_brandsInput = {
    create?: XOR<itemsCreateWithoutItems_brandsInput, itemsUncheckedCreateWithoutItems_brandsInput> | itemsCreateWithoutItems_brandsInput[] | itemsUncheckedCreateWithoutItems_brandsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutItems_brandsInput | itemsCreateOrConnectWithoutItems_brandsInput[]
    createMany?: itemsCreateManyItems_brandsInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type itemsUncheckedCreateNestedManyWithoutItems_brandsInput = {
    create?: XOR<itemsCreateWithoutItems_brandsInput, itemsUncheckedCreateWithoutItems_brandsInput> | itemsCreateWithoutItems_brandsInput[] | itemsUncheckedCreateWithoutItems_brandsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutItems_brandsInput | itemsCreateOrConnectWithoutItems_brandsInput[]
    createMany?: itemsCreateManyItems_brandsInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type itemsUpdateManyWithoutItems_brandsNestedInput = {
    create?: XOR<itemsCreateWithoutItems_brandsInput, itemsUncheckedCreateWithoutItems_brandsInput> | itemsCreateWithoutItems_brandsInput[] | itemsUncheckedCreateWithoutItems_brandsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutItems_brandsInput | itemsCreateOrConnectWithoutItems_brandsInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutItems_brandsInput | itemsUpsertWithWhereUniqueWithoutItems_brandsInput[]
    createMany?: itemsCreateManyItems_brandsInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutItems_brandsInput | itemsUpdateWithWhereUniqueWithoutItems_brandsInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutItems_brandsInput | itemsUpdateManyWithWhereWithoutItems_brandsInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type itemsUncheckedUpdateManyWithoutItems_brandsNestedInput = {
    create?: XOR<itemsCreateWithoutItems_brandsInput, itemsUncheckedCreateWithoutItems_brandsInput> | itemsCreateWithoutItems_brandsInput[] | itemsUncheckedCreateWithoutItems_brandsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutItems_brandsInput | itemsCreateOrConnectWithoutItems_brandsInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutItems_brandsInput | itemsUpsertWithWhereUniqueWithoutItems_brandsInput[]
    createMany?: itemsCreateManyItems_brandsInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutItems_brandsInput | itemsUpdateWithWhereUniqueWithoutItems_brandsInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutItems_brandsInput | itemsUpdateManyWithWhereWithoutItems_brandsInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type purchaseitemsCreateNestedManyWithoutPurchaseitems_itemsInput = {
    create?: XOR<purchaseitemsCreateWithoutPurchaseitems_itemsInput, purchaseitemsUncheckedCreateWithoutPurchaseitems_itemsInput> | purchaseitemsCreateWithoutPurchaseitems_itemsInput[] | purchaseitemsUncheckedCreateWithoutPurchaseitems_itemsInput[]
    connectOrCreate?: purchaseitemsCreateOrConnectWithoutPurchaseitems_itemsInput | purchaseitemsCreateOrConnectWithoutPurchaseitems_itemsInput[]
    createMany?: purchaseitemsCreateManyPurchaseitems_itemsInputEnvelope
    connect?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
  }

  export type purchaseCreateNestedManyWithoutPurchase_itemsInput = {
    create?: XOR<purchaseCreateWithoutPurchase_itemsInput, purchaseUncheckedCreateWithoutPurchase_itemsInput> | purchaseCreateWithoutPurchase_itemsInput[] | purchaseUncheckedCreateWithoutPurchase_itemsInput[]
    connectOrCreate?: purchaseCreateOrConnectWithoutPurchase_itemsInput | purchaseCreateOrConnectWithoutPurchase_itemsInput[]
    createMany?: purchaseCreateManyPurchase_itemsInputEnvelope
    connect?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
  }

  export type salesCreateNestedManyWithoutItemsInput = {
    create?: XOR<salesCreateWithoutItemsInput, salesUncheckedCreateWithoutItemsInput> | salesCreateWithoutItemsInput[] | salesUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: salesCreateOrConnectWithoutItemsInput | salesCreateOrConnectWithoutItemsInput[]
    createMany?: salesCreateManyItemsInputEnvelope
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
  }

  export type categoryCreateNestedOneWithoutItemsInput = {
    create?: XOR<categoryCreateWithoutItemsInput, categoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: categoryCreateOrConnectWithoutItemsInput
    connect?: categoryWhereUniqueInput
  }

  export type brandsCreateNestedOneWithoutItemsInput = {
    create?: XOR<brandsCreateWithoutItemsInput, brandsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutItemsInput
    connect?: brandsWhereUniqueInput
  }

  export type unitsCreateNestedOneWithoutItemsInput = {
    create?: XOR<unitsCreateWithoutItemsInput, unitsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: unitsCreateOrConnectWithoutItemsInput
    connect?: unitsWhereUniqueInput
  }

  export type purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitems_itemsInput = {
    create?: XOR<purchaseitemsCreateWithoutPurchaseitems_itemsInput, purchaseitemsUncheckedCreateWithoutPurchaseitems_itemsInput> | purchaseitemsCreateWithoutPurchaseitems_itemsInput[] | purchaseitemsUncheckedCreateWithoutPurchaseitems_itemsInput[]
    connectOrCreate?: purchaseitemsCreateOrConnectWithoutPurchaseitems_itemsInput | purchaseitemsCreateOrConnectWithoutPurchaseitems_itemsInput[]
    createMany?: purchaseitemsCreateManyPurchaseitems_itemsInputEnvelope
    connect?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
  }

  export type purchaseUncheckedCreateNestedManyWithoutPurchase_itemsInput = {
    create?: XOR<purchaseCreateWithoutPurchase_itemsInput, purchaseUncheckedCreateWithoutPurchase_itemsInput> | purchaseCreateWithoutPurchase_itemsInput[] | purchaseUncheckedCreateWithoutPurchase_itemsInput[]
    connectOrCreate?: purchaseCreateOrConnectWithoutPurchase_itemsInput | purchaseCreateOrConnectWithoutPurchase_itemsInput[]
    createMany?: purchaseCreateManyPurchase_itemsInputEnvelope
    connect?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
  }

  export type salesUncheckedCreateNestedManyWithoutItemsInput = {
    create?: XOR<salesCreateWithoutItemsInput, salesUncheckedCreateWithoutItemsInput> | salesCreateWithoutItemsInput[] | salesUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: salesCreateOrConnectWithoutItemsInput | salesCreateOrConnectWithoutItemsInput[]
    createMany?: salesCreateManyItemsInputEnvelope
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
  }

  export type purchaseitemsUpdateManyWithoutPurchaseitems_itemsNestedInput = {
    create?: XOR<purchaseitemsCreateWithoutPurchaseitems_itemsInput, purchaseitemsUncheckedCreateWithoutPurchaseitems_itemsInput> | purchaseitemsCreateWithoutPurchaseitems_itemsInput[] | purchaseitemsUncheckedCreateWithoutPurchaseitems_itemsInput[]
    connectOrCreate?: purchaseitemsCreateOrConnectWithoutPurchaseitems_itemsInput | purchaseitemsCreateOrConnectWithoutPurchaseitems_itemsInput[]
    upsert?: purchaseitemsUpsertWithWhereUniqueWithoutPurchaseitems_itemsInput | purchaseitemsUpsertWithWhereUniqueWithoutPurchaseitems_itemsInput[]
    createMany?: purchaseitemsCreateManyPurchaseitems_itemsInputEnvelope
    set?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    disconnect?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    delete?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    connect?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    update?: purchaseitemsUpdateWithWhereUniqueWithoutPurchaseitems_itemsInput | purchaseitemsUpdateWithWhereUniqueWithoutPurchaseitems_itemsInput[]
    updateMany?: purchaseitemsUpdateManyWithWhereWithoutPurchaseitems_itemsInput | purchaseitemsUpdateManyWithWhereWithoutPurchaseitems_itemsInput[]
    deleteMany?: purchaseitemsScalarWhereInput | purchaseitemsScalarWhereInput[]
  }

  export type purchaseUpdateManyWithoutPurchase_itemsNestedInput = {
    create?: XOR<purchaseCreateWithoutPurchase_itemsInput, purchaseUncheckedCreateWithoutPurchase_itemsInput> | purchaseCreateWithoutPurchase_itemsInput[] | purchaseUncheckedCreateWithoutPurchase_itemsInput[]
    connectOrCreate?: purchaseCreateOrConnectWithoutPurchase_itemsInput | purchaseCreateOrConnectWithoutPurchase_itemsInput[]
    upsert?: purchaseUpsertWithWhereUniqueWithoutPurchase_itemsInput | purchaseUpsertWithWhereUniqueWithoutPurchase_itemsInput[]
    createMany?: purchaseCreateManyPurchase_itemsInputEnvelope
    set?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    disconnect?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    delete?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    connect?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    update?: purchaseUpdateWithWhereUniqueWithoutPurchase_itemsInput | purchaseUpdateWithWhereUniqueWithoutPurchase_itemsInput[]
    updateMany?: purchaseUpdateManyWithWhereWithoutPurchase_itemsInput | purchaseUpdateManyWithWhereWithoutPurchase_itemsInput[]
    deleteMany?: purchaseScalarWhereInput | purchaseScalarWhereInput[]
  }

  export type salesUpdateManyWithoutItemsNestedInput = {
    create?: XOR<salesCreateWithoutItemsInput, salesUncheckedCreateWithoutItemsInput> | salesCreateWithoutItemsInput[] | salesUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: salesCreateOrConnectWithoutItemsInput | salesCreateOrConnectWithoutItemsInput[]
    upsert?: salesUpsertWithWhereUniqueWithoutItemsInput | salesUpsertWithWhereUniqueWithoutItemsInput[]
    createMany?: salesCreateManyItemsInputEnvelope
    set?: salesWhereUniqueInput | salesWhereUniqueInput[]
    disconnect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    delete?: salesWhereUniqueInput | salesWhereUniqueInput[]
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    update?: salesUpdateWithWhereUniqueWithoutItemsInput | salesUpdateWithWhereUniqueWithoutItemsInput[]
    updateMany?: salesUpdateManyWithWhereWithoutItemsInput | salesUpdateManyWithWhereWithoutItemsInput[]
    deleteMany?: salesScalarWhereInput | salesScalarWhereInput[]
  }

  export type categoryUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<categoryCreateWithoutItemsInput, categoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: categoryCreateOrConnectWithoutItemsInput
    upsert?: categoryUpsertWithoutItemsInput
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutItemsInput, categoryUpdateWithoutItemsInput>, categoryUncheckedUpdateWithoutItemsInput>
  }

  export type brandsUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<brandsCreateWithoutItemsInput, brandsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutItemsInput
    upsert?: brandsUpsertWithoutItemsInput
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutItemsInput, brandsUpdateWithoutItemsInput>, brandsUncheckedUpdateWithoutItemsInput>
  }

  export type unitsUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<unitsCreateWithoutItemsInput, unitsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: unitsCreateOrConnectWithoutItemsInput
    upsert?: unitsUpsertWithoutItemsInput
    connect?: unitsWhereUniqueInput
    update?: XOR<XOR<unitsUpdateToOneWithWhereWithoutItemsInput, unitsUpdateWithoutItemsInput>, unitsUncheckedUpdateWithoutItemsInput>
  }

  export type purchaseitemsUncheckedUpdateManyWithoutPurchaseitems_itemsNestedInput = {
    create?: XOR<purchaseitemsCreateWithoutPurchaseitems_itemsInput, purchaseitemsUncheckedCreateWithoutPurchaseitems_itemsInput> | purchaseitemsCreateWithoutPurchaseitems_itemsInput[] | purchaseitemsUncheckedCreateWithoutPurchaseitems_itemsInput[]
    connectOrCreate?: purchaseitemsCreateOrConnectWithoutPurchaseitems_itemsInput | purchaseitemsCreateOrConnectWithoutPurchaseitems_itemsInput[]
    upsert?: purchaseitemsUpsertWithWhereUniqueWithoutPurchaseitems_itemsInput | purchaseitemsUpsertWithWhereUniqueWithoutPurchaseitems_itemsInput[]
    createMany?: purchaseitemsCreateManyPurchaseitems_itemsInputEnvelope
    set?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    disconnect?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    delete?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    connect?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    update?: purchaseitemsUpdateWithWhereUniqueWithoutPurchaseitems_itemsInput | purchaseitemsUpdateWithWhereUniqueWithoutPurchaseitems_itemsInput[]
    updateMany?: purchaseitemsUpdateManyWithWhereWithoutPurchaseitems_itemsInput | purchaseitemsUpdateManyWithWhereWithoutPurchaseitems_itemsInput[]
    deleteMany?: purchaseitemsScalarWhereInput | purchaseitemsScalarWhereInput[]
  }

  export type purchaseUncheckedUpdateManyWithoutPurchase_itemsNestedInput = {
    create?: XOR<purchaseCreateWithoutPurchase_itemsInput, purchaseUncheckedCreateWithoutPurchase_itemsInput> | purchaseCreateWithoutPurchase_itemsInput[] | purchaseUncheckedCreateWithoutPurchase_itemsInput[]
    connectOrCreate?: purchaseCreateOrConnectWithoutPurchase_itemsInput | purchaseCreateOrConnectWithoutPurchase_itemsInput[]
    upsert?: purchaseUpsertWithWhereUniqueWithoutPurchase_itemsInput | purchaseUpsertWithWhereUniqueWithoutPurchase_itemsInput[]
    createMany?: purchaseCreateManyPurchase_itemsInputEnvelope
    set?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    disconnect?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    delete?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    connect?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    update?: purchaseUpdateWithWhereUniqueWithoutPurchase_itemsInput | purchaseUpdateWithWhereUniqueWithoutPurchase_itemsInput[]
    updateMany?: purchaseUpdateManyWithWhereWithoutPurchase_itemsInput | purchaseUpdateManyWithWhereWithoutPurchase_itemsInput[]
    deleteMany?: purchaseScalarWhereInput | purchaseScalarWhereInput[]
  }

  export type salesUncheckedUpdateManyWithoutItemsNestedInput = {
    create?: XOR<salesCreateWithoutItemsInput, salesUncheckedCreateWithoutItemsInput> | salesCreateWithoutItemsInput[] | salesUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: salesCreateOrConnectWithoutItemsInput | salesCreateOrConnectWithoutItemsInput[]
    upsert?: salesUpsertWithWhereUniqueWithoutItemsInput | salesUpsertWithWhereUniqueWithoutItemsInput[]
    createMany?: salesCreateManyItemsInputEnvelope
    set?: salesWhereUniqueInput | salesWhereUniqueInput[]
    disconnect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    delete?: salesWhereUniqueInput | salesWhereUniqueInput[]
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    update?: salesUpdateWithWhereUniqueWithoutItemsInput | salesUpdateWithWhereUniqueWithoutItemsInput[]
    updateMany?: salesUpdateManyWithWhereWithoutItemsInput | salesUpdateManyWithWhereWithoutItemsInput[]
    deleteMany?: salesScalarWhereInput | salesScalarWhereInput[]
  }

  export type purchaseitemsCreateNestedManyWithoutPurchaseitemsIdInput = {
    create?: XOR<purchaseitemsCreateWithoutPurchaseitemsIdInput, purchaseitemsUncheckedCreateWithoutPurchaseitemsIdInput> | purchaseitemsCreateWithoutPurchaseitemsIdInput[] | purchaseitemsUncheckedCreateWithoutPurchaseitemsIdInput[]
    connectOrCreate?: purchaseitemsCreateOrConnectWithoutPurchaseitemsIdInput | purchaseitemsCreateOrConnectWithoutPurchaseitemsIdInput[]
    createMany?: purchaseitemsCreateManyPurchaseitemsIdInputEnvelope
    connect?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
  }

  export type purchaseCreateNestedManyWithoutSupplierInput = {
    create?: XOR<purchaseCreateWithoutSupplierInput, purchaseUncheckedCreateWithoutSupplierInput> | purchaseCreateWithoutSupplierInput[] | purchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: purchaseCreateOrConnectWithoutSupplierInput | purchaseCreateOrConnectWithoutSupplierInput[]
    createMany?: purchaseCreateManySupplierInputEnvelope
    connect?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
  }

  export type purchasesuppliertrackCreateNestedManyWithoutSupplierInput = {
    create?: XOR<purchasesuppliertrackCreateWithoutSupplierInput, purchasesuppliertrackUncheckedCreateWithoutSupplierInput> | purchasesuppliertrackCreateWithoutSupplierInput[] | purchasesuppliertrackUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: purchasesuppliertrackCreateOrConnectWithoutSupplierInput | purchasesuppliertrackCreateOrConnectWithoutSupplierInput[]
    createMany?: purchasesuppliertrackCreateManySupplierInputEnvelope
    connect?: purchasesuppliertrackWhereUniqueInput | purchasesuppliertrackWhereUniqueInput[]
  }

  export type transactionCreateNestedManyWithoutSupplierInput = {
    create?: XOR<transactionCreateWithoutSupplierInput, transactionUncheckedCreateWithoutSupplierInput> | transactionCreateWithoutSupplierInput[] | transactionUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutSupplierInput | transactionCreateOrConnectWithoutSupplierInput[]
    createMany?: transactionCreateManySupplierInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type supplierledgerCreateNestedManyWithoutSupplierInput = {
    create?: XOR<supplierledgerCreateWithoutSupplierInput, supplierledgerUncheckedCreateWithoutSupplierInput> | supplierledgerCreateWithoutSupplierInput[] | supplierledgerUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: supplierledgerCreateOrConnectWithoutSupplierInput | supplierledgerCreateOrConnectWithoutSupplierInput[]
    createMany?: supplierledgerCreateManySupplierInputEnvelope
    connect?: supplierledgerWhereUniqueInput | supplierledgerWhereUniqueInput[]
  }

  export type purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitemsIdInput = {
    create?: XOR<purchaseitemsCreateWithoutPurchaseitemsIdInput, purchaseitemsUncheckedCreateWithoutPurchaseitemsIdInput> | purchaseitemsCreateWithoutPurchaseitemsIdInput[] | purchaseitemsUncheckedCreateWithoutPurchaseitemsIdInput[]
    connectOrCreate?: purchaseitemsCreateOrConnectWithoutPurchaseitemsIdInput | purchaseitemsCreateOrConnectWithoutPurchaseitemsIdInput[]
    createMany?: purchaseitemsCreateManyPurchaseitemsIdInputEnvelope
    connect?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
  }

  export type purchaseUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<purchaseCreateWithoutSupplierInput, purchaseUncheckedCreateWithoutSupplierInput> | purchaseCreateWithoutSupplierInput[] | purchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: purchaseCreateOrConnectWithoutSupplierInput | purchaseCreateOrConnectWithoutSupplierInput[]
    createMany?: purchaseCreateManySupplierInputEnvelope
    connect?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
  }

  export type purchasesuppliertrackUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<purchasesuppliertrackCreateWithoutSupplierInput, purchasesuppliertrackUncheckedCreateWithoutSupplierInput> | purchasesuppliertrackCreateWithoutSupplierInput[] | purchasesuppliertrackUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: purchasesuppliertrackCreateOrConnectWithoutSupplierInput | purchasesuppliertrackCreateOrConnectWithoutSupplierInput[]
    createMany?: purchasesuppliertrackCreateManySupplierInputEnvelope
    connect?: purchasesuppliertrackWhereUniqueInput | purchasesuppliertrackWhereUniqueInput[]
  }

  export type transactionUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<transactionCreateWithoutSupplierInput, transactionUncheckedCreateWithoutSupplierInput> | transactionCreateWithoutSupplierInput[] | transactionUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutSupplierInput | transactionCreateOrConnectWithoutSupplierInput[]
    createMany?: transactionCreateManySupplierInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type supplierledgerUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<supplierledgerCreateWithoutSupplierInput, supplierledgerUncheckedCreateWithoutSupplierInput> | supplierledgerCreateWithoutSupplierInput[] | supplierledgerUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: supplierledgerCreateOrConnectWithoutSupplierInput | supplierledgerCreateOrConnectWithoutSupplierInput[]
    createMany?: supplierledgerCreateManySupplierInputEnvelope
    connect?: supplierledgerWhereUniqueInput | supplierledgerWhereUniqueInput[]
  }

  export type purchaseitemsUpdateManyWithoutPurchaseitemsIdNestedInput = {
    create?: XOR<purchaseitemsCreateWithoutPurchaseitemsIdInput, purchaseitemsUncheckedCreateWithoutPurchaseitemsIdInput> | purchaseitemsCreateWithoutPurchaseitemsIdInput[] | purchaseitemsUncheckedCreateWithoutPurchaseitemsIdInput[]
    connectOrCreate?: purchaseitemsCreateOrConnectWithoutPurchaseitemsIdInput | purchaseitemsCreateOrConnectWithoutPurchaseitemsIdInput[]
    upsert?: purchaseitemsUpsertWithWhereUniqueWithoutPurchaseitemsIdInput | purchaseitemsUpsertWithWhereUniqueWithoutPurchaseitemsIdInput[]
    createMany?: purchaseitemsCreateManyPurchaseitemsIdInputEnvelope
    set?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    disconnect?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    delete?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    connect?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    update?: purchaseitemsUpdateWithWhereUniqueWithoutPurchaseitemsIdInput | purchaseitemsUpdateWithWhereUniqueWithoutPurchaseitemsIdInput[]
    updateMany?: purchaseitemsUpdateManyWithWhereWithoutPurchaseitemsIdInput | purchaseitemsUpdateManyWithWhereWithoutPurchaseitemsIdInput[]
    deleteMany?: purchaseitemsScalarWhereInput | purchaseitemsScalarWhereInput[]
  }

  export type purchaseUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<purchaseCreateWithoutSupplierInput, purchaseUncheckedCreateWithoutSupplierInput> | purchaseCreateWithoutSupplierInput[] | purchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: purchaseCreateOrConnectWithoutSupplierInput | purchaseCreateOrConnectWithoutSupplierInput[]
    upsert?: purchaseUpsertWithWhereUniqueWithoutSupplierInput | purchaseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: purchaseCreateManySupplierInputEnvelope
    set?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    disconnect?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    delete?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    connect?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    update?: purchaseUpdateWithWhereUniqueWithoutSupplierInput | purchaseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: purchaseUpdateManyWithWhereWithoutSupplierInput | purchaseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: purchaseScalarWhereInput | purchaseScalarWhereInput[]
  }

  export type purchasesuppliertrackUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<purchasesuppliertrackCreateWithoutSupplierInput, purchasesuppliertrackUncheckedCreateWithoutSupplierInput> | purchasesuppliertrackCreateWithoutSupplierInput[] | purchasesuppliertrackUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: purchasesuppliertrackCreateOrConnectWithoutSupplierInput | purchasesuppliertrackCreateOrConnectWithoutSupplierInput[]
    upsert?: purchasesuppliertrackUpsertWithWhereUniqueWithoutSupplierInput | purchasesuppliertrackUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: purchasesuppliertrackCreateManySupplierInputEnvelope
    set?: purchasesuppliertrackWhereUniqueInput | purchasesuppliertrackWhereUniqueInput[]
    disconnect?: purchasesuppliertrackWhereUniqueInput | purchasesuppliertrackWhereUniqueInput[]
    delete?: purchasesuppliertrackWhereUniqueInput | purchasesuppliertrackWhereUniqueInput[]
    connect?: purchasesuppliertrackWhereUniqueInput | purchasesuppliertrackWhereUniqueInput[]
    update?: purchasesuppliertrackUpdateWithWhereUniqueWithoutSupplierInput | purchasesuppliertrackUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: purchasesuppliertrackUpdateManyWithWhereWithoutSupplierInput | purchasesuppliertrackUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: purchasesuppliertrackScalarWhereInput | purchasesuppliertrackScalarWhereInput[]
  }

  export type transactionUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<transactionCreateWithoutSupplierInput, transactionUncheckedCreateWithoutSupplierInput> | transactionCreateWithoutSupplierInput[] | transactionUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutSupplierInput | transactionCreateOrConnectWithoutSupplierInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutSupplierInput | transactionUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: transactionCreateManySupplierInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutSupplierInput | transactionUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutSupplierInput | transactionUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type supplierledgerUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<supplierledgerCreateWithoutSupplierInput, supplierledgerUncheckedCreateWithoutSupplierInput> | supplierledgerCreateWithoutSupplierInput[] | supplierledgerUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: supplierledgerCreateOrConnectWithoutSupplierInput | supplierledgerCreateOrConnectWithoutSupplierInput[]
    upsert?: supplierledgerUpsertWithWhereUniqueWithoutSupplierInput | supplierledgerUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: supplierledgerCreateManySupplierInputEnvelope
    set?: supplierledgerWhereUniqueInput | supplierledgerWhereUniqueInput[]
    disconnect?: supplierledgerWhereUniqueInput | supplierledgerWhereUniqueInput[]
    delete?: supplierledgerWhereUniqueInput | supplierledgerWhereUniqueInput[]
    connect?: supplierledgerWhereUniqueInput | supplierledgerWhereUniqueInput[]
    update?: supplierledgerUpdateWithWhereUniqueWithoutSupplierInput | supplierledgerUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: supplierledgerUpdateManyWithWhereWithoutSupplierInput | supplierledgerUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: supplierledgerScalarWhereInput | supplierledgerScalarWhereInput[]
  }

  export type purchaseitemsUncheckedUpdateManyWithoutPurchaseitemsIdNestedInput = {
    create?: XOR<purchaseitemsCreateWithoutPurchaseitemsIdInput, purchaseitemsUncheckedCreateWithoutPurchaseitemsIdInput> | purchaseitemsCreateWithoutPurchaseitemsIdInput[] | purchaseitemsUncheckedCreateWithoutPurchaseitemsIdInput[]
    connectOrCreate?: purchaseitemsCreateOrConnectWithoutPurchaseitemsIdInput | purchaseitemsCreateOrConnectWithoutPurchaseitemsIdInput[]
    upsert?: purchaseitemsUpsertWithWhereUniqueWithoutPurchaseitemsIdInput | purchaseitemsUpsertWithWhereUniqueWithoutPurchaseitemsIdInput[]
    createMany?: purchaseitemsCreateManyPurchaseitemsIdInputEnvelope
    set?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    disconnect?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    delete?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    connect?: purchaseitemsWhereUniqueInput | purchaseitemsWhereUniqueInput[]
    update?: purchaseitemsUpdateWithWhereUniqueWithoutPurchaseitemsIdInput | purchaseitemsUpdateWithWhereUniqueWithoutPurchaseitemsIdInput[]
    updateMany?: purchaseitemsUpdateManyWithWhereWithoutPurchaseitemsIdInput | purchaseitemsUpdateManyWithWhereWithoutPurchaseitemsIdInput[]
    deleteMany?: purchaseitemsScalarWhereInput | purchaseitemsScalarWhereInput[]
  }

  export type purchaseUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<purchaseCreateWithoutSupplierInput, purchaseUncheckedCreateWithoutSupplierInput> | purchaseCreateWithoutSupplierInput[] | purchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: purchaseCreateOrConnectWithoutSupplierInput | purchaseCreateOrConnectWithoutSupplierInput[]
    upsert?: purchaseUpsertWithWhereUniqueWithoutSupplierInput | purchaseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: purchaseCreateManySupplierInputEnvelope
    set?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    disconnect?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    delete?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    connect?: purchaseWhereUniqueInput | purchaseWhereUniqueInput[]
    update?: purchaseUpdateWithWhereUniqueWithoutSupplierInput | purchaseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: purchaseUpdateManyWithWhereWithoutSupplierInput | purchaseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: purchaseScalarWhereInput | purchaseScalarWhereInput[]
  }

  export type purchasesuppliertrackUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<purchasesuppliertrackCreateWithoutSupplierInput, purchasesuppliertrackUncheckedCreateWithoutSupplierInput> | purchasesuppliertrackCreateWithoutSupplierInput[] | purchasesuppliertrackUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: purchasesuppliertrackCreateOrConnectWithoutSupplierInput | purchasesuppliertrackCreateOrConnectWithoutSupplierInput[]
    upsert?: purchasesuppliertrackUpsertWithWhereUniqueWithoutSupplierInput | purchasesuppliertrackUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: purchasesuppliertrackCreateManySupplierInputEnvelope
    set?: purchasesuppliertrackWhereUniqueInput | purchasesuppliertrackWhereUniqueInput[]
    disconnect?: purchasesuppliertrackWhereUniqueInput | purchasesuppliertrackWhereUniqueInput[]
    delete?: purchasesuppliertrackWhereUniqueInput | purchasesuppliertrackWhereUniqueInput[]
    connect?: purchasesuppliertrackWhereUniqueInput | purchasesuppliertrackWhereUniqueInput[]
    update?: purchasesuppliertrackUpdateWithWhereUniqueWithoutSupplierInput | purchasesuppliertrackUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: purchasesuppliertrackUpdateManyWithWhereWithoutSupplierInput | purchasesuppliertrackUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: purchasesuppliertrackScalarWhereInput | purchasesuppliertrackScalarWhereInput[]
  }

  export type transactionUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<transactionCreateWithoutSupplierInput, transactionUncheckedCreateWithoutSupplierInput> | transactionCreateWithoutSupplierInput[] | transactionUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutSupplierInput | transactionCreateOrConnectWithoutSupplierInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutSupplierInput | transactionUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: transactionCreateManySupplierInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutSupplierInput | transactionUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutSupplierInput | transactionUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type supplierledgerUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<supplierledgerCreateWithoutSupplierInput, supplierledgerUncheckedCreateWithoutSupplierInput> | supplierledgerCreateWithoutSupplierInput[] | supplierledgerUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: supplierledgerCreateOrConnectWithoutSupplierInput | supplierledgerCreateOrConnectWithoutSupplierInput[]
    upsert?: supplierledgerUpsertWithWhereUniqueWithoutSupplierInput | supplierledgerUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: supplierledgerCreateManySupplierInputEnvelope
    set?: supplierledgerWhereUniqueInput | supplierledgerWhereUniqueInput[]
    disconnect?: supplierledgerWhereUniqueInput | supplierledgerWhereUniqueInput[]
    delete?: supplierledgerWhereUniqueInput | supplierledgerWhereUniqueInput[]
    connect?: supplierledgerWhereUniqueInput | supplierledgerWhereUniqueInput[]
    update?: supplierledgerUpdateWithWhereUniqueWithoutSupplierInput | supplierledgerUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: supplierledgerUpdateManyWithWhereWithoutSupplierInput | supplierledgerUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: supplierledgerScalarWhereInput | supplierledgerScalarWhereInput[]
  }

  export type itemsCreateNestedOneWithoutPurchaseitemsInput = {
    create?: XOR<itemsCreateWithoutPurchaseitemsInput, itemsUncheckedCreateWithoutPurchaseitemsInput>
    connectOrCreate?: itemsCreateOrConnectWithoutPurchaseitemsInput
    connect?: itemsWhereUniqueInput
  }

  export type supplierCreateNestedOneWithoutPurchaseitemsInput = {
    create?: XOR<supplierCreateWithoutPurchaseitemsInput, supplierUncheckedCreateWithoutPurchaseitemsInput>
    connectOrCreate?: supplierCreateOrConnectWithoutPurchaseitemsInput
    connect?: supplierWhereUniqueInput
  }

  export type itemsUpdateOneRequiredWithoutPurchaseitemsNestedInput = {
    create?: XOR<itemsCreateWithoutPurchaseitemsInput, itemsUncheckedCreateWithoutPurchaseitemsInput>
    connectOrCreate?: itemsCreateOrConnectWithoutPurchaseitemsInput
    upsert?: itemsUpsertWithoutPurchaseitemsInput
    connect?: itemsWhereUniqueInput
    update?: XOR<XOR<itemsUpdateToOneWithWhereWithoutPurchaseitemsInput, itemsUpdateWithoutPurchaseitemsInput>, itemsUncheckedUpdateWithoutPurchaseitemsInput>
  }

  export type supplierUpdateOneRequiredWithoutPurchaseitemsNestedInput = {
    create?: XOR<supplierCreateWithoutPurchaseitemsInput, supplierUncheckedCreateWithoutPurchaseitemsInput>
    connectOrCreate?: supplierCreateOrConnectWithoutPurchaseitemsInput
    upsert?: supplierUpsertWithoutPurchaseitemsInput
    connect?: supplierWhereUniqueInput
    update?: XOR<XOR<supplierUpdateToOneWithWhereWithoutPurchaseitemsInput, supplierUpdateWithoutPurchaseitemsInput>, supplierUncheckedUpdateWithoutPurchaseitemsInput>
  }

  export type itemsCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<itemsCreateWithoutPurchaseInput, itemsUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: itemsCreateOrConnectWithoutPurchaseInput
    connect?: itemsWhereUniqueInput
  }

  export type supplierCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<supplierCreateWithoutPurchaseInput, supplierUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: supplierCreateOrConnectWithoutPurchaseInput
    connect?: supplierWhereUniqueInput
  }

  export type itemsUpdateOneRequiredWithoutPurchaseNestedInput = {
    create?: XOR<itemsCreateWithoutPurchaseInput, itemsUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: itemsCreateOrConnectWithoutPurchaseInput
    upsert?: itemsUpsertWithoutPurchaseInput
    connect?: itemsWhereUniqueInput
    update?: XOR<XOR<itemsUpdateToOneWithWhereWithoutPurchaseInput, itemsUpdateWithoutPurchaseInput>, itemsUncheckedUpdateWithoutPurchaseInput>
  }

  export type supplierUpdateOneRequiredWithoutPurchaseNestedInput = {
    create?: XOR<supplierCreateWithoutPurchaseInput, supplierUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: supplierCreateOrConnectWithoutPurchaseInput
    upsert?: supplierUpsertWithoutPurchaseInput
    connect?: supplierWhereUniqueInput
    update?: XOR<XOR<supplierUpdateToOneWithWhereWithoutPurchaseInput, supplierUpdateWithoutPurchaseInput>, supplierUncheckedUpdateWithoutPurchaseInput>
  }

  export type itemsCreateNestedOneWithoutSalesInput = {
    create?: XOR<itemsCreateWithoutSalesInput, itemsUncheckedCreateWithoutSalesInput>
    connectOrCreate?: itemsCreateOrConnectWithoutSalesInput
    connect?: itemsWhereUniqueInput
  }

  export type customerCreateNestedOneWithoutSalesInput = {
    create?: XOR<customerCreateWithoutSalesInput, customerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: customerCreateOrConnectWithoutSalesInput
    connect?: customerWhereUniqueInput
  }

  export type itemsUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<itemsCreateWithoutSalesInput, itemsUncheckedCreateWithoutSalesInput>
    connectOrCreate?: itemsCreateOrConnectWithoutSalesInput
    upsert?: itemsUpsertWithoutSalesInput
    connect?: itemsWhereUniqueInput
    update?: XOR<XOR<itemsUpdateToOneWithWhereWithoutSalesInput, itemsUpdateWithoutSalesInput>, itemsUncheckedUpdateWithoutSalesInput>
  }

  export type customerUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<customerCreateWithoutSalesInput, customerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: customerCreateOrConnectWithoutSalesInput
    upsert?: customerUpsertWithoutSalesInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutSalesInput, customerUpdateWithoutSalesInput>, customerUncheckedUpdateWithoutSalesInput>
  }

  export type customerCreateNestedManyWithoutCustomerIdInput = {
    create?: XOR<customerCreateWithoutCustomerIdInput, customerUncheckedCreateWithoutCustomerIdInput> | customerCreateWithoutCustomerIdInput[] | customerUncheckedCreateWithoutCustomerIdInput[]
    connectOrCreate?: customerCreateOrConnectWithoutCustomerIdInput | customerCreateOrConnectWithoutCustomerIdInput[]
    createMany?: customerCreateManyCustomerIdInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type customerpaymentCreateNestedManyWithoutCustomertypeInput = {
    create?: XOR<customerpaymentCreateWithoutCustomertypeInput, customerpaymentUncheckedCreateWithoutCustomertypeInput> | customerpaymentCreateWithoutCustomertypeInput[] | customerpaymentUncheckedCreateWithoutCustomertypeInput[]
    connectOrCreate?: customerpaymentCreateOrConnectWithoutCustomertypeInput | customerpaymentCreateOrConnectWithoutCustomertypeInput[]
    createMany?: customerpaymentCreateManyCustomertypeInputEnvelope
    connect?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
  }

  export type customerUncheckedCreateNestedManyWithoutCustomerIdInput = {
    create?: XOR<customerCreateWithoutCustomerIdInput, customerUncheckedCreateWithoutCustomerIdInput> | customerCreateWithoutCustomerIdInput[] | customerUncheckedCreateWithoutCustomerIdInput[]
    connectOrCreate?: customerCreateOrConnectWithoutCustomerIdInput | customerCreateOrConnectWithoutCustomerIdInput[]
    createMany?: customerCreateManyCustomerIdInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type customerpaymentUncheckedCreateNestedManyWithoutCustomertypeInput = {
    create?: XOR<customerpaymentCreateWithoutCustomertypeInput, customerpaymentUncheckedCreateWithoutCustomertypeInput> | customerpaymentCreateWithoutCustomertypeInput[] | customerpaymentUncheckedCreateWithoutCustomertypeInput[]
    connectOrCreate?: customerpaymentCreateOrConnectWithoutCustomertypeInput | customerpaymentCreateOrConnectWithoutCustomertypeInput[]
    createMany?: customerpaymentCreateManyCustomertypeInputEnvelope
    connect?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
  }

  export type customerUpdateManyWithoutCustomerIdNestedInput = {
    create?: XOR<customerCreateWithoutCustomerIdInput, customerUncheckedCreateWithoutCustomerIdInput> | customerCreateWithoutCustomerIdInput[] | customerUncheckedCreateWithoutCustomerIdInput[]
    connectOrCreate?: customerCreateOrConnectWithoutCustomerIdInput | customerCreateOrConnectWithoutCustomerIdInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutCustomerIdInput | customerUpsertWithWhereUniqueWithoutCustomerIdInput[]
    createMany?: customerCreateManyCustomerIdInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutCustomerIdInput | customerUpdateWithWhereUniqueWithoutCustomerIdInput[]
    updateMany?: customerUpdateManyWithWhereWithoutCustomerIdInput | customerUpdateManyWithWhereWithoutCustomerIdInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type customerpaymentUpdateManyWithoutCustomertypeNestedInput = {
    create?: XOR<customerpaymentCreateWithoutCustomertypeInput, customerpaymentUncheckedCreateWithoutCustomertypeInput> | customerpaymentCreateWithoutCustomertypeInput[] | customerpaymentUncheckedCreateWithoutCustomertypeInput[]
    connectOrCreate?: customerpaymentCreateOrConnectWithoutCustomertypeInput | customerpaymentCreateOrConnectWithoutCustomertypeInput[]
    upsert?: customerpaymentUpsertWithWhereUniqueWithoutCustomertypeInput | customerpaymentUpsertWithWhereUniqueWithoutCustomertypeInput[]
    createMany?: customerpaymentCreateManyCustomertypeInputEnvelope
    set?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    disconnect?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    delete?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    connect?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    update?: customerpaymentUpdateWithWhereUniqueWithoutCustomertypeInput | customerpaymentUpdateWithWhereUniqueWithoutCustomertypeInput[]
    updateMany?: customerpaymentUpdateManyWithWhereWithoutCustomertypeInput | customerpaymentUpdateManyWithWhereWithoutCustomertypeInput[]
    deleteMany?: customerpaymentScalarWhereInput | customerpaymentScalarWhereInput[]
  }

  export type customerUncheckedUpdateManyWithoutCustomerIdNestedInput = {
    create?: XOR<customerCreateWithoutCustomerIdInput, customerUncheckedCreateWithoutCustomerIdInput> | customerCreateWithoutCustomerIdInput[] | customerUncheckedCreateWithoutCustomerIdInput[]
    connectOrCreate?: customerCreateOrConnectWithoutCustomerIdInput | customerCreateOrConnectWithoutCustomerIdInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutCustomerIdInput | customerUpsertWithWhereUniqueWithoutCustomerIdInput[]
    createMany?: customerCreateManyCustomerIdInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutCustomerIdInput | customerUpdateWithWhereUniqueWithoutCustomerIdInput[]
    updateMany?: customerUpdateManyWithWhereWithoutCustomerIdInput | customerUpdateManyWithWhereWithoutCustomerIdInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type customerpaymentUncheckedUpdateManyWithoutCustomertypeNestedInput = {
    create?: XOR<customerpaymentCreateWithoutCustomertypeInput, customerpaymentUncheckedCreateWithoutCustomertypeInput> | customerpaymentCreateWithoutCustomertypeInput[] | customerpaymentUncheckedCreateWithoutCustomertypeInput[]
    connectOrCreate?: customerpaymentCreateOrConnectWithoutCustomertypeInput | customerpaymentCreateOrConnectWithoutCustomertypeInput[]
    upsert?: customerpaymentUpsertWithWhereUniqueWithoutCustomertypeInput | customerpaymentUpsertWithWhereUniqueWithoutCustomertypeInput[]
    createMany?: customerpaymentCreateManyCustomertypeInputEnvelope
    set?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    disconnect?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    delete?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    connect?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    update?: customerpaymentUpdateWithWhereUniqueWithoutCustomertypeInput | customerpaymentUpdateWithWhereUniqueWithoutCustomertypeInput[]
    updateMany?: customerpaymentUpdateManyWithWhereWithoutCustomertypeInput | customerpaymentUpdateManyWithWhereWithoutCustomertypeInput[]
    deleteMany?: customerpaymentScalarWhereInput | customerpaymentScalarWhereInput[]
  }

  export type customertypeCreateNestedOneWithoutCustomerInput = {
    create?: XOR<customertypeCreateWithoutCustomerInput, customertypeUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: customertypeCreateOrConnectWithoutCustomerInput
    connect?: customertypeWhereUniqueInput
  }

  export type customerdetailsCreateNestedManyWithoutCustomerInput = {
    create?: XOR<customerdetailsCreateWithoutCustomerInput, customerdetailsUncheckedCreateWithoutCustomerInput> | customerdetailsCreateWithoutCustomerInput[] | customerdetailsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerdetailsCreateOrConnectWithoutCustomerInput | customerdetailsCreateOrConnectWithoutCustomerInput[]
    createMany?: customerdetailsCreateManyCustomerInputEnvelope
    connect?: customerdetailsWhereUniqueInput | customerdetailsWhereUniqueInput[]
  }

  export type salesCreateNestedManyWithoutCustomerInput = {
    create?: XOR<salesCreateWithoutCustomerInput, salesUncheckedCreateWithoutCustomerInput> | salesCreateWithoutCustomerInput[] | salesUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: salesCreateOrConnectWithoutCustomerInput | salesCreateOrConnectWithoutCustomerInput[]
    createMany?: salesCreateManyCustomerInputEnvelope
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
  }

  export type salescustomertrackerCreateNestedManyWithoutCustomerInput = {
    create?: XOR<salescustomertrackerCreateWithoutCustomerInput, salescustomertrackerUncheckedCreateWithoutCustomerInput> | salescustomertrackerCreateWithoutCustomerInput[] | salescustomertrackerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: salescustomertrackerCreateOrConnectWithoutCustomerInput | salescustomertrackerCreateOrConnectWithoutCustomerInput[]
    createMany?: salescustomertrackerCreateManyCustomerInputEnvelope
    connect?: salescustomertrackerWhereUniqueInput | salescustomertrackerWhereUniqueInput[]
  }

  export type customerledgerCreateNestedManyWithoutCustomerInput = {
    create?: XOR<customerledgerCreateWithoutCustomerInput, customerledgerUncheckedCreateWithoutCustomerInput> | customerledgerCreateWithoutCustomerInput[] | customerledgerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerledgerCreateOrConnectWithoutCustomerInput | customerledgerCreateOrConnectWithoutCustomerInput[]
    createMany?: customerledgerCreateManyCustomerInputEnvelope
    connect?: customerledgerWhereUniqueInput | customerledgerWhereUniqueInput[]
  }

  export type customerpaymentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<customerpaymentCreateWithoutCustomerInput, customerpaymentUncheckedCreateWithoutCustomerInput> | customerpaymentCreateWithoutCustomerInput[] | customerpaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerpaymentCreateOrConnectWithoutCustomerInput | customerpaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: customerpaymentCreateManyCustomerInputEnvelope
    connect?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
  }

  export type customerdetailsUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<customerdetailsCreateWithoutCustomerInput, customerdetailsUncheckedCreateWithoutCustomerInput> | customerdetailsCreateWithoutCustomerInput[] | customerdetailsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerdetailsCreateOrConnectWithoutCustomerInput | customerdetailsCreateOrConnectWithoutCustomerInput[]
    createMany?: customerdetailsCreateManyCustomerInputEnvelope
    connect?: customerdetailsWhereUniqueInput | customerdetailsWhereUniqueInput[]
  }

  export type salesUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<salesCreateWithoutCustomerInput, salesUncheckedCreateWithoutCustomerInput> | salesCreateWithoutCustomerInput[] | salesUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: salesCreateOrConnectWithoutCustomerInput | salesCreateOrConnectWithoutCustomerInput[]
    createMany?: salesCreateManyCustomerInputEnvelope
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
  }

  export type salescustomertrackerUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<salescustomertrackerCreateWithoutCustomerInput, salescustomertrackerUncheckedCreateWithoutCustomerInput> | salescustomertrackerCreateWithoutCustomerInput[] | salescustomertrackerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: salescustomertrackerCreateOrConnectWithoutCustomerInput | salescustomertrackerCreateOrConnectWithoutCustomerInput[]
    createMany?: salescustomertrackerCreateManyCustomerInputEnvelope
    connect?: salescustomertrackerWhereUniqueInput | salescustomertrackerWhereUniqueInput[]
  }

  export type customerledgerUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<customerledgerCreateWithoutCustomerInput, customerledgerUncheckedCreateWithoutCustomerInput> | customerledgerCreateWithoutCustomerInput[] | customerledgerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerledgerCreateOrConnectWithoutCustomerInput | customerledgerCreateOrConnectWithoutCustomerInput[]
    createMany?: customerledgerCreateManyCustomerInputEnvelope
    connect?: customerledgerWhereUniqueInput | customerledgerWhereUniqueInput[]
  }

  export type customerpaymentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<customerpaymentCreateWithoutCustomerInput, customerpaymentUncheckedCreateWithoutCustomerInput> | customerpaymentCreateWithoutCustomerInput[] | customerpaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerpaymentCreateOrConnectWithoutCustomerInput | customerpaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: customerpaymentCreateManyCustomerInputEnvelope
    connect?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
  }

  export type customertypeUpdateOneRequiredWithoutCustomerNestedInput = {
    create?: XOR<customertypeCreateWithoutCustomerInput, customertypeUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: customertypeCreateOrConnectWithoutCustomerInput
    upsert?: customertypeUpsertWithoutCustomerInput
    connect?: customertypeWhereUniqueInput
    update?: XOR<XOR<customertypeUpdateToOneWithWhereWithoutCustomerInput, customertypeUpdateWithoutCustomerInput>, customertypeUncheckedUpdateWithoutCustomerInput>
  }

  export type customerdetailsUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<customerdetailsCreateWithoutCustomerInput, customerdetailsUncheckedCreateWithoutCustomerInput> | customerdetailsCreateWithoutCustomerInput[] | customerdetailsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerdetailsCreateOrConnectWithoutCustomerInput | customerdetailsCreateOrConnectWithoutCustomerInput[]
    upsert?: customerdetailsUpsertWithWhereUniqueWithoutCustomerInput | customerdetailsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: customerdetailsCreateManyCustomerInputEnvelope
    set?: customerdetailsWhereUniqueInput | customerdetailsWhereUniqueInput[]
    disconnect?: customerdetailsWhereUniqueInput | customerdetailsWhereUniqueInput[]
    delete?: customerdetailsWhereUniqueInput | customerdetailsWhereUniqueInput[]
    connect?: customerdetailsWhereUniqueInput | customerdetailsWhereUniqueInput[]
    update?: customerdetailsUpdateWithWhereUniqueWithoutCustomerInput | customerdetailsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: customerdetailsUpdateManyWithWhereWithoutCustomerInput | customerdetailsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: customerdetailsScalarWhereInput | customerdetailsScalarWhereInput[]
  }

  export type salesUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<salesCreateWithoutCustomerInput, salesUncheckedCreateWithoutCustomerInput> | salesCreateWithoutCustomerInput[] | salesUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: salesCreateOrConnectWithoutCustomerInput | salesCreateOrConnectWithoutCustomerInput[]
    upsert?: salesUpsertWithWhereUniqueWithoutCustomerInput | salesUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: salesCreateManyCustomerInputEnvelope
    set?: salesWhereUniqueInput | salesWhereUniqueInput[]
    disconnect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    delete?: salesWhereUniqueInput | salesWhereUniqueInput[]
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    update?: salesUpdateWithWhereUniqueWithoutCustomerInput | salesUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: salesUpdateManyWithWhereWithoutCustomerInput | salesUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: salesScalarWhereInput | salesScalarWhereInput[]
  }

  export type salescustomertrackerUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<salescustomertrackerCreateWithoutCustomerInput, salescustomertrackerUncheckedCreateWithoutCustomerInput> | salescustomertrackerCreateWithoutCustomerInput[] | salescustomertrackerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: salescustomertrackerCreateOrConnectWithoutCustomerInput | salescustomertrackerCreateOrConnectWithoutCustomerInput[]
    upsert?: salescustomertrackerUpsertWithWhereUniqueWithoutCustomerInput | salescustomertrackerUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: salescustomertrackerCreateManyCustomerInputEnvelope
    set?: salescustomertrackerWhereUniqueInput | salescustomertrackerWhereUniqueInput[]
    disconnect?: salescustomertrackerWhereUniqueInput | salescustomertrackerWhereUniqueInput[]
    delete?: salescustomertrackerWhereUniqueInput | salescustomertrackerWhereUniqueInput[]
    connect?: salescustomertrackerWhereUniqueInput | salescustomertrackerWhereUniqueInput[]
    update?: salescustomertrackerUpdateWithWhereUniqueWithoutCustomerInput | salescustomertrackerUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: salescustomertrackerUpdateManyWithWhereWithoutCustomerInput | salescustomertrackerUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: salescustomertrackerScalarWhereInput | salescustomertrackerScalarWhereInput[]
  }

  export type customerledgerUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<customerledgerCreateWithoutCustomerInput, customerledgerUncheckedCreateWithoutCustomerInput> | customerledgerCreateWithoutCustomerInput[] | customerledgerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerledgerCreateOrConnectWithoutCustomerInput | customerledgerCreateOrConnectWithoutCustomerInput[]
    upsert?: customerledgerUpsertWithWhereUniqueWithoutCustomerInput | customerledgerUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: customerledgerCreateManyCustomerInputEnvelope
    set?: customerledgerWhereUniqueInput | customerledgerWhereUniqueInput[]
    disconnect?: customerledgerWhereUniqueInput | customerledgerWhereUniqueInput[]
    delete?: customerledgerWhereUniqueInput | customerledgerWhereUniqueInput[]
    connect?: customerledgerWhereUniqueInput | customerledgerWhereUniqueInput[]
    update?: customerledgerUpdateWithWhereUniqueWithoutCustomerInput | customerledgerUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: customerledgerUpdateManyWithWhereWithoutCustomerInput | customerledgerUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: customerledgerScalarWhereInput | customerledgerScalarWhereInput[]
  }

  export type customerpaymentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<customerpaymentCreateWithoutCustomerInput, customerpaymentUncheckedCreateWithoutCustomerInput> | customerpaymentCreateWithoutCustomerInput[] | customerpaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerpaymentCreateOrConnectWithoutCustomerInput | customerpaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: customerpaymentUpsertWithWhereUniqueWithoutCustomerInput | customerpaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: customerpaymentCreateManyCustomerInputEnvelope
    set?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    disconnect?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    delete?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    connect?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    update?: customerpaymentUpdateWithWhereUniqueWithoutCustomerInput | customerpaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: customerpaymentUpdateManyWithWhereWithoutCustomerInput | customerpaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: customerpaymentScalarWhereInput | customerpaymentScalarWhereInput[]
  }

  export type customerdetailsUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<customerdetailsCreateWithoutCustomerInput, customerdetailsUncheckedCreateWithoutCustomerInput> | customerdetailsCreateWithoutCustomerInput[] | customerdetailsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerdetailsCreateOrConnectWithoutCustomerInput | customerdetailsCreateOrConnectWithoutCustomerInput[]
    upsert?: customerdetailsUpsertWithWhereUniqueWithoutCustomerInput | customerdetailsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: customerdetailsCreateManyCustomerInputEnvelope
    set?: customerdetailsWhereUniqueInput | customerdetailsWhereUniqueInput[]
    disconnect?: customerdetailsWhereUniqueInput | customerdetailsWhereUniqueInput[]
    delete?: customerdetailsWhereUniqueInput | customerdetailsWhereUniqueInput[]
    connect?: customerdetailsWhereUniqueInput | customerdetailsWhereUniqueInput[]
    update?: customerdetailsUpdateWithWhereUniqueWithoutCustomerInput | customerdetailsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: customerdetailsUpdateManyWithWhereWithoutCustomerInput | customerdetailsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: customerdetailsScalarWhereInput | customerdetailsScalarWhereInput[]
  }

  export type salesUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<salesCreateWithoutCustomerInput, salesUncheckedCreateWithoutCustomerInput> | salesCreateWithoutCustomerInput[] | salesUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: salesCreateOrConnectWithoutCustomerInput | salesCreateOrConnectWithoutCustomerInput[]
    upsert?: salesUpsertWithWhereUniqueWithoutCustomerInput | salesUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: salesCreateManyCustomerInputEnvelope
    set?: salesWhereUniqueInput | salesWhereUniqueInput[]
    disconnect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    delete?: salesWhereUniqueInput | salesWhereUniqueInput[]
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    update?: salesUpdateWithWhereUniqueWithoutCustomerInput | salesUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: salesUpdateManyWithWhereWithoutCustomerInput | salesUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: salesScalarWhereInput | salesScalarWhereInput[]
  }

  export type salescustomertrackerUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<salescustomertrackerCreateWithoutCustomerInput, salescustomertrackerUncheckedCreateWithoutCustomerInput> | salescustomertrackerCreateWithoutCustomerInput[] | salescustomertrackerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: salescustomertrackerCreateOrConnectWithoutCustomerInput | salescustomertrackerCreateOrConnectWithoutCustomerInput[]
    upsert?: salescustomertrackerUpsertWithWhereUniqueWithoutCustomerInput | salescustomertrackerUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: salescustomertrackerCreateManyCustomerInputEnvelope
    set?: salescustomertrackerWhereUniqueInput | salescustomertrackerWhereUniqueInput[]
    disconnect?: salescustomertrackerWhereUniqueInput | salescustomertrackerWhereUniqueInput[]
    delete?: salescustomertrackerWhereUniqueInput | salescustomertrackerWhereUniqueInput[]
    connect?: salescustomertrackerWhereUniqueInput | salescustomertrackerWhereUniqueInput[]
    update?: salescustomertrackerUpdateWithWhereUniqueWithoutCustomerInput | salescustomertrackerUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: salescustomertrackerUpdateManyWithWhereWithoutCustomerInput | salescustomertrackerUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: salescustomertrackerScalarWhereInput | salescustomertrackerScalarWhereInput[]
  }

  export type customerledgerUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<customerledgerCreateWithoutCustomerInput, customerledgerUncheckedCreateWithoutCustomerInput> | customerledgerCreateWithoutCustomerInput[] | customerledgerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerledgerCreateOrConnectWithoutCustomerInput | customerledgerCreateOrConnectWithoutCustomerInput[]
    upsert?: customerledgerUpsertWithWhereUniqueWithoutCustomerInput | customerledgerUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: customerledgerCreateManyCustomerInputEnvelope
    set?: customerledgerWhereUniqueInput | customerledgerWhereUniqueInput[]
    disconnect?: customerledgerWhereUniqueInput | customerledgerWhereUniqueInput[]
    delete?: customerledgerWhereUniqueInput | customerledgerWhereUniqueInput[]
    connect?: customerledgerWhereUniqueInput | customerledgerWhereUniqueInput[]
    update?: customerledgerUpdateWithWhereUniqueWithoutCustomerInput | customerledgerUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: customerledgerUpdateManyWithWhereWithoutCustomerInput | customerledgerUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: customerledgerScalarWhereInput | customerledgerScalarWhereInput[]
  }

  export type customerpaymentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<customerpaymentCreateWithoutCustomerInput, customerpaymentUncheckedCreateWithoutCustomerInput> | customerpaymentCreateWithoutCustomerInput[] | customerpaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerpaymentCreateOrConnectWithoutCustomerInput | customerpaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: customerpaymentUpsertWithWhereUniqueWithoutCustomerInput | customerpaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: customerpaymentCreateManyCustomerInputEnvelope
    set?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    disconnect?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    delete?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    connect?: customerpaymentWhereUniqueInput | customerpaymentWhereUniqueInput[]
    update?: customerpaymentUpdateWithWhereUniqueWithoutCustomerInput | customerpaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: customerpaymentUpdateManyWithWhereWithoutCustomerInput | customerpaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: customerpaymentScalarWhereInput | customerpaymentScalarWhereInput[]
  }

  export type customerCreateNestedOneWithoutSalescustomertrackerInput = {
    create?: XOR<customerCreateWithoutSalescustomertrackerInput, customerUncheckedCreateWithoutSalescustomertrackerInput>
    connectOrCreate?: customerCreateOrConnectWithoutSalescustomertrackerInput
    connect?: customerWhereUniqueInput
  }

  export type customerUpdateOneRequiredWithoutSalescustomertrackerNestedInput = {
    create?: XOR<customerCreateWithoutSalescustomertrackerInput, customerUncheckedCreateWithoutSalescustomertrackerInput>
    connectOrCreate?: customerCreateOrConnectWithoutSalescustomertrackerInput
    upsert?: customerUpsertWithoutSalescustomertrackerInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutSalescustomertrackerInput, customerUpdateWithoutSalescustomertrackerInput>, customerUncheckedUpdateWithoutSalescustomertrackerInput>
  }

  export type customertypeCreateNestedOneWithoutCustomerpaymentInput = {
    create?: XOR<customertypeCreateWithoutCustomerpaymentInput, customertypeUncheckedCreateWithoutCustomerpaymentInput>
    connectOrCreate?: customertypeCreateOrConnectWithoutCustomerpaymentInput
    connect?: customertypeWhereUniqueInput
  }

  export type customerCreateNestedOneWithoutCustomerpaymentInput = {
    create?: XOR<customerCreateWithoutCustomerpaymentInput, customerUncheckedCreateWithoutCustomerpaymentInput>
    connectOrCreate?: customerCreateOrConnectWithoutCustomerpaymentInput
    connect?: customerWhereUniqueInput
  }

  export type customertypeUpdateOneRequiredWithoutCustomerpaymentNestedInput = {
    create?: XOR<customertypeCreateWithoutCustomerpaymentInput, customertypeUncheckedCreateWithoutCustomerpaymentInput>
    connectOrCreate?: customertypeCreateOrConnectWithoutCustomerpaymentInput
    upsert?: customertypeUpsertWithoutCustomerpaymentInput
    connect?: customertypeWhereUniqueInput
    update?: XOR<XOR<customertypeUpdateToOneWithWhereWithoutCustomerpaymentInput, customertypeUpdateWithoutCustomerpaymentInput>, customertypeUncheckedUpdateWithoutCustomerpaymentInput>
  }

  export type customerUpdateOneRequiredWithoutCustomerpaymentNestedInput = {
    create?: XOR<customerCreateWithoutCustomerpaymentInput, customerUncheckedCreateWithoutCustomerpaymentInput>
    connectOrCreate?: customerCreateOrConnectWithoutCustomerpaymentInput
    upsert?: customerUpsertWithoutCustomerpaymentInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutCustomerpaymentInput, customerUpdateWithoutCustomerpaymentInput>, customerUncheckedUpdateWithoutCustomerpaymentInput>
  }

  export type customerCreateNestedOneWithoutCustomerledgerInput = {
    create?: XOR<customerCreateWithoutCustomerledgerInput, customerUncheckedCreateWithoutCustomerledgerInput>
    connectOrCreate?: customerCreateOrConnectWithoutCustomerledgerInput
    connect?: customerWhereUniqueInput
  }

  export type customerUpdateOneRequiredWithoutCustomerledgerNestedInput = {
    create?: XOR<customerCreateWithoutCustomerledgerInput, customerUncheckedCreateWithoutCustomerledgerInput>
    connectOrCreate?: customerCreateOrConnectWithoutCustomerledgerInput
    upsert?: customerUpsertWithoutCustomerledgerInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutCustomerledgerInput, customerUpdateWithoutCustomerledgerInput>, customerUncheckedUpdateWithoutCustomerledgerInput>
  }

  export type supplierCreateNestedOneWithoutPurchasesuppliertrackInput = {
    create?: XOR<supplierCreateWithoutPurchasesuppliertrackInput, supplierUncheckedCreateWithoutPurchasesuppliertrackInput>
    connectOrCreate?: supplierCreateOrConnectWithoutPurchasesuppliertrackInput
    connect?: supplierWhereUniqueInput
  }

  export type supplierUpdateOneRequiredWithoutPurchasesuppliertrackNestedInput = {
    create?: XOR<supplierCreateWithoutPurchasesuppliertrackInput, supplierUncheckedCreateWithoutPurchasesuppliertrackInput>
    connectOrCreate?: supplierCreateOrConnectWithoutPurchasesuppliertrackInput
    upsert?: supplierUpsertWithoutPurchasesuppliertrackInput
    connect?: supplierWhereUniqueInput
    update?: XOR<XOR<supplierUpdateToOneWithWhereWithoutPurchasesuppliertrackInput, supplierUpdateWithoutPurchasesuppliertrackInput>, supplierUncheckedUpdateWithoutPurchasesuppliertrackInput>
  }

  export type supplierCreateNestedOneWithoutTransactionInput = {
    create?: XOR<supplierCreateWithoutTransactionInput, supplierUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: supplierCreateOrConnectWithoutTransactionInput
    connect?: supplierWhereUniqueInput
  }

  export type supplierUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<supplierCreateWithoutTransactionInput, supplierUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: supplierCreateOrConnectWithoutTransactionInput
    upsert?: supplierUpsertWithoutTransactionInput
    connect?: supplierWhereUniqueInput
    update?: XOR<XOR<supplierUpdateToOneWithWhereWithoutTransactionInput, supplierUpdateWithoutTransactionInput>, supplierUncheckedUpdateWithoutTransactionInput>
  }

  export type supplierCreateNestedOneWithoutSupplierledgerInput = {
    create?: XOR<supplierCreateWithoutSupplierledgerInput, supplierUncheckedCreateWithoutSupplierledgerInput>
    connectOrCreate?: supplierCreateOrConnectWithoutSupplierledgerInput
    connect?: supplierWhereUniqueInput
  }

  export type supplierUpdateOneRequiredWithoutSupplierledgerNestedInput = {
    create?: XOR<supplierCreateWithoutSupplierledgerInput, supplierUncheckedCreateWithoutSupplierledgerInput>
    connectOrCreate?: supplierCreateOrConnectWithoutSupplierledgerInput
    upsert?: supplierUpsertWithoutSupplierledgerInput
    connect?: supplierWhereUniqueInput
    update?: XOR<XOR<supplierUpdateToOneWithWhereWithoutSupplierledgerInput, supplierUpdateWithoutSupplierledgerInput>, supplierUncheckedUpdateWithoutSupplierledgerInput>
  }

  export type customerCreateNestedOneWithoutCustomerdetailsInput = {
    create?: XOR<customerCreateWithoutCustomerdetailsInput, customerUncheckedCreateWithoutCustomerdetailsInput>
    connectOrCreate?: customerCreateOrConnectWithoutCustomerdetailsInput
    connect?: customerWhereUniqueInput
  }

  export type customerUpdateOneRequiredWithoutCustomerdetailsNestedInput = {
    create?: XOR<customerCreateWithoutCustomerdetailsInput, customerUncheckedCreateWithoutCustomerdetailsInput>
    connectOrCreate?: customerCreateOrConnectWithoutCustomerdetailsInput
    upsert?: customerUpsertWithoutCustomerdetailsInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutCustomerdetailsInput, customerUpdateWithoutCustomerdetailsInput>, customerUncheckedUpdateWithoutCustomerdetailsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type itemsCreateWithoutItems_categoryInput = {
    items_name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsCreateNestedManyWithoutPurchaseitems_itemsInput
    Purchase?: purchaseCreateNestedManyWithoutPurchase_itemsInput
    sales?: salesCreateNestedManyWithoutItemsInput
    items_brands: brandsCreateNestedOneWithoutItemsInput
    items_units: unitsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutItems_categoryInput = {
    id?: number
    items_name: string
    description: string
    brandsId: number
    unitsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitems_itemsInput
    Purchase?: purchaseUncheckedCreateNestedManyWithoutPurchase_itemsInput
    sales?: salesUncheckedCreateNestedManyWithoutItemsInput
  }

  export type itemsCreateOrConnectWithoutItems_categoryInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutItems_categoryInput, itemsUncheckedCreateWithoutItems_categoryInput>
  }

  export type itemsCreateManyItems_categoryInputEnvelope = {
    data: itemsCreateManyItems_categoryInput | itemsCreateManyItems_categoryInput[]
    skipDuplicates?: boolean
  }

  export type itemsUpsertWithWhereUniqueWithoutItems_categoryInput = {
    where: itemsWhereUniqueInput
    update: XOR<itemsUpdateWithoutItems_categoryInput, itemsUncheckedUpdateWithoutItems_categoryInput>
    create: XOR<itemsCreateWithoutItems_categoryInput, itemsUncheckedCreateWithoutItems_categoryInput>
  }

  export type itemsUpdateWithWhereUniqueWithoutItems_categoryInput = {
    where: itemsWhereUniqueInput
    data: XOR<itemsUpdateWithoutItems_categoryInput, itemsUncheckedUpdateWithoutItems_categoryInput>
  }

  export type itemsUpdateManyWithWhereWithoutItems_categoryInput = {
    where: itemsScalarWhereInput
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyWithoutItems_categoryInput>
  }

  export type itemsScalarWhereInput = {
    AND?: itemsScalarWhereInput | itemsScalarWhereInput[]
    OR?: itemsScalarWhereInput[]
    NOT?: itemsScalarWhereInput | itemsScalarWhereInput[]
    id?: IntFilter<"items"> | number
    items_name?: StringFilter<"items"> | string
    categoryId?: IntFilter<"items"> | number
    description?: StringFilter<"items"> | string
    brandsId?: IntFilter<"items"> | number
    unitsId?: IntFilter<"items"> | number
    createdAt?: DateTimeFilter<"items"> | Date | string
    updatedAt?: DateTimeFilter<"items"> | Date | string
  }

  export type itemsCreateWithoutItems_unitsInput = {
    items_name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsCreateNestedManyWithoutPurchaseitems_itemsInput
    Purchase?: purchaseCreateNestedManyWithoutPurchase_itemsInput
    sales?: salesCreateNestedManyWithoutItemsInput
    items_category: categoryCreateNestedOneWithoutItemsInput
    items_brands: brandsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutItems_unitsInput = {
    id?: number
    items_name: string
    categoryId: number
    description: string
    brandsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitems_itemsInput
    Purchase?: purchaseUncheckedCreateNestedManyWithoutPurchase_itemsInput
    sales?: salesUncheckedCreateNestedManyWithoutItemsInput
  }

  export type itemsCreateOrConnectWithoutItems_unitsInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutItems_unitsInput, itemsUncheckedCreateWithoutItems_unitsInput>
  }

  export type itemsCreateManyItems_unitsInputEnvelope = {
    data: itemsCreateManyItems_unitsInput | itemsCreateManyItems_unitsInput[]
    skipDuplicates?: boolean
  }

  export type itemsUpsertWithWhereUniqueWithoutItems_unitsInput = {
    where: itemsWhereUniqueInput
    update: XOR<itemsUpdateWithoutItems_unitsInput, itemsUncheckedUpdateWithoutItems_unitsInput>
    create: XOR<itemsCreateWithoutItems_unitsInput, itemsUncheckedCreateWithoutItems_unitsInput>
  }

  export type itemsUpdateWithWhereUniqueWithoutItems_unitsInput = {
    where: itemsWhereUniqueInput
    data: XOR<itemsUpdateWithoutItems_unitsInput, itemsUncheckedUpdateWithoutItems_unitsInput>
  }

  export type itemsUpdateManyWithWhereWithoutItems_unitsInput = {
    where: itemsScalarWhereInput
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyWithoutItems_unitsInput>
  }

  export type itemsCreateWithoutItems_brandsInput = {
    items_name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsCreateNestedManyWithoutPurchaseitems_itemsInput
    Purchase?: purchaseCreateNestedManyWithoutPurchase_itemsInput
    sales?: salesCreateNestedManyWithoutItemsInput
    items_category: categoryCreateNestedOneWithoutItemsInput
    items_units: unitsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutItems_brandsInput = {
    id?: number
    items_name: string
    categoryId: number
    description: string
    unitsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitems_itemsInput
    Purchase?: purchaseUncheckedCreateNestedManyWithoutPurchase_itemsInput
    sales?: salesUncheckedCreateNestedManyWithoutItemsInput
  }

  export type itemsCreateOrConnectWithoutItems_brandsInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutItems_brandsInput, itemsUncheckedCreateWithoutItems_brandsInput>
  }

  export type itemsCreateManyItems_brandsInputEnvelope = {
    data: itemsCreateManyItems_brandsInput | itemsCreateManyItems_brandsInput[]
    skipDuplicates?: boolean
  }

  export type itemsUpsertWithWhereUniqueWithoutItems_brandsInput = {
    where: itemsWhereUniqueInput
    update: XOR<itemsUpdateWithoutItems_brandsInput, itemsUncheckedUpdateWithoutItems_brandsInput>
    create: XOR<itemsCreateWithoutItems_brandsInput, itemsUncheckedCreateWithoutItems_brandsInput>
  }

  export type itemsUpdateWithWhereUniqueWithoutItems_brandsInput = {
    where: itemsWhereUniqueInput
    data: XOR<itemsUpdateWithoutItems_brandsInput, itemsUncheckedUpdateWithoutItems_brandsInput>
  }

  export type itemsUpdateManyWithWhereWithoutItems_brandsInput = {
    where: itemsScalarWhereInput
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyWithoutItems_brandsInput>
  }

  export type purchaseitemsCreateWithoutPurchaseitems_itemsInput = {
    purchase_qty: number
    price_per_unit: number
    price_avg: number
    purchase_total: number
    subtotal_amount: number
    purchase_update_qty: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitemsId: supplierCreateNestedOneWithoutPurchaseitemsInput
  }

  export type purchaseitemsUncheckedCreateWithoutPurchaseitems_itemsInput = {
    id?: number
    supplierId: number
    purchase_qty: number
    price_per_unit: number
    price_avg: number
    purchase_total: number
    subtotal_amount: number
    purchase_update_qty: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseitemsCreateOrConnectWithoutPurchaseitems_itemsInput = {
    where: purchaseitemsWhereUniqueInput
    create: XOR<purchaseitemsCreateWithoutPurchaseitems_itemsInput, purchaseitemsUncheckedCreateWithoutPurchaseitems_itemsInput>
  }

  export type purchaseitemsCreateManyPurchaseitems_itemsInputEnvelope = {
    data: purchaseitemsCreateManyPurchaseitems_itemsInput | purchaseitemsCreateManyPurchaseitems_itemsInput[]
    skipDuplicates?: boolean
  }

  export type purchaseCreateWithoutPurchase_itemsInput = {
    purchase_qty: number
    price_per_unit: number
    purchase_total: number
    subtotal_amount: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: supplierCreateNestedOneWithoutPurchaseInput
  }

  export type purchaseUncheckedCreateWithoutPurchase_itemsInput = {
    id?: number
    supplierId: number
    purchase_qty: number
    price_per_unit: number
    purchase_total: number
    subtotal_amount: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseCreateOrConnectWithoutPurchase_itemsInput = {
    where: purchaseWhereUniqueInput
    create: XOR<purchaseCreateWithoutPurchase_itemsInput, purchaseUncheckedCreateWithoutPurchase_itemsInput>
  }

  export type purchaseCreateManyPurchase_itemsInputEnvelope = {
    data: purchaseCreateManyPurchase_itemsInput | purchaseCreateManyPurchase_itemsInput[]
    skipDuplicates?: boolean
  }

  export type salesCreateWithoutItemsInput = {
    sale_qty: number
    sales_price: number
    discount: number
    transport_cost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: customerCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateWithoutItemsInput = {
    id?: number
    customerId: number
    sale_qty: number
    sales_price: number
    discount: number
    transport_cost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesCreateOrConnectWithoutItemsInput = {
    where: salesWhereUniqueInput
    create: XOR<salesCreateWithoutItemsInput, salesUncheckedCreateWithoutItemsInput>
  }

  export type salesCreateManyItemsInputEnvelope = {
    data: salesCreateManyItemsInput | salesCreateManyItemsInput[]
    skipDuplicates?: boolean
  }

  export type categoryCreateWithoutItemsInput = {
    category_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type categoryUncheckedCreateWithoutItemsInput = {
    id?: number
    category_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type categoryCreateOrConnectWithoutItemsInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutItemsInput, categoryUncheckedCreateWithoutItemsInput>
  }

  export type brandsCreateWithoutItemsInput = {
    brands_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type brandsUncheckedCreateWithoutItemsInput = {
    id?: number
    brands_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type brandsCreateOrConnectWithoutItemsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutItemsInput, brandsUncheckedCreateWithoutItemsInput>
  }

  export type unitsCreateWithoutItemsInput = {
    units_name: string
    units_label: string
    relation: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type unitsUncheckedCreateWithoutItemsInput = {
    id?: number
    units_name: string
    units_label: string
    relation: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type unitsCreateOrConnectWithoutItemsInput = {
    where: unitsWhereUniqueInput
    create: XOR<unitsCreateWithoutItemsInput, unitsUncheckedCreateWithoutItemsInput>
  }

  export type purchaseitemsUpsertWithWhereUniqueWithoutPurchaseitems_itemsInput = {
    where: purchaseitemsWhereUniqueInput
    update: XOR<purchaseitemsUpdateWithoutPurchaseitems_itemsInput, purchaseitemsUncheckedUpdateWithoutPurchaseitems_itemsInput>
    create: XOR<purchaseitemsCreateWithoutPurchaseitems_itemsInput, purchaseitemsUncheckedCreateWithoutPurchaseitems_itemsInput>
  }

  export type purchaseitemsUpdateWithWhereUniqueWithoutPurchaseitems_itemsInput = {
    where: purchaseitemsWhereUniqueInput
    data: XOR<purchaseitemsUpdateWithoutPurchaseitems_itemsInput, purchaseitemsUncheckedUpdateWithoutPurchaseitems_itemsInput>
  }

  export type purchaseitemsUpdateManyWithWhereWithoutPurchaseitems_itemsInput = {
    where: purchaseitemsScalarWhereInput
    data: XOR<purchaseitemsUpdateManyMutationInput, purchaseitemsUncheckedUpdateManyWithoutPurchaseitems_itemsInput>
  }

  export type purchaseitemsScalarWhereInput = {
    AND?: purchaseitemsScalarWhereInput | purchaseitemsScalarWhereInput[]
    OR?: purchaseitemsScalarWhereInput[]
    NOT?: purchaseitemsScalarWhereInput | purchaseitemsScalarWhereInput[]
    id?: IntFilter<"purchaseitems"> | number
    itemId?: IntFilter<"purchaseitems"> | number
    supplierId?: IntFilter<"purchaseitems"> | number
    purchase_qty?: FloatFilter<"purchaseitems"> | number
    price_per_unit?: FloatFilter<"purchaseitems"> | number
    price_avg?: FloatFilter<"purchaseitems"> | number
    purchase_total?: FloatFilter<"purchaseitems"> | number
    subtotal_amount?: FloatFilter<"purchaseitems"> | number
    purchase_update_qty?: FloatFilter<"purchaseitems"> | number
    tax_Id?: IntFilter<"purchaseitems"> | number
    createdAt?: DateTimeFilter<"purchaseitems"> | Date | string
    updatedAt?: DateTimeFilter<"purchaseitems"> | Date | string
  }

  export type purchaseUpsertWithWhereUniqueWithoutPurchase_itemsInput = {
    where: purchaseWhereUniqueInput
    update: XOR<purchaseUpdateWithoutPurchase_itemsInput, purchaseUncheckedUpdateWithoutPurchase_itemsInput>
    create: XOR<purchaseCreateWithoutPurchase_itemsInput, purchaseUncheckedCreateWithoutPurchase_itemsInput>
  }

  export type purchaseUpdateWithWhereUniqueWithoutPurchase_itemsInput = {
    where: purchaseWhereUniqueInput
    data: XOR<purchaseUpdateWithoutPurchase_itemsInput, purchaseUncheckedUpdateWithoutPurchase_itemsInput>
  }

  export type purchaseUpdateManyWithWhereWithoutPurchase_itemsInput = {
    where: purchaseScalarWhereInput
    data: XOR<purchaseUpdateManyMutationInput, purchaseUncheckedUpdateManyWithoutPurchase_itemsInput>
  }

  export type purchaseScalarWhereInput = {
    AND?: purchaseScalarWhereInput | purchaseScalarWhereInput[]
    OR?: purchaseScalarWhereInput[]
    NOT?: purchaseScalarWhereInput | purchaseScalarWhereInput[]
    id?: IntFilter<"purchase"> | number
    itemId?: IntFilter<"purchase"> | number
    supplierId?: IntFilter<"purchase"> | number
    purchase_qty?: FloatFilter<"purchase"> | number
    price_per_unit?: FloatFilter<"purchase"> | number
    purchase_total?: FloatFilter<"purchase"> | number
    subtotal_amount?: FloatFilter<"purchase"> | number
    tax_Id?: IntFilter<"purchase"> | number
    createdAt?: DateTimeFilter<"purchase"> | Date | string
    updatedAt?: DateTimeFilter<"purchase"> | Date | string
  }

  export type salesUpsertWithWhereUniqueWithoutItemsInput = {
    where: salesWhereUniqueInput
    update: XOR<salesUpdateWithoutItemsInput, salesUncheckedUpdateWithoutItemsInput>
    create: XOR<salesCreateWithoutItemsInput, salesUncheckedCreateWithoutItemsInput>
  }

  export type salesUpdateWithWhereUniqueWithoutItemsInput = {
    where: salesWhereUniqueInput
    data: XOR<salesUpdateWithoutItemsInput, salesUncheckedUpdateWithoutItemsInput>
  }

  export type salesUpdateManyWithWhereWithoutItemsInput = {
    where: salesScalarWhereInput
    data: XOR<salesUpdateManyMutationInput, salesUncheckedUpdateManyWithoutItemsInput>
  }

  export type salesScalarWhereInput = {
    AND?: salesScalarWhereInput | salesScalarWhereInput[]
    OR?: salesScalarWhereInput[]
    NOT?: salesScalarWhereInput | salesScalarWhereInput[]
    id?: IntFilter<"sales"> | number
    itemId?: IntFilter<"sales"> | number
    customerId?: IntFilter<"sales"> | number
    sale_qty?: FloatFilter<"sales"> | number
    sales_price?: FloatFilter<"sales"> | number
    discount?: FloatFilter<"sales"> | number
    transport_cost?: FloatFilter<"sales"> | number
    createdAt?: DateTimeFilter<"sales"> | Date | string
    updatedAt?: DateTimeFilter<"sales"> | Date | string
  }

  export type categoryUpsertWithoutItemsInput = {
    update: XOR<categoryUpdateWithoutItemsInput, categoryUncheckedUpdateWithoutItemsInput>
    create: XOR<categoryCreateWithoutItemsInput, categoryUncheckedCreateWithoutItemsInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutItemsInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutItemsInput, categoryUncheckedUpdateWithoutItemsInput>
  }

  export type categoryUpdateWithoutItemsInput = {
    category_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoryUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandsUpsertWithoutItemsInput = {
    update: XOR<brandsUpdateWithoutItemsInput, brandsUncheckedUpdateWithoutItemsInput>
    create: XOR<brandsCreateWithoutItemsInput, brandsUncheckedCreateWithoutItemsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutItemsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutItemsInput, brandsUncheckedUpdateWithoutItemsInput>
  }

  export type brandsUpdateWithoutItemsInput = {
    brands_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandsUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brands_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unitsUpsertWithoutItemsInput = {
    update: XOR<unitsUpdateWithoutItemsInput, unitsUncheckedUpdateWithoutItemsInput>
    create: XOR<unitsCreateWithoutItemsInput, unitsUncheckedCreateWithoutItemsInput>
    where?: unitsWhereInput
  }

  export type unitsUpdateToOneWithWhereWithoutItemsInput = {
    where?: unitsWhereInput
    data: XOR<unitsUpdateWithoutItemsInput, unitsUncheckedUpdateWithoutItemsInput>
  }

  export type unitsUpdateWithoutItemsInput = {
    units_name?: StringFieldUpdateOperationsInput | string
    units_label?: StringFieldUpdateOperationsInput | string
    relation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unitsUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    units_name?: StringFieldUpdateOperationsInput | string
    units_label?: StringFieldUpdateOperationsInput | string
    relation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseitemsCreateWithoutPurchaseitemsIdInput = {
    purchase_qty: number
    price_per_unit: number
    price_avg: number
    purchase_total: number
    subtotal_amount: number
    purchase_update_qty: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems_items: itemsCreateNestedOneWithoutPurchaseitemsInput
  }

  export type purchaseitemsUncheckedCreateWithoutPurchaseitemsIdInput = {
    id?: number
    itemId: number
    purchase_qty: number
    price_per_unit: number
    price_avg: number
    purchase_total: number
    subtotal_amount: number
    purchase_update_qty: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseitemsCreateOrConnectWithoutPurchaseitemsIdInput = {
    where: purchaseitemsWhereUniqueInput
    create: XOR<purchaseitemsCreateWithoutPurchaseitemsIdInput, purchaseitemsUncheckedCreateWithoutPurchaseitemsIdInput>
  }

  export type purchaseitemsCreateManyPurchaseitemsIdInputEnvelope = {
    data: purchaseitemsCreateManyPurchaseitemsIdInput | purchaseitemsCreateManyPurchaseitemsIdInput[]
    skipDuplicates?: boolean
  }

  export type purchaseCreateWithoutSupplierInput = {
    purchase_qty: number
    price_per_unit: number
    purchase_total: number
    subtotal_amount: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase_items: itemsCreateNestedOneWithoutPurchaseInput
  }

  export type purchaseUncheckedCreateWithoutSupplierInput = {
    id?: number
    itemId: number
    purchase_qty: number
    price_per_unit: number
    purchase_total: number
    subtotal_amount: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseCreateOrConnectWithoutSupplierInput = {
    where: purchaseWhereUniqueInput
    create: XOR<purchaseCreateWithoutSupplierInput, purchaseUncheckedCreateWithoutSupplierInput>
  }

  export type purchaseCreateManySupplierInputEnvelope = {
    data: purchaseCreateManySupplierInput | purchaseCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type purchasesuppliertrackCreateWithoutSupplierInput = {
    curr_balance: number
    payment_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchasesuppliertrackUncheckedCreateWithoutSupplierInput = {
    id?: number
    curr_balance: number
    payment_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchasesuppliertrackCreateOrConnectWithoutSupplierInput = {
    where: purchasesuppliertrackWhereUniqueInput
    create: XOR<purchasesuppliertrackCreateWithoutSupplierInput, purchasesuppliertrackUncheckedCreateWithoutSupplierInput>
  }

  export type purchasesuppliertrackCreateManySupplierInputEnvelope = {
    data: purchasesuppliertrackCreateManySupplierInput | purchasesuppliertrackCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type transactionCreateWithoutSupplierInput = {
    balance: number
    transaction_type: string
    transaction_method: string
    payment: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionUncheckedCreateWithoutSupplierInput = {
    id?: number
    balance: number
    transaction_type: string
    transaction_method: string
    payment: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionCreateOrConnectWithoutSupplierInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionCreateWithoutSupplierInput, transactionUncheckedCreateWithoutSupplierInput>
  }

  export type transactionCreateManySupplierInputEnvelope = {
    data: transactionCreateManySupplierInput | transactionCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type supplierledgerCreateWithoutSupplierInput = {
    payment_type: string
    voucher_no: string
    credit: number
    debit: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type supplierledgerUncheckedCreateWithoutSupplierInput = {
    id?: number
    payment_type: string
    voucher_no: string
    credit: number
    debit: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type supplierledgerCreateOrConnectWithoutSupplierInput = {
    where: supplierledgerWhereUniqueInput
    create: XOR<supplierledgerCreateWithoutSupplierInput, supplierledgerUncheckedCreateWithoutSupplierInput>
  }

  export type supplierledgerCreateManySupplierInputEnvelope = {
    data: supplierledgerCreateManySupplierInput | supplierledgerCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type purchaseitemsUpsertWithWhereUniqueWithoutPurchaseitemsIdInput = {
    where: purchaseitemsWhereUniqueInput
    update: XOR<purchaseitemsUpdateWithoutPurchaseitemsIdInput, purchaseitemsUncheckedUpdateWithoutPurchaseitemsIdInput>
    create: XOR<purchaseitemsCreateWithoutPurchaseitemsIdInput, purchaseitemsUncheckedCreateWithoutPurchaseitemsIdInput>
  }

  export type purchaseitemsUpdateWithWhereUniqueWithoutPurchaseitemsIdInput = {
    where: purchaseitemsWhereUniqueInput
    data: XOR<purchaseitemsUpdateWithoutPurchaseitemsIdInput, purchaseitemsUncheckedUpdateWithoutPurchaseitemsIdInput>
  }

  export type purchaseitemsUpdateManyWithWhereWithoutPurchaseitemsIdInput = {
    where: purchaseitemsScalarWhereInput
    data: XOR<purchaseitemsUpdateManyMutationInput, purchaseitemsUncheckedUpdateManyWithoutPurchaseitemsIdInput>
  }

  export type purchaseUpsertWithWhereUniqueWithoutSupplierInput = {
    where: purchaseWhereUniqueInput
    update: XOR<purchaseUpdateWithoutSupplierInput, purchaseUncheckedUpdateWithoutSupplierInput>
    create: XOR<purchaseCreateWithoutSupplierInput, purchaseUncheckedCreateWithoutSupplierInput>
  }

  export type purchaseUpdateWithWhereUniqueWithoutSupplierInput = {
    where: purchaseWhereUniqueInput
    data: XOR<purchaseUpdateWithoutSupplierInput, purchaseUncheckedUpdateWithoutSupplierInput>
  }

  export type purchaseUpdateManyWithWhereWithoutSupplierInput = {
    where: purchaseScalarWhereInput
    data: XOR<purchaseUpdateManyMutationInput, purchaseUncheckedUpdateManyWithoutSupplierInput>
  }

  export type purchasesuppliertrackUpsertWithWhereUniqueWithoutSupplierInput = {
    where: purchasesuppliertrackWhereUniqueInput
    update: XOR<purchasesuppliertrackUpdateWithoutSupplierInput, purchasesuppliertrackUncheckedUpdateWithoutSupplierInput>
    create: XOR<purchasesuppliertrackCreateWithoutSupplierInput, purchasesuppliertrackUncheckedCreateWithoutSupplierInput>
  }

  export type purchasesuppliertrackUpdateWithWhereUniqueWithoutSupplierInput = {
    where: purchasesuppliertrackWhereUniqueInput
    data: XOR<purchasesuppliertrackUpdateWithoutSupplierInput, purchasesuppliertrackUncheckedUpdateWithoutSupplierInput>
  }

  export type purchasesuppliertrackUpdateManyWithWhereWithoutSupplierInput = {
    where: purchasesuppliertrackScalarWhereInput
    data: XOR<purchasesuppliertrackUpdateManyMutationInput, purchasesuppliertrackUncheckedUpdateManyWithoutSupplierInput>
  }

  export type purchasesuppliertrackScalarWhereInput = {
    AND?: purchasesuppliertrackScalarWhereInput | purchasesuppliertrackScalarWhereInput[]
    OR?: purchasesuppliertrackScalarWhereInput[]
    NOT?: purchasesuppliertrackScalarWhereInput | purchasesuppliertrackScalarWhereInput[]
    id?: IntFilter<"purchasesuppliertrack"> | number
    supplierId?: IntFilter<"purchasesuppliertrack"> | number
    curr_balance?: FloatFilter<"purchasesuppliertrack"> | number
    payment_type?: StringFilter<"purchasesuppliertrack"> | string
    createdAt?: DateTimeFilter<"purchasesuppliertrack"> | Date | string
    updatedAt?: DateTimeFilter<"purchasesuppliertrack"> | Date | string
  }

  export type transactionUpsertWithWhereUniqueWithoutSupplierInput = {
    where: transactionWhereUniqueInput
    update: XOR<transactionUpdateWithoutSupplierInput, transactionUncheckedUpdateWithoutSupplierInput>
    create: XOR<transactionCreateWithoutSupplierInput, transactionUncheckedCreateWithoutSupplierInput>
  }

  export type transactionUpdateWithWhereUniqueWithoutSupplierInput = {
    where: transactionWhereUniqueInput
    data: XOR<transactionUpdateWithoutSupplierInput, transactionUncheckedUpdateWithoutSupplierInput>
  }

  export type transactionUpdateManyWithWhereWithoutSupplierInput = {
    where: transactionScalarWhereInput
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyWithoutSupplierInput>
  }

  export type transactionScalarWhereInput = {
    AND?: transactionScalarWhereInput | transactionScalarWhereInput[]
    OR?: transactionScalarWhereInput[]
    NOT?: transactionScalarWhereInput | transactionScalarWhereInput[]
    id?: IntFilter<"transaction"> | number
    supplierId?: IntFilter<"transaction"> | number
    balance?: FloatFilter<"transaction"> | number
    transaction_type?: StringFilter<"transaction"> | string
    transaction_method?: StringFilter<"transaction"> | string
    payment?: FloatFilter<"transaction"> | number
    curr_balance?: FloatFilter<"transaction"> | number
    createdAt?: DateTimeFilter<"transaction"> | Date | string
    updatedAt?: DateTimeFilter<"transaction"> | Date | string
  }

  export type supplierledgerUpsertWithWhereUniqueWithoutSupplierInput = {
    where: supplierledgerWhereUniqueInput
    update: XOR<supplierledgerUpdateWithoutSupplierInput, supplierledgerUncheckedUpdateWithoutSupplierInput>
    create: XOR<supplierledgerCreateWithoutSupplierInput, supplierledgerUncheckedCreateWithoutSupplierInput>
  }

  export type supplierledgerUpdateWithWhereUniqueWithoutSupplierInput = {
    where: supplierledgerWhereUniqueInput
    data: XOR<supplierledgerUpdateWithoutSupplierInput, supplierledgerUncheckedUpdateWithoutSupplierInput>
  }

  export type supplierledgerUpdateManyWithWhereWithoutSupplierInput = {
    where: supplierledgerScalarWhereInput
    data: XOR<supplierledgerUpdateManyMutationInput, supplierledgerUncheckedUpdateManyWithoutSupplierInput>
  }

  export type supplierledgerScalarWhereInput = {
    AND?: supplierledgerScalarWhereInput | supplierledgerScalarWhereInput[]
    OR?: supplierledgerScalarWhereInput[]
    NOT?: supplierledgerScalarWhereInput | supplierledgerScalarWhereInput[]
    id?: IntFilter<"supplierledger"> | number
    supplierId?: IntFilter<"supplierledger"> | number
    payment_type?: StringFilter<"supplierledger"> | string
    voucher_no?: StringFilter<"supplierledger"> | string
    credit?: FloatFilter<"supplierledger"> | number
    debit?: FloatFilter<"supplierledger"> | number
    balance?: FloatFilter<"supplierledger"> | number
    createdAt?: DateTimeFilter<"supplierledger"> | Date | string
    updatedAt?: DateTimeFilter<"supplierledger"> | Date | string
  }

  export type itemsCreateWithoutPurchaseitemsInput = {
    items_name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Purchase?: purchaseCreateNestedManyWithoutPurchase_itemsInput
    sales?: salesCreateNestedManyWithoutItemsInput
    items_category: categoryCreateNestedOneWithoutItemsInput
    items_brands: brandsCreateNestedOneWithoutItemsInput
    items_units: unitsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutPurchaseitemsInput = {
    id?: number
    items_name: string
    categoryId: number
    description: string
    brandsId: number
    unitsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Purchase?: purchaseUncheckedCreateNestedManyWithoutPurchase_itemsInput
    sales?: salesUncheckedCreateNestedManyWithoutItemsInput
  }

  export type itemsCreateOrConnectWithoutPurchaseitemsInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutPurchaseitemsInput, itemsUncheckedCreateWithoutPurchaseitemsInput>
  }

  export type supplierCreateWithoutPurchaseitemsInput = {
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Purchase?: purchaseCreateNestedManyWithoutSupplierInput
    purchasesuppliertrack?: purchasesuppliertrackCreateNestedManyWithoutSupplierInput
    transaction?: transactionCreateNestedManyWithoutSupplierInput
    supplierledger?: supplierledgerCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateWithoutPurchaseitemsInput = {
    id?: number
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Purchase?: purchaseUncheckedCreateNestedManyWithoutSupplierInput
    purchasesuppliertrack?: purchasesuppliertrackUncheckedCreateNestedManyWithoutSupplierInput
    transaction?: transactionUncheckedCreateNestedManyWithoutSupplierInput
    supplierledger?: supplierledgerUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierCreateOrConnectWithoutPurchaseitemsInput = {
    where: supplierWhereUniqueInput
    create: XOR<supplierCreateWithoutPurchaseitemsInput, supplierUncheckedCreateWithoutPurchaseitemsInput>
  }

  export type itemsUpsertWithoutPurchaseitemsInput = {
    update: XOR<itemsUpdateWithoutPurchaseitemsInput, itemsUncheckedUpdateWithoutPurchaseitemsInput>
    create: XOR<itemsCreateWithoutPurchaseitemsInput, itemsUncheckedCreateWithoutPurchaseitemsInput>
    where?: itemsWhereInput
  }

  export type itemsUpdateToOneWithWhereWithoutPurchaseitemsInput = {
    where?: itemsWhereInput
    data: XOR<itemsUpdateWithoutPurchaseitemsInput, itemsUncheckedUpdateWithoutPurchaseitemsInput>
  }

  export type itemsUpdateWithoutPurchaseitemsInput = {
    items_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Purchase?: purchaseUpdateManyWithoutPurchase_itemsNestedInput
    sales?: salesUpdateManyWithoutItemsNestedInput
    items_category?: categoryUpdateOneRequiredWithoutItemsNestedInput
    items_brands?: brandsUpdateOneRequiredWithoutItemsNestedInput
    items_units?: unitsUpdateOneRequiredWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutPurchaseitemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    items_name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    brandsId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Purchase?: purchaseUncheckedUpdateManyWithoutPurchase_itemsNestedInput
    sales?: salesUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type supplierUpsertWithoutPurchaseitemsInput = {
    update: XOR<supplierUpdateWithoutPurchaseitemsInput, supplierUncheckedUpdateWithoutPurchaseitemsInput>
    create: XOR<supplierCreateWithoutPurchaseitemsInput, supplierUncheckedCreateWithoutPurchaseitemsInput>
    where?: supplierWhereInput
  }

  export type supplierUpdateToOneWithWhereWithoutPurchaseitemsInput = {
    where?: supplierWhereInput
    data: XOR<supplierUpdateWithoutPurchaseitemsInput, supplierUncheckedUpdateWithoutPurchaseitemsInput>
  }

  export type supplierUpdateWithoutPurchaseitemsInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Purchase?: purchaseUpdateManyWithoutSupplierNestedInput
    purchasesuppliertrack?: purchasesuppliertrackUpdateManyWithoutSupplierNestedInput
    transaction?: transactionUpdateManyWithoutSupplierNestedInput
    supplierledger?: supplierledgerUpdateManyWithoutSupplierNestedInput
  }

  export type supplierUncheckedUpdateWithoutPurchaseitemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Purchase?: purchaseUncheckedUpdateManyWithoutSupplierNestedInput
    purchasesuppliertrack?: purchasesuppliertrackUncheckedUpdateManyWithoutSupplierNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutSupplierNestedInput
    supplierledger?: supplierledgerUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type itemsCreateWithoutPurchaseInput = {
    items_name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsCreateNestedManyWithoutPurchaseitems_itemsInput
    sales?: salesCreateNestedManyWithoutItemsInput
    items_category: categoryCreateNestedOneWithoutItemsInput
    items_brands: brandsCreateNestedOneWithoutItemsInput
    items_units: unitsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutPurchaseInput = {
    id?: number
    items_name: string
    categoryId: number
    description: string
    brandsId: number
    unitsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitems_itemsInput
    sales?: salesUncheckedCreateNestedManyWithoutItemsInput
  }

  export type itemsCreateOrConnectWithoutPurchaseInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutPurchaseInput, itemsUncheckedCreateWithoutPurchaseInput>
  }

  export type supplierCreateWithoutPurchaseInput = {
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsCreateNestedManyWithoutPurchaseitemsIdInput
    purchasesuppliertrack?: purchasesuppliertrackCreateNestedManyWithoutSupplierInput
    transaction?: transactionCreateNestedManyWithoutSupplierInput
    supplierledger?: supplierledgerCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateWithoutPurchaseInput = {
    id?: number
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitemsIdInput
    purchasesuppliertrack?: purchasesuppliertrackUncheckedCreateNestedManyWithoutSupplierInput
    transaction?: transactionUncheckedCreateNestedManyWithoutSupplierInput
    supplierledger?: supplierledgerUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierCreateOrConnectWithoutPurchaseInput = {
    where: supplierWhereUniqueInput
    create: XOR<supplierCreateWithoutPurchaseInput, supplierUncheckedCreateWithoutPurchaseInput>
  }

  export type itemsUpsertWithoutPurchaseInput = {
    update: XOR<itemsUpdateWithoutPurchaseInput, itemsUncheckedUpdateWithoutPurchaseInput>
    create: XOR<itemsCreateWithoutPurchaseInput, itemsUncheckedCreateWithoutPurchaseInput>
    where?: itemsWhereInput
  }

  export type itemsUpdateToOneWithWhereWithoutPurchaseInput = {
    where?: itemsWhereInput
    data: XOR<itemsUpdateWithoutPurchaseInput, itemsUncheckedUpdateWithoutPurchaseInput>
  }

  export type itemsUpdateWithoutPurchaseInput = {
    items_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUpdateManyWithoutPurchaseitems_itemsNestedInput
    sales?: salesUpdateManyWithoutItemsNestedInput
    items_category?: categoryUpdateOneRequiredWithoutItemsNestedInput
    items_brands?: brandsUpdateOneRequiredWithoutItemsNestedInput
    items_units?: unitsUpdateOneRequiredWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    items_name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    brandsId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUncheckedUpdateManyWithoutPurchaseitems_itemsNestedInput
    sales?: salesUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type supplierUpsertWithoutPurchaseInput = {
    update: XOR<supplierUpdateWithoutPurchaseInput, supplierUncheckedUpdateWithoutPurchaseInput>
    create: XOR<supplierCreateWithoutPurchaseInput, supplierUncheckedCreateWithoutPurchaseInput>
    where?: supplierWhereInput
  }

  export type supplierUpdateToOneWithWhereWithoutPurchaseInput = {
    where?: supplierWhereInput
    data: XOR<supplierUpdateWithoutPurchaseInput, supplierUncheckedUpdateWithoutPurchaseInput>
  }

  export type supplierUpdateWithoutPurchaseInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUpdateManyWithoutPurchaseitemsIdNestedInput
    purchasesuppliertrack?: purchasesuppliertrackUpdateManyWithoutSupplierNestedInput
    transaction?: transactionUpdateManyWithoutSupplierNestedInput
    supplierledger?: supplierledgerUpdateManyWithoutSupplierNestedInput
  }

  export type supplierUncheckedUpdateWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUncheckedUpdateManyWithoutPurchaseitemsIdNestedInput
    purchasesuppliertrack?: purchasesuppliertrackUncheckedUpdateManyWithoutSupplierNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutSupplierNestedInput
    supplierledger?: supplierledgerUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type itemsCreateWithoutSalesInput = {
    items_name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsCreateNestedManyWithoutPurchaseitems_itemsInput
    Purchase?: purchaseCreateNestedManyWithoutPurchase_itemsInput
    items_category: categoryCreateNestedOneWithoutItemsInput
    items_brands: brandsCreateNestedOneWithoutItemsInput
    items_units: unitsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutSalesInput = {
    id?: number
    items_name: string
    categoryId: number
    description: string
    brandsId: number
    unitsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitems_itemsInput
    Purchase?: purchaseUncheckedCreateNestedManyWithoutPurchase_itemsInput
  }

  export type itemsCreateOrConnectWithoutSalesInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutSalesInput, itemsUncheckedCreateWithoutSalesInput>
  }

  export type customerCreateWithoutSalesInput = {
    customer_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: customertypeCreateNestedOneWithoutCustomerInput
    customerdetails?: customerdetailsCreateNestedManyWithoutCustomerInput
    salescustomertracker?: salescustomertrackerCreateNestedManyWithoutCustomerInput
    customerledger?: customerledgerCreateNestedManyWithoutCustomerInput
    customerpayment?: customerpaymentCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutSalesInput = {
    id?: number
    customer_name: string
    customertypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customerdetails?: customerdetailsUncheckedCreateNestedManyWithoutCustomerInput
    salescustomertracker?: salescustomertrackerUncheckedCreateNestedManyWithoutCustomerInput
    customerledger?: customerledgerUncheckedCreateNestedManyWithoutCustomerInput
    customerpayment?: customerpaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutSalesInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutSalesInput, customerUncheckedCreateWithoutSalesInput>
  }

  export type itemsUpsertWithoutSalesInput = {
    update: XOR<itemsUpdateWithoutSalesInput, itemsUncheckedUpdateWithoutSalesInput>
    create: XOR<itemsCreateWithoutSalesInput, itemsUncheckedCreateWithoutSalesInput>
    where?: itemsWhereInput
  }

  export type itemsUpdateToOneWithWhereWithoutSalesInput = {
    where?: itemsWhereInput
    data: XOR<itemsUpdateWithoutSalesInput, itemsUncheckedUpdateWithoutSalesInput>
  }

  export type itemsUpdateWithoutSalesInput = {
    items_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUpdateManyWithoutPurchaseitems_itemsNestedInput
    Purchase?: purchaseUpdateManyWithoutPurchase_itemsNestedInput
    items_category?: categoryUpdateOneRequiredWithoutItemsNestedInput
    items_brands?: brandsUpdateOneRequiredWithoutItemsNestedInput
    items_units?: unitsUpdateOneRequiredWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    items_name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    brandsId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUncheckedUpdateManyWithoutPurchaseitems_itemsNestedInput
    Purchase?: purchaseUncheckedUpdateManyWithoutPurchase_itemsNestedInput
  }

  export type customerUpsertWithoutSalesInput = {
    update: XOR<customerUpdateWithoutSalesInput, customerUncheckedUpdateWithoutSalesInput>
    create: XOR<customerCreateWithoutSalesInput, customerUncheckedCreateWithoutSalesInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutSalesInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutSalesInput, customerUncheckedUpdateWithoutSalesInput>
  }

  export type customerUpdateWithoutSalesInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: customertypeUpdateOneRequiredWithoutCustomerNestedInput
    customerdetails?: customerdetailsUpdateManyWithoutCustomerNestedInput
    salescustomertracker?: salescustomertrackerUpdateManyWithoutCustomerNestedInput
    customerledger?: customerledgerUpdateManyWithoutCustomerNestedInput
    customerpayment?: customerpaymentUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    customertypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerdetails?: customerdetailsUncheckedUpdateManyWithoutCustomerNestedInput
    salescustomertracker?: salescustomertrackerUncheckedUpdateManyWithoutCustomerNestedInput
    customerledger?: customerledgerUncheckedUpdateManyWithoutCustomerNestedInput
    customerpayment?: customerpaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerCreateWithoutCustomerIdInput = {
    customer_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerdetails?: customerdetailsCreateNestedManyWithoutCustomerInput
    sales?: salesCreateNestedManyWithoutCustomerInput
    salescustomertracker?: salescustomertrackerCreateNestedManyWithoutCustomerInput
    customerledger?: customerledgerCreateNestedManyWithoutCustomerInput
    customerpayment?: customerpaymentCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutCustomerIdInput = {
    id?: number
    customer_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerdetails?: customerdetailsUncheckedCreateNestedManyWithoutCustomerInput
    sales?: salesUncheckedCreateNestedManyWithoutCustomerInput
    salescustomertracker?: salescustomertrackerUncheckedCreateNestedManyWithoutCustomerInput
    customerledger?: customerledgerUncheckedCreateNestedManyWithoutCustomerInput
    customerpayment?: customerpaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutCustomerIdInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutCustomerIdInput, customerUncheckedCreateWithoutCustomerIdInput>
  }

  export type customerCreateManyCustomerIdInputEnvelope = {
    data: customerCreateManyCustomerIdInput | customerCreateManyCustomerIdInput[]
    skipDuplicates?: boolean
  }

  export type customerpaymentCreateWithoutCustomertypeInput = {
    balance: number
    transaction_type: string
    collection_method: string
    paid: number
    remission: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: customerCreateNestedOneWithoutCustomerpaymentInput
  }

  export type customerpaymentUncheckedCreateWithoutCustomertypeInput = {
    id?: number
    customerId: number
    balance: number
    transaction_type: string
    collection_method: string
    paid: number
    remission: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerpaymentCreateOrConnectWithoutCustomertypeInput = {
    where: customerpaymentWhereUniqueInput
    create: XOR<customerpaymentCreateWithoutCustomertypeInput, customerpaymentUncheckedCreateWithoutCustomertypeInput>
  }

  export type customerpaymentCreateManyCustomertypeInputEnvelope = {
    data: customerpaymentCreateManyCustomertypeInput | customerpaymentCreateManyCustomertypeInput[]
    skipDuplicates?: boolean
  }

  export type customerUpsertWithWhereUniqueWithoutCustomerIdInput = {
    where: customerWhereUniqueInput
    update: XOR<customerUpdateWithoutCustomerIdInput, customerUncheckedUpdateWithoutCustomerIdInput>
    create: XOR<customerCreateWithoutCustomerIdInput, customerUncheckedCreateWithoutCustomerIdInput>
  }

  export type customerUpdateWithWhereUniqueWithoutCustomerIdInput = {
    where: customerWhereUniqueInput
    data: XOR<customerUpdateWithoutCustomerIdInput, customerUncheckedUpdateWithoutCustomerIdInput>
  }

  export type customerUpdateManyWithWhereWithoutCustomerIdInput = {
    where: customerScalarWhereInput
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyWithoutCustomerIdInput>
  }

  export type customerScalarWhereInput = {
    AND?: customerScalarWhereInput | customerScalarWhereInput[]
    OR?: customerScalarWhereInput[]
    NOT?: customerScalarWhereInput | customerScalarWhereInput[]
    id?: IntFilter<"customer"> | number
    customer_name?: StringFilter<"customer"> | string
    customertypeId?: IntFilter<"customer"> | number
    createdAt?: DateTimeFilter<"customer"> | Date | string
    updatedAt?: DateTimeFilter<"customer"> | Date | string
  }

  export type customerpaymentUpsertWithWhereUniqueWithoutCustomertypeInput = {
    where: customerpaymentWhereUniqueInput
    update: XOR<customerpaymentUpdateWithoutCustomertypeInput, customerpaymentUncheckedUpdateWithoutCustomertypeInput>
    create: XOR<customerpaymentCreateWithoutCustomertypeInput, customerpaymentUncheckedCreateWithoutCustomertypeInput>
  }

  export type customerpaymentUpdateWithWhereUniqueWithoutCustomertypeInput = {
    where: customerpaymentWhereUniqueInput
    data: XOR<customerpaymentUpdateWithoutCustomertypeInput, customerpaymentUncheckedUpdateWithoutCustomertypeInput>
  }

  export type customerpaymentUpdateManyWithWhereWithoutCustomertypeInput = {
    where: customerpaymentScalarWhereInput
    data: XOR<customerpaymentUpdateManyMutationInput, customerpaymentUncheckedUpdateManyWithoutCustomertypeInput>
  }

  export type customerpaymentScalarWhereInput = {
    AND?: customerpaymentScalarWhereInput | customerpaymentScalarWhereInput[]
    OR?: customerpaymentScalarWhereInput[]
    NOT?: customerpaymentScalarWhereInput | customerpaymentScalarWhereInput[]
    id?: IntFilter<"customerpayment"> | number
    customertypeId?: IntFilter<"customerpayment"> | number
    customerId?: IntFilter<"customerpayment"> | number
    balance?: FloatFilter<"customerpayment"> | number
    transaction_type?: StringFilter<"customerpayment"> | string
    collection_method?: StringFilter<"customerpayment"> | string
    paid?: FloatFilter<"customerpayment"> | number
    remission?: FloatFilter<"customerpayment"> | number
    curr_balance?: FloatFilter<"customerpayment"> | number
    createdAt?: DateTimeFilter<"customerpayment"> | Date | string
    updatedAt?: DateTimeFilter<"customerpayment"> | Date | string
  }

  export type customertypeCreateWithoutCustomerInput = {
    type_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerpayment?: customerpaymentCreateNestedManyWithoutCustomertypeInput
  }

  export type customertypeUncheckedCreateWithoutCustomerInput = {
    id?: number
    type_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerpayment?: customerpaymentUncheckedCreateNestedManyWithoutCustomertypeInput
  }

  export type customertypeCreateOrConnectWithoutCustomerInput = {
    where: customertypeWhereUniqueInput
    create: XOR<customertypeCreateWithoutCustomerInput, customertypeUncheckedCreateWithoutCustomerInput>
  }

  export type customerdetailsCreateWithoutCustomerInput = {
    customer_name: string
    mob_no: string
    address: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerdetailsUncheckedCreateWithoutCustomerInput = {
    id?: number
    customer_name: string
    mob_no: string
    address: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerdetailsCreateOrConnectWithoutCustomerInput = {
    where: customerdetailsWhereUniqueInput
    create: XOR<customerdetailsCreateWithoutCustomerInput, customerdetailsUncheckedCreateWithoutCustomerInput>
  }

  export type customerdetailsCreateManyCustomerInputEnvelope = {
    data: customerdetailsCreateManyCustomerInput | customerdetailsCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type salesCreateWithoutCustomerInput = {
    sale_qty: number
    sales_price: number
    discount: number
    transport_cost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items: itemsCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateWithoutCustomerInput = {
    id?: number
    itemId: number
    sale_qty: number
    sales_price: number
    discount: number
    transport_cost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesCreateOrConnectWithoutCustomerInput = {
    where: salesWhereUniqueInput
    create: XOR<salesCreateWithoutCustomerInput, salesUncheckedCreateWithoutCustomerInput>
  }

  export type salesCreateManyCustomerInputEnvelope = {
    data: salesCreateManyCustomerInput | salesCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type salescustomertrackerCreateWithoutCustomerInput = {
    curr_balance: number
    payment_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salescustomertrackerUncheckedCreateWithoutCustomerInput = {
    id?: number
    curr_balance: number
    payment_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salescustomertrackerCreateOrConnectWithoutCustomerInput = {
    where: salescustomertrackerWhereUniqueInput
    create: XOR<salescustomertrackerCreateWithoutCustomerInput, salescustomertrackerUncheckedCreateWithoutCustomerInput>
  }

  export type salescustomertrackerCreateManyCustomerInputEnvelope = {
    data: salescustomertrackerCreateManyCustomerInput | salescustomertrackerCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type customerledgerCreateWithoutCustomerInput = {
    payment_type: string
    credit: number
    debit: number
    balance: number
    voucher_no: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerledgerUncheckedCreateWithoutCustomerInput = {
    id?: number
    payment_type: string
    credit: number
    debit: number
    balance: number
    voucher_no: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerledgerCreateOrConnectWithoutCustomerInput = {
    where: customerledgerWhereUniqueInput
    create: XOR<customerledgerCreateWithoutCustomerInput, customerledgerUncheckedCreateWithoutCustomerInput>
  }

  export type customerledgerCreateManyCustomerInputEnvelope = {
    data: customerledgerCreateManyCustomerInput | customerledgerCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type customerpaymentCreateWithoutCustomerInput = {
    balance: number
    transaction_type: string
    collection_method: string
    paid: number
    remission: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customertype: customertypeCreateNestedOneWithoutCustomerpaymentInput
  }

  export type customerpaymentUncheckedCreateWithoutCustomerInput = {
    id?: number
    customertypeId: number
    balance: number
    transaction_type: string
    collection_method: string
    paid: number
    remission: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerpaymentCreateOrConnectWithoutCustomerInput = {
    where: customerpaymentWhereUniqueInput
    create: XOR<customerpaymentCreateWithoutCustomerInput, customerpaymentUncheckedCreateWithoutCustomerInput>
  }

  export type customerpaymentCreateManyCustomerInputEnvelope = {
    data: customerpaymentCreateManyCustomerInput | customerpaymentCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type customertypeUpsertWithoutCustomerInput = {
    update: XOR<customertypeUpdateWithoutCustomerInput, customertypeUncheckedUpdateWithoutCustomerInput>
    create: XOR<customertypeCreateWithoutCustomerInput, customertypeUncheckedCreateWithoutCustomerInput>
    where?: customertypeWhereInput
  }

  export type customertypeUpdateToOneWithWhereWithoutCustomerInput = {
    where?: customertypeWhereInput
    data: XOR<customertypeUpdateWithoutCustomerInput, customertypeUncheckedUpdateWithoutCustomerInput>
  }

  export type customertypeUpdateWithoutCustomerInput = {
    type_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerpayment?: customerpaymentUpdateManyWithoutCustomertypeNestedInput
  }

  export type customertypeUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerpayment?: customerpaymentUncheckedUpdateManyWithoutCustomertypeNestedInput
  }

  export type customerdetailsUpsertWithWhereUniqueWithoutCustomerInput = {
    where: customerdetailsWhereUniqueInput
    update: XOR<customerdetailsUpdateWithoutCustomerInput, customerdetailsUncheckedUpdateWithoutCustomerInput>
    create: XOR<customerdetailsCreateWithoutCustomerInput, customerdetailsUncheckedCreateWithoutCustomerInput>
  }

  export type customerdetailsUpdateWithWhereUniqueWithoutCustomerInput = {
    where: customerdetailsWhereUniqueInput
    data: XOR<customerdetailsUpdateWithoutCustomerInput, customerdetailsUncheckedUpdateWithoutCustomerInput>
  }

  export type customerdetailsUpdateManyWithWhereWithoutCustomerInput = {
    where: customerdetailsScalarWhereInput
    data: XOR<customerdetailsUpdateManyMutationInput, customerdetailsUncheckedUpdateManyWithoutCustomerInput>
  }

  export type customerdetailsScalarWhereInput = {
    AND?: customerdetailsScalarWhereInput | customerdetailsScalarWhereInput[]
    OR?: customerdetailsScalarWhereInput[]
    NOT?: customerdetailsScalarWhereInput | customerdetailsScalarWhereInput[]
    id?: IntFilter<"customerdetails"> | number
    customerId?: IntFilter<"customerdetails"> | number
    customer_name?: StringFilter<"customerdetails"> | string
    mob_no?: StringFilter<"customerdetails"> | string
    address?: StringFilter<"customerdetails"> | string
    description?: StringFilter<"customerdetails"> | string
    createdAt?: DateTimeFilter<"customerdetails"> | Date | string
    updatedAt?: DateTimeFilter<"customerdetails"> | Date | string
  }

  export type salesUpsertWithWhereUniqueWithoutCustomerInput = {
    where: salesWhereUniqueInput
    update: XOR<salesUpdateWithoutCustomerInput, salesUncheckedUpdateWithoutCustomerInput>
    create: XOR<salesCreateWithoutCustomerInput, salesUncheckedCreateWithoutCustomerInput>
  }

  export type salesUpdateWithWhereUniqueWithoutCustomerInput = {
    where: salesWhereUniqueInput
    data: XOR<salesUpdateWithoutCustomerInput, salesUncheckedUpdateWithoutCustomerInput>
  }

  export type salesUpdateManyWithWhereWithoutCustomerInput = {
    where: salesScalarWhereInput
    data: XOR<salesUpdateManyMutationInput, salesUncheckedUpdateManyWithoutCustomerInput>
  }

  export type salescustomertrackerUpsertWithWhereUniqueWithoutCustomerInput = {
    where: salescustomertrackerWhereUniqueInput
    update: XOR<salescustomertrackerUpdateWithoutCustomerInput, salescustomertrackerUncheckedUpdateWithoutCustomerInput>
    create: XOR<salescustomertrackerCreateWithoutCustomerInput, salescustomertrackerUncheckedCreateWithoutCustomerInput>
  }

  export type salescustomertrackerUpdateWithWhereUniqueWithoutCustomerInput = {
    where: salescustomertrackerWhereUniqueInput
    data: XOR<salescustomertrackerUpdateWithoutCustomerInput, salescustomertrackerUncheckedUpdateWithoutCustomerInput>
  }

  export type salescustomertrackerUpdateManyWithWhereWithoutCustomerInput = {
    where: salescustomertrackerScalarWhereInput
    data: XOR<salescustomertrackerUpdateManyMutationInput, salescustomertrackerUncheckedUpdateManyWithoutCustomerInput>
  }

  export type salescustomertrackerScalarWhereInput = {
    AND?: salescustomertrackerScalarWhereInput | salescustomertrackerScalarWhereInput[]
    OR?: salescustomertrackerScalarWhereInput[]
    NOT?: salescustomertrackerScalarWhereInput | salescustomertrackerScalarWhereInput[]
    id?: IntFilter<"salescustomertracker"> | number
    customerId?: IntFilter<"salescustomertracker"> | number
    curr_balance?: FloatFilter<"salescustomertracker"> | number
    payment_type?: StringFilter<"salescustomertracker"> | string
    createdAt?: DateTimeFilter<"salescustomertracker"> | Date | string
    updatedAt?: DateTimeFilter<"salescustomertracker"> | Date | string
  }

  export type customerledgerUpsertWithWhereUniqueWithoutCustomerInput = {
    where: customerledgerWhereUniqueInput
    update: XOR<customerledgerUpdateWithoutCustomerInput, customerledgerUncheckedUpdateWithoutCustomerInput>
    create: XOR<customerledgerCreateWithoutCustomerInput, customerledgerUncheckedCreateWithoutCustomerInput>
  }

  export type customerledgerUpdateWithWhereUniqueWithoutCustomerInput = {
    where: customerledgerWhereUniqueInput
    data: XOR<customerledgerUpdateWithoutCustomerInput, customerledgerUncheckedUpdateWithoutCustomerInput>
  }

  export type customerledgerUpdateManyWithWhereWithoutCustomerInput = {
    where: customerledgerScalarWhereInput
    data: XOR<customerledgerUpdateManyMutationInput, customerledgerUncheckedUpdateManyWithoutCustomerInput>
  }

  export type customerledgerScalarWhereInput = {
    AND?: customerledgerScalarWhereInput | customerledgerScalarWhereInput[]
    OR?: customerledgerScalarWhereInput[]
    NOT?: customerledgerScalarWhereInput | customerledgerScalarWhereInput[]
    id?: IntFilter<"customerledger"> | number
    customerId?: IntFilter<"customerledger"> | number
    payment_type?: StringFilter<"customerledger"> | string
    credit?: FloatFilter<"customerledger"> | number
    debit?: FloatFilter<"customerledger"> | number
    balance?: FloatFilter<"customerledger"> | number
    voucher_no?: StringFilter<"customerledger"> | string
    createdAt?: DateTimeFilter<"customerledger"> | Date | string
    updatedAt?: DateTimeFilter<"customerledger"> | Date | string
  }

  export type customerpaymentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: customerpaymentWhereUniqueInput
    update: XOR<customerpaymentUpdateWithoutCustomerInput, customerpaymentUncheckedUpdateWithoutCustomerInput>
    create: XOR<customerpaymentCreateWithoutCustomerInput, customerpaymentUncheckedCreateWithoutCustomerInput>
  }

  export type customerpaymentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: customerpaymentWhereUniqueInput
    data: XOR<customerpaymentUpdateWithoutCustomerInput, customerpaymentUncheckedUpdateWithoutCustomerInput>
  }

  export type customerpaymentUpdateManyWithWhereWithoutCustomerInput = {
    where: customerpaymentScalarWhereInput
    data: XOR<customerpaymentUpdateManyMutationInput, customerpaymentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type customerCreateWithoutSalescustomertrackerInput = {
    customer_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: customertypeCreateNestedOneWithoutCustomerInput
    customerdetails?: customerdetailsCreateNestedManyWithoutCustomerInput
    sales?: salesCreateNestedManyWithoutCustomerInput
    customerledger?: customerledgerCreateNestedManyWithoutCustomerInput
    customerpayment?: customerpaymentCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutSalescustomertrackerInput = {
    id?: number
    customer_name: string
    customertypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customerdetails?: customerdetailsUncheckedCreateNestedManyWithoutCustomerInput
    sales?: salesUncheckedCreateNestedManyWithoutCustomerInput
    customerledger?: customerledgerUncheckedCreateNestedManyWithoutCustomerInput
    customerpayment?: customerpaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutSalescustomertrackerInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutSalescustomertrackerInput, customerUncheckedCreateWithoutSalescustomertrackerInput>
  }

  export type customerUpsertWithoutSalescustomertrackerInput = {
    update: XOR<customerUpdateWithoutSalescustomertrackerInput, customerUncheckedUpdateWithoutSalescustomertrackerInput>
    create: XOR<customerCreateWithoutSalescustomertrackerInput, customerUncheckedCreateWithoutSalescustomertrackerInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutSalescustomertrackerInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutSalescustomertrackerInput, customerUncheckedUpdateWithoutSalescustomertrackerInput>
  }

  export type customerUpdateWithoutSalescustomertrackerInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: customertypeUpdateOneRequiredWithoutCustomerNestedInput
    customerdetails?: customerdetailsUpdateManyWithoutCustomerNestedInput
    sales?: salesUpdateManyWithoutCustomerNestedInput
    customerledger?: customerledgerUpdateManyWithoutCustomerNestedInput
    customerpayment?: customerpaymentUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutSalescustomertrackerInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    customertypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerdetails?: customerdetailsUncheckedUpdateManyWithoutCustomerNestedInput
    sales?: salesUncheckedUpdateManyWithoutCustomerNestedInput
    customerledger?: customerledgerUncheckedUpdateManyWithoutCustomerNestedInput
    customerpayment?: customerpaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customertypeCreateWithoutCustomerpaymentInput = {
    type_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: customerCreateNestedManyWithoutCustomerIdInput
  }

  export type customertypeUncheckedCreateWithoutCustomerpaymentInput = {
    id?: number
    type_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: customerUncheckedCreateNestedManyWithoutCustomerIdInput
  }

  export type customertypeCreateOrConnectWithoutCustomerpaymentInput = {
    where: customertypeWhereUniqueInput
    create: XOR<customertypeCreateWithoutCustomerpaymentInput, customertypeUncheckedCreateWithoutCustomerpaymentInput>
  }

  export type customerCreateWithoutCustomerpaymentInput = {
    customer_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: customertypeCreateNestedOneWithoutCustomerInput
    customerdetails?: customerdetailsCreateNestedManyWithoutCustomerInput
    sales?: salesCreateNestedManyWithoutCustomerInput
    salescustomertracker?: salescustomertrackerCreateNestedManyWithoutCustomerInput
    customerledger?: customerledgerCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutCustomerpaymentInput = {
    id?: number
    customer_name: string
    customertypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customerdetails?: customerdetailsUncheckedCreateNestedManyWithoutCustomerInput
    sales?: salesUncheckedCreateNestedManyWithoutCustomerInput
    salescustomertracker?: salescustomertrackerUncheckedCreateNestedManyWithoutCustomerInput
    customerledger?: customerledgerUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutCustomerpaymentInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutCustomerpaymentInput, customerUncheckedCreateWithoutCustomerpaymentInput>
  }

  export type customertypeUpsertWithoutCustomerpaymentInput = {
    update: XOR<customertypeUpdateWithoutCustomerpaymentInput, customertypeUncheckedUpdateWithoutCustomerpaymentInput>
    create: XOR<customertypeCreateWithoutCustomerpaymentInput, customertypeUncheckedCreateWithoutCustomerpaymentInput>
    where?: customertypeWhereInput
  }

  export type customertypeUpdateToOneWithWhereWithoutCustomerpaymentInput = {
    where?: customertypeWhereInput
    data: XOR<customertypeUpdateWithoutCustomerpaymentInput, customertypeUncheckedUpdateWithoutCustomerpaymentInput>
  }

  export type customertypeUpdateWithoutCustomerpaymentInput = {
    type_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: customerUpdateManyWithoutCustomerIdNestedInput
  }

  export type customertypeUncheckedUpdateWithoutCustomerpaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: customerUncheckedUpdateManyWithoutCustomerIdNestedInput
  }

  export type customerUpsertWithoutCustomerpaymentInput = {
    update: XOR<customerUpdateWithoutCustomerpaymentInput, customerUncheckedUpdateWithoutCustomerpaymentInput>
    create: XOR<customerCreateWithoutCustomerpaymentInput, customerUncheckedCreateWithoutCustomerpaymentInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutCustomerpaymentInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutCustomerpaymentInput, customerUncheckedUpdateWithoutCustomerpaymentInput>
  }

  export type customerUpdateWithoutCustomerpaymentInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: customertypeUpdateOneRequiredWithoutCustomerNestedInput
    customerdetails?: customerdetailsUpdateManyWithoutCustomerNestedInput
    sales?: salesUpdateManyWithoutCustomerNestedInput
    salescustomertracker?: salescustomertrackerUpdateManyWithoutCustomerNestedInput
    customerledger?: customerledgerUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutCustomerpaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    customertypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerdetails?: customerdetailsUncheckedUpdateManyWithoutCustomerNestedInput
    sales?: salesUncheckedUpdateManyWithoutCustomerNestedInput
    salescustomertracker?: salescustomertrackerUncheckedUpdateManyWithoutCustomerNestedInput
    customerledger?: customerledgerUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerCreateWithoutCustomerledgerInput = {
    customer_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: customertypeCreateNestedOneWithoutCustomerInput
    customerdetails?: customerdetailsCreateNestedManyWithoutCustomerInput
    sales?: salesCreateNestedManyWithoutCustomerInput
    salescustomertracker?: salescustomertrackerCreateNestedManyWithoutCustomerInput
    customerpayment?: customerpaymentCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutCustomerledgerInput = {
    id?: number
    customer_name: string
    customertypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customerdetails?: customerdetailsUncheckedCreateNestedManyWithoutCustomerInput
    sales?: salesUncheckedCreateNestedManyWithoutCustomerInput
    salescustomertracker?: salescustomertrackerUncheckedCreateNestedManyWithoutCustomerInput
    customerpayment?: customerpaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutCustomerledgerInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutCustomerledgerInput, customerUncheckedCreateWithoutCustomerledgerInput>
  }

  export type customerUpsertWithoutCustomerledgerInput = {
    update: XOR<customerUpdateWithoutCustomerledgerInput, customerUncheckedUpdateWithoutCustomerledgerInput>
    create: XOR<customerCreateWithoutCustomerledgerInput, customerUncheckedCreateWithoutCustomerledgerInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutCustomerledgerInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutCustomerledgerInput, customerUncheckedUpdateWithoutCustomerledgerInput>
  }

  export type customerUpdateWithoutCustomerledgerInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: customertypeUpdateOneRequiredWithoutCustomerNestedInput
    customerdetails?: customerdetailsUpdateManyWithoutCustomerNestedInput
    sales?: salesUpdateManyWithoutCustomerNestedInput
    salescustomertracker?: salescustomertrackerUpdateManyWithoutCustomerNestedInput
    customerpayment?: customerpaymentUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutCustomerledgerInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    customertypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerdetails?: customerdetailsUncheckedUpdateManyWithoutCustomerNestedInput
    sales?: salesUncheckedUpdateManyWithoutCustomerNestedInput
    salescustomertracker?: salescustomertrackerUncheckedUpdateManyWithoutCustomerNestedInput
    customerpayment?: customerpaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type supplierCreateWithoutPurchasesuppliertrackInput = {
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsCreateNestedManyWithoutPurchaseitemsIdInput
    Purchase?: purchaseCreateNestedManyWithoutSupplierInput
    transaction?: transactionCreateNestedManyWithoutSupplierInput
    supplierledger?: supplierledgerCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateWithoutPurchasesuppliertrackInput = {
    id?: number
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitemsIdInput
    Purchase?: purchaseUncheckedCreateNestedManyWithoutSupplierInput
    transaction?: transactionUncheckedCreateNestedManyWithoutSupplierInput
    supplierledger?: supplierledgerUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierCreateOrConnectWithoutPurchasesuppliertrackInput = {
    where: supplierWhereUniqueInput
    create: XOR<supplierCreateWithoutPurchasesuppliertrackInput, supplierUncheckedCreateWithoutPurchasesuppliertrackInput>
  }

  export type supplierUpsertWithoutPurchasesuppliertrackInput = {
    update: XOR<supplierUpdateWithoutPurchasesuppliertrackInput, supplierUncheckedUpdateWithoutPurchasesuppliertrackInput>
    create: XOR<supplierCreateWithoutPurchasesuppliertrackInput, supplierUncheckedCreateWithoutPurchasesuppliertrackInput>
    where?: supplierWhereInput
  }

  export type supplierUpdateToOneWithWhereWithoutPurchasesuppliertrackInput = {
    where?: supplierWhereInput
    data: XOR<supplierUpdateWithoutPurchasesuppliertrackInput, supplierUncheckedUpdateWithoutPurchasesuppliertrackInput>
  }

  export type supplierUpdateWithoutPurchasesuppliertrackInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUpdateManyWithoutPurchaseitemsIdNestedInput
    Purchase?: purchaseUpdateManyWithoutSupplierNestedInput
    transaction?: transactionUpdateManyWithoutSupplierNestedInput
    supplierledger?: supplierledgerUpdateManyWithoutSupplierNestedInput
  }

  export type supplierUncheckedUpdateWithoutPurchasesuppliertrackInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUncheckedUpdateManyWithoutPurchaseitemsIdNestedInput
    Purchase?: purchaseUncheckedUpdateManyWithoutSupplierNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutSupplierNestedInput
    supplierledger?: supplierledgerUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type supplierCreateWithoutTransactionInput = {
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsCreateNestedManyWithoutPurchaseitemsIdInput
    Purchase?: purchaseCreateNestedManyWithoutSupplierInput
    purchasesuppliertrack?: purchasesuppliertrackCreateNestedManyWithoutSupplierInput
    supplierledger?: supplierledgerCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateWithoutTransactionInput = {
    id?: number
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitemsIdInput
    Purchase?: purchaseUncheckedCreateNestedManyWithoutSupplierInput
    purchasesuppliertrack?: purchasesuppliertrackUncheckedCreateNestedManyWithoutSupplierInput
    supplierledger?: supplierledgerUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierCreateOrConnectWithoutTransactionInput = {
    where: supplierWhereUniqueInput
    create: XOR<supplierCreateWithoutTransactionInput, supplierUncheckedCreateWithoutTransactionInput>
  }

  export type supplierUpsertWithoutTransactionInput = {
    update: XOR<supplierUpdateWithoutTransactionInput, supplierUncheckedUpdateWithoutTransactionInput>
    create: XOR<supplierCreateWithoutTransactionInput, supplierUncheckedCreateWithoutTransactionInput>
    where?: supplierWhereInput
  }

  export type supplierUpdateToOneWithWhereWithoutTransactionInput = {
    where?: supplierWhereInput
    data: XOR<supplierUpdateWithoutTransactionInput, supplierUncheckedUpdateWithoutTransactionInput>
  }

  export type supplierUpdateWithoutTransactionInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUpdateManyWithoutPurchaseitemsIdNestedInput
    Purchase?: purchaseUpdateManyWithoutSupplierNestedInput
    purchasesuppliertrack?: purchasesuppliertrackUpdateManyWithoutSupplierNestedInput
    supplierledger?: supplierledgerUpdateManyWithoutSupplierNestedInput
  }

  export type supplierUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUncheckedUpdateManyWithoutPurchaseitemsIdNestedInput
    Purchase?: purchaseUncheckedUpdateManyWithoutSupplierNestedInput
    purchasesuppliertrack?: purchasesuppliertrackUncheckedUpdateManyWithoutSupplierNestedInput
    supplierledger?: supplierledgerUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type supplierCreateWithoutSupplierledgerInput = {
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsCreateNestedManyWithoutPurchaseitemsIdInput
    Purchase?: purchaseCreateNestedManyWithoutSupplierInput
    purchasesuppliertrack?: purchasesuppliertrackCreateNestedManyWithoutSupplierInput
    transaction?: transactionCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateWithoutSupplierledgerInput = {
    id?: number
    supplier_name: string
    contact_person: string
    mobile_number: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseitems?: purchaseitemsUncheckedCreateNestedManyWithoutPurchaseitemsIdInput
    Purchase?: purchaseUncheckedCreateNestedManyWithoutSupplierInput
    purchasesuppliertrack?: purchasesuppliertrackUncheckedCreateNestedManyWithoutSupplierInput
    transaction?: transactionUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierCreateOrConnectWithoutSupplierledgerInput = {
    where: supplierWhereUniqueInput
    create: XOR<supplierCreateWithoutSupplierledgerInput, supplierUncheckedCreateWithoutSupplierledgerInput>
  }

  export type supplierUpsertWithoutSupplierledgerInput = {
    update: XOR<supplierUpdateWithoutSupplierledgerInput, supplierUncheckedUpdateWithoutSupplierledgerInput>
    create: XOR<supplierCreateWithoutSupplierledgerInput, supplierUncheckedCreateWithoutSupplierledgerInput>
    where?: supplierWhereInput
  }

  export type supplierUpdateToOneWithWhereWithoutSupplierledgerInput = {
    where?: supplierWhereInput
    data: XOR<supplierUpdateWithoutSupplierledgerInput, supplierUncheckedUpdateWithoutSupplierledgerInput>
  }

  export type supplierUpdateWithoutSupplierledgerInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUpdateManyWithoutPurchaseitemsIdNestedInput
    Purchase?: purchaseUpdateManyWithoutSupplierNestedInput
    purchasesuppliertrack?: purchasesuppliertrackUpdateManyWithoutSupplierNestedInput
    transaction?: transactionUpdateManyWithoutSupplierNestedInput
  }

  export type supplierUncheckedUpdateWithoutSupplierledgerInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUncheckedUpdateManyWithoutPurchaseitemsIdNestedInput
    Purchase?: purchaseUncheckedUpdateManyWithoutSupplierNestedInput
    purchasesuppliertrack?: purchasesuppliertrackUncheckedUpdateManyWithoutSupplierNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type customerCreateWithoutCustomerdetailsInput = {
    customer_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: customertypeCreateNestedOneWithoutCustomerInput
    sales?: salesCreateNestedManyWithoutCustomerInput
    salescustomertracker?: salescustomertrackerCreateNestedManyWithoutCustomerInput
    customerledger?: customerledgerCreateNestedManyWithoutCustomerInput
    customerpayment?: customerpaymentCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutCustomerdetailsInput = {
    id?: number
    customer_name: string
    customertypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: salesUncheckedCreateNestedManyWithoutCustomerInput
    salescustomertracker?: salescustomertrackerUncheckedCreateNestedManyWithoutCustomerInput
    customerledger?: customerledgerUncheckedCreateNestedManyWithoutCustomerInput
    customerpayment?: customerpaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutCustomerdetailsInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutCustomerdetailsInput, customerUncheckedCreateWithoutCustomerdetailsInput>
  }

  export type customerUpsertWithoutCustomerdetailsInput = {
    update: XOR<customerUpdateWithoutCustomerdetailsInput, customerUncheckedUpdateWithoutCustomerdetailsInput>
    create: XOR<customerCreateWithoutCustomerdetailsInput, customerUncheckedCreateWithoutCustomerdetailsInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutCustomerdetailsInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutCustomerdetailsInput, customerUncheckedUpdateWithoutCustomerdetailsInput>
  }

  export type customerUpdateWithoutCustomerdetailsInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: customertypeUpdateOneRequiredWithoutCustomerNestedInput
    sales?: salesUpdateManyWithoutCustomerNestedInput
    salescustomertracker?: salescustomertrackerUpdateManyWithoutCustomerNestedInput
    customerledger?: customerledgerUpdateManyWithoutCustomerNestedInput
    customerpayment?: customerpaymentUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutCustomerdetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    customertypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: salesUncheckedUpdateManyWithoutCustomerNestedInput
    salescustomertracker?: salescustomertrackerUncheckedUpdateManyWithoutCustomerNestedInput
    customerledger?: customerledgerUncheckedUpdateManyWithoutCustomerNestedInput
    customerpayment?: customerpaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type itemsCreateManyItems_categoryInput = {
    id?: number
    items_name: string
    description: string
    brandsId: number
    unitsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemsUpdateWithoutItems_categoryInput = {
    items_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUpdateManyWithoutPurchaseitems_itemsNestedInput
    Purchase?: purchaseUpdateManyWithoutPurchase_itemsNestedInput
    sales?: salesUpdateManyWithoutItemsNestedInput
    items_brands?: brandsUpdateOneRequiredWithoutItemsNestedInput
    items_units?: unitsUpdateOneRequiredWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutItems_categoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    items_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    brandsId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUncheckedUpdateManyWithoutPurchaseitems_itemsNestedInput
    Purchase?: purchaseUncheckedUpdateManyWithoutPurchase_itemsNestedInput
    sales?: salesUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateManyWithoutItems_categoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    items_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    brandsId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemsCreateManyItems_unitsInput = {
    id?: number
    items_name: string
    categoryId: number
    description: string
    brandsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemsUpdateWithoutItems_unitsInput = {
    items_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUpdateManyWithoutPurchaseitems_itemsNestedInput
    Purchase?: purchaseUpdateManyWithoutPurchase_itemsNestedInput
    sales?: salesUpdateManyWithoutItemsNestedInput
    items_category?: categoryUpdateOneRequiredWithoutItemsNestedInput
    items_brands?: brandsUpdateOneRequiredWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutItems_unitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    items_name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    brandsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUncheckedUpdateManyWithoutPurchaseitems_itemsNestedInput
    Purchase?: purchaseUncheckedUpdateManyWithoutPurchase_itemsNestedInput
    sales?: salesUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateManyWithoutItems_unitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    items_name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    brandsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemsCreateManyItems_brandsInput = {
    id?: number
    items_name: string
    categoryId: number
    description: string
    unitsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemsUpdateWithoutItems_brandsInput = {
    items_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUpdateManyWithoutPurchaseitems_itemsNestedInput
    Purchase?: purchaseUpdateManyWithoutPurchase_itemsNestedInput
    sales?: salesUpdateManyWithoutItemsNestedInput
    items_category?: categoryUpdateOneRequiredWithoutItemsNestedInput
    items_units?: unitsUpdateOneRequiredWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutItems_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    items_name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    unitsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems?: purchaseitemsUncheckedUpdateManyWithoutPurchaseitems_itemsNestedInput
    Purchase?: purchaseUncheckedUpdateManyWithoutPurchase_itemsNestedInput
    sales?: salesUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateManyWithoutItems_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    items_name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    unitsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseitemsCreateManyPurchaseitems_itemsInput = {
    id?: number
    supplierId: number
    purchase_qty: number
    price_per_unit: number
    price_avg: number
    purchase_total: number
    subtotal_amount: number
    purchase_update_qty: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseCreateManyPurchase_itemsInput = {
    id?: number
    supplierId: number
    purchase_qty: number
    price_per_unit: number
    purchase_total: number
    subtotal_amount: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesCreateManyItemsInput = {
    id?: number
    customerId: number
    sale_qty: number
    sales_price: number
    discount: number
    transport_cost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseitemsUpdateWithoutPurchaseitems_itemsInput = {
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    price_avg?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    purchase_update_qty?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitemsId?: supplierUpdateOneRequiredWithoutPurchaseitemsNestedInput
  }

  export type purchaseitemsUncheckedUpdateWithoutPurchaseitems_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    price_avg?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    purchase_update_qty?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseitemsUncheckedUpdateManyWithoutPurchaseitems_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    price_avg?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    purchase_update_qty?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseUpdateWithoutPurchase_itemsInput = {
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: supplierUpdateOneRequiredWithoutPurchaseNestedInput
  }

  export type purchaseUncheckedUpdateWithoutPurchase_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseUncheckedUpdateManyWithoutPurchase_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesUpdateWithoutItemsInput = {
    sale_qty?: FloatFieldUpdateOperationsInput | number
    sales_price?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    transport_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: customerUpdateOneRequiredWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    sale_qty?: FloatFieldUpdateOperationsInput | number
    sales_price?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    transport_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesUncheckedUpdateManyWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    sale_qty?: FloatFieldUpdateOperationsInput | number
    sales_price?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    transport_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseitemsCreateManyPurchaseitemsIdInput = {
    id?: number
    itemId: number
    purchase_qty: number
    price_per_unit: number
    price_avg: number
    purchase_total: number
    subtotal_amount: number
    purchase_update_qty: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseCreateManySupplierInput = {
    id?: number
    itemId: number
    purchase_qty: number
    price_per_unit: number
    purchase_total: number
    subtotal_amount: number
    tax_Id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchasesuppliertrackCreateManySupplierInput = {
    id?: number
    curr_balance: number
    payment_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionCreateManySupplierInput = {
    id?: number
    balance: number
    transaction_type: string
    transaction_method: string
    payment: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type supplierledgerCreateManySupplierInput = {
    id?: number
    payment_type: string
    voucher_no: string
    credit: number
    debit: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseitemsUpdateWithoutPurchaseitemsIdInput = {
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    price_avg?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    purchase_update_qty?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseitems_items?: itemsUpdateOneRequiredWithoutPurchaseitemsNestedInput
  }

  export type purchaseitemsUncheckedUpdateWithoutPurchaseitemsIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    price_avg?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    purchase_update_qty?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseitemsUncheckedUpdateManyWithoutPurchaseitemsIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    price_avg?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    purchase_update_qty?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseUpdateWithoutSupplierInput = {
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_items?: itemsUpdateOneRequiredWithoutPurchaseNestedInput
  }

  export type purchaseUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    purchase_qty?: FloatFieldUpdateOperationsInput | number
    price_per_unit?: FloatFieldUpdateOperationsInput | number
    purchase_total?: FloatFieldUpdateOperationsInput | number
    subtotal_amount?: FloatFieldUpdateOperationsInput | number
    tax_Id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchasesuppliertrackUpdateWithoutSupplierInput = {
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchasesuppliertrackUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchasesuppliertrackUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionUpdateWithoutSupplierInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    transaction_method?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    transaction_method?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    transaction_method?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplierledgerUpdateWithoutSupplierInput = {
    payment_type?: StringFieldUpdateOperationsInput | string
    voucher_no?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplierledgerUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    voucher_no?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplierledgerUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    voucher_no?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerCreateManyCustomerIdInput = {
    id?: number
    customer_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerpaymentCreateManyCustomertypeInput = {
    id?: number
    customerId: number
    balance: number
    transaction_type: string
    collection_method: string
    paid: number
    remission: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerUpdateWithoutCustomerIdInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerdetails?: customerdetailsUpdateManyWithoutCustomerNestedInput
    sales?: salesUpdateManyWithoutCustomerNestedInput
    salescustomertracker?: salescustomertrackerUpdateManyWithoutCustomerNestedInput
    customerledger?: customerledgerUpdateManyWithoutCustomerNestedInput
    customerpayment?: customerpaymentUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutCustomerIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerdetails?: customerdetailsUncheckedUpdateManyWithoutCustomerNestedInput
    sales?: salesUncheckedUpdateManyWithoutCustomerNestedInput
    salescustomertracker?: salescustomertrackerUncheckedUpdateManyWithoutCustomerNestedInput
    customerledger?: customerledgerUncheckedUpdateManyWithoutCustomerNestedInput
    customerpayment?: customerpaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateManyWithoutCustomerIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerpaymentUpdateWithoutCustomertypeInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    collection_method?: StringFieldUpdateOperationsInput | string
    paid?: FloatFieldUpdateOperationsInput | number
    remission?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: customerUpdateOneRequiredWithoutCustomerpaymentNestedInput
  }

  export type customerpaymentUncheckedUpdateWithoutCustomertypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    collection_method?: StringFieldUpdateOperationsInput | string
    paid?: FloatFieldUpdateOperationsInput | number
    remission?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerpaymentUncheckedUpdateManyWithoutCustomertypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    collection_method?: StringFieldUpdateOperationsInput | string
    paid?: FloatFieldUpdateOperationsInput | number
    remission?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerdetailsCreateManyCustomerInput = {
    id?: number
    customer_name: string
    mob_no: string
    address: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesCreateManyCustomerInput = {
    id?: number
    itemId: number
    sale_qty: number
    sales_price: number
    discount: number
    transport_cost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salescustomertrackerCreateManyCustomerInput = {
    id?: number
    curr_balance: number
    payment_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerledgerCreateManyCustomerInput = {
    id?: number
    payment_type: string
    credit: number
    debit: number
    balance: number
    voucher_no: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerpaymentCreateManyCustomerInput = {
    id?: number
    customertypeId: number
    balance: number
    transaction_type: string
    collection_method: string
    paid: number
    remission: number
    curr_balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerdetailsUpdateWithoutCustomerInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    mob_no?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerdetailsUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    mob_no?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerdetailsUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    mob_no?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesUpdateWithoutCustomerInput = {
    sale_qty?: FloatFieldUpdateOperationsInput | number
    sales_price?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    transport_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: itemsUpdateOneRequiredWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    sale_qty?: FloatFieldUpdateOperationsInput | number
    sales_price?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    transport_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    sale_qty?: FloatFieldUpdateOperationsInput | number
    sales_price?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    transport_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salescustomertrackerUpdateWithoutCustomerInput = {
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salescustomertrackerUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salescustomertrackerUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerledgerUpdateWithoutCustomerInput = {
    payment_type?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    voucher_no?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerledgerUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    voucher_no?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerledgerUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_type?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    voucher_no?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerpaymentUpdateWithoutCustomerInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    collection_method?: StringFieldUpdateOperationsInput | string
    paid?: FloatFieldUpdateOperationsInput | number
    remission?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customertype?: customertypeUpdateOneRequiredWithoutCustomerpaymentNestedInput
  }

  export type customerpaymentUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    customertypeId?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    collection_method?: StringFieldUpdateOperationsInput | string
    paid?: FloatFieldUpdateOperationsInput | number
    remission?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerpaymentUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    customertypeId?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    collection_method?: StringFieldUpdateOperationsInput | string
    paid?: FloatFieldUpdateOperationsInput | number
    remission?: FloatFieldUpdateOperationsInput | number
    curr_balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitsCountOutputTypeDefaultArgs instead
     */
    export type UnitsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandsCountOutputTypeDefaultArgs instead
     */
    export type BrandsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemsCountOutputTypeDefaultArgs instead
     */
    export type ItemsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomertypeCountOutputTypeDefaultArgs instead
     */
    export type CustomertypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomertypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use categoryDefaultArgs instead
     */
    export type categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = categoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use unitsDefaultArgs instead
     */
    export type unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = unitsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use brandsDefaultArgs instead
     */
    export type brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = brandsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use itemsDefaultArgs instead
     */
    export type itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = itemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use supplierDefaultArgs instead
     */
    export type supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = supplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use purchaseitemsDefaultArgs instead
     */
    export type purchaseitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = purchaseitemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use purchaseDefaultArgs instead
     */
    export type purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = purchaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use salesDefaultArgs instead
     */
    export type salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = salesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use customertypeDefaultArgs instead
     */
    export type customertypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = customertypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use customerDefaultArgs instead
     */
    export type customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = customerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use salescustomertrackerDefaultArgs instead
     */
    export type salescustomertrackerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = salescustomertrackerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use customerpaymentDefaultArgs instead
     */
    export type customerpaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = customerpaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use customerledgerDefaultArgs instead
     */
    export type customerledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = customerledgerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use purchasesuppliertrackDefaultArgs instead
     */
    export type purchasesuppliertrackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = purchasesuppliertrackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use transactionDefaultArgs instead
     */
    export type transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = transactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use supplierledgerDefaultArgs instead
     */
    export type supplierledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = supplierledgerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use customerdetailsDefaultArgs instead
     */
    export type customerdetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = customerdetailsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}